       
       
     1	2019-01-12 06:19             com/example/app/App.java             Page 1
       
       
     2	package com.example.app;
       
     3	import com.example.dep.Dep;
       
     4	public class App 
     5	{
     6	    public static void main( String[] args )
     7	    {
     8	        Dep.hello( "GitLab" );
     9	    }
    10	}
    11	
       
    12	2019-01-11 06:34     tripleo/elijah/gen/java/JavaCodeGen.java     Page 1
       
       
    13	package tripleo.elijah.gen.java;
    14	
    15	import java.util.*;
    16	
    17	import javassist.*;
    18	import tripleo.elijah.lang.*;
    19	import tripleo.elijah.util.NotImplementedException;
    20	
    21	public class JavaCodeGen {
    22	
    23		final ClassPool cp = new ClassPool();
    24	
    25		private List<OS_Element> finished = new ArrayList<OS_Element>();;
    26	
    27		public void addClass(ClassStatement klass) {
    28			String pn = klass.parent.packageName;
    29			if (pn != null)
    30				System.out.print("package " + pn + ";");
    31			System.out.print("class " + klass.clsName + "{\n");
    32			if (elementDone(klass))
    33				try {
    34					CtClass ctc = cp.makeClass(klass.clsName);
    35					// ctc.setPackagename(pacakageName); // TODO
    36					System.out.println(ctc.toString());
    37				} catch (Exception e) {
    38					e.printStackTrace();
    39				}
    40			else {
    41				for (ClassItem element : klass.items())
    42					addClassItem(element);
    43			}
    44			System.out.print("}\n");
    45		}
    46	
    47		public void addModule(OS_Module module) {
    48			if (elementDone(module)) {
    49				try {
    50					CtClass ctc = cp.makeClass(module.moduleName);
    51					// ctc.setPackagename(pacakageName); // TODO
    52					System.out.println(ctc.toString());
    53				} catch (Exception e) {
    54					e.printStackTrace();
    55				}
    56			} else {
    57				synchronized (module.items) {
    58					for (ModuleItem element : module.items)
    59						addModuleItem(element);
    60	
    61				}
    62	
    63			}
    64		}
    65	
    66		private boolean elementDone(OS_Element module) {
    67			boolean contains = finished.contains(module);
    68			// if (!contains)
    69	
       
    70	2019-01-11 06:34     tripleo/elijah/gen/java/JavaCodeGen.java     Page 2
       
       
    71			// finished.add(module);
    72			return contains;
    73		}
    74	
    75		private void addModuleItem(ModuleItem element) {
    76			// TODO Auto-generated method stub
    77			if (element instanceof ClassStatement) {
    78				ClassStatement cl = (ClassStatement) element;
    79				addClass(cl);
    80			} else if (element instanceof ImportStatement) {
    81				ImportStatement imp = (ImportStatement) element;
    82				addImport(imp);
    83			}
    84			// if (elementDone(element)) {
    85			// try {
    86			// CtClass ctc = cp.makeClass(element.);
    87			// // ctc.setPackagename(pacakageName); // TODO
    88			// System.out.println(ctc.toString());
    89			// } catch (Exception e) {
    90			// e.printStackTrace();
    91			// }
    92			// } else {
    93			// synchronized (element.items) {
    94			// for (ModuleItem element : module.items)
    95			// addModuleItem(element);
    96			//
    97			// }
    98			//
    99			// }
   100		}
   101	
   102		private void addImport(ImportStatement imp) {
   103			// TODO Auto-generated method stub
   104			throw new NotImplementedException();
   105		}
   106	
   107		private void addClassItem(ClassItem element) {
   108			// TODO Auto-generated method stub
   109			// throw new NotImplementedException();
   110			if (elementDone(element)) {
   111				throw new NotImplementedException();
   112			} else {
   113				if (element instanceof FunctionDef) {
   114					FunctionDef fd = (FunctionDef) element;
   115					System.out.print("void " + fd.funName + "(){\n");
   116					element.visit(this);
   117					System.out.print("}\n\n");
   118				} else
   119					element.visit(this);
   120			}
   121		}
   122	
   123		public void addFunctionItem(FunctionItem element) {
   124			// TODO Auto-generated method stub
   125			if (element instanceof VariableSequence)
   126				for (VariableStatement ii : ((VariableSequence) element).items()) {
   127	
       
   128	2019-01-11 06:34     tripleo/elijah/gen/java/JavaCodeGen.java     Page 3
       
       
   129					System.out.print("int vv" + ii.name + ";");
   130	
   131				}
   132			else {
   133				if (elementDone(element)) {
   134					throw new NotImplementedException();
   135				} else {
   136					// element.visit(this);
   137				}
   138				System.out.print(element);
   139	
   140			}
   141		}
   142	
   143	}
   144	
       
   145	2019-01-11 06:34 tripleo/elijah/lang/AbstractStatementClosure.java Page 1
       
       
   146	package tripleo.elijah.lang;
       
   147	import java.util.*;
       
       
   148	// Referenced classes of package pak2:
   149	//			StatementClosure, VariableSequence, ProcedureCallExpression, Loop, 
   150	//			YieldExpression, IfExpression
       
   151	public final class AbstractStatementClosure implements StatementClosure, StatementItem {
       
   152		public AbstractStatementClosure(Scope aParent) {
   153			// TODO Auto-generated constructor stub
   154			parent = aParent;
   155		}
       
   156		private StatementItem add(StatementItem aItem) {
   157			parent.add(aItem);
   158			return aItem;
   159		}
   160		public BlockStatement blockClosure() {
   161			bs=new BlockStatement(this.parent);
   162			add(bs);
   163			return bs;
   164		}
   165		public IExpression constructExpression() {
   166			ctex=new ConstructExpression(this.parent); 
   167			add(ctex);
   168			return null;
   169		}
   170		public IfExpression ifExpression() {
   171			ifex=new IfExpression(this.parent); 
   172			add(ifex);
   173			return ifex;
   174		}
   175		public Loop loop() {
   176			loop=new Loop();
   177			add(loop);
   178			return loop;
   179		}
   180		public StatementClosure procCallExpr() {
   181			pcex=new AbstractStatementClosure(parent); //TODO:
   182			add(pcex);
   183			return pcex;
   184		}
       
   185		public ProcedureCallExpression procedureCallExpression() {
   186			pce=new ProcedureCallExpression();
   187			add(pce);
   188			return pce;
   189		}
       
   190		public VariableSequence varSeq() {
   191			return (VariableSequence) add(vsq=new VariableSequence());
   192		}
       
   193	
       
   194	2019-01-11 06:34 tripleo/elijah/lang/AbstractStatementClosure.java Page 2
       
       
   195		private BlockStatement bs;
       
   196		private ConstructExpression ctex;
   197		private IfExpression ifex;
   198		List<StatementItem> items =new ArrayList<StatementItem>();
   199		private Loop loop;
   200		
   201		final Scope parent;
       
   202		private ProcedureCallExpression pce;
       
   203		private AbstractStatementClosure pcex;
       
   204		private VariableSequence vsq;
       
   205		private YieldExpression yiex;
       
   206		public void constructExpression(IExpression aExpr) {
   207			add((StatementItem) aExpr);
   208		}
       
   209		public void yield(IExpression aExpr) {
   210			add((StatementItem) aExpr);
   211		}
   212	}
   213	
       
   214	2019-01-11 06:34   tripleo/elijah/lang/AbstractExpression.java    Page 1
       
       
   215	package tripleo.elijah.lang;
       
   216	import java.io.IOException;
       
   217	import tripleo.elijah.util.TabbedOutputStream;
       
   218	// Referenced classes of package pak:
   219	//			IExpression, ScopeElement
       
   220	public class AbstractExpression implements IBinaryExpression, ScopeElement {
       
   221		public AbstractExpression() {
   222			left  = null;
   223			right = null;
   224			type  = null;
   225		}
       
   226		public AbstractExpression(IExpression aLeft, ExpressionType aType, IExpression aRight) {
   227			left = aLeft;
   228			type = aType;
   229			right = aRight;
   230		}
       
   231		public IExpression getLeft() {
   232			return left;
   233		}
       
   234		public IExpression getRight() {
   235			return right;
   236		}
       
   237		public ExpressionType getType() {
   238			return type;
   239		}
       
   240		public void print_osi(TabbedOutputStream $1) throws IOException {
   241			throw new IllegalStateException("please implement this method");
   242		}
       
   243		public String repr_() {
   244			return String.format("<Expression %s %s %s>", left,type,right);
   245		}
       
   246		public void set(IBinaryExpression aEx) {
   247			left=aEx.getLeft();
   248			type=aEx.getType();
   249			right=aEx.getRight();
   250		}
       
   251		public void setLeft(IExpression aLeft) {
   252			left = aLeft;
   253		}
       
   254		public void setRight(IExpression aRight) {
   255			right = aRight;
   256		}
   257	
       
   258	2019-01-11 06:34   tripleo/elijah/lang/AbstractExpression.java    Page 2
       
       
   259		public void shift(ExpressionType aType) {
   260			left=new AbstractExpression(left,type,right); //TODO
   261			type=aType;
   262			right=null;
   263		}
       
   264		public IExpression left;
   265		public IExpression right;
   266		public ExpressionType type;
       
   267		public void set(ExpressionType aIncrement) {
   268			type=aIncrement;
   269		}
   270	}
   271	
       
   272	2019-01-11 06:34  tripleo/elijah/lang/AssignmentExpression.java   Page 1
       
       
   273	// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
   274	// Jad home page: http://www.geocities.com/kpdus/jad.html
   275	// Decompiler options: packimports(3) 
   276	// Source File Name:   AssignmentExpression.java
       
   277	package tripleo.elijah.lang;
       
   278	// Referenced classes of package pak:
   279	//			AbstractExpression
       
   280	public class AssignmentExpression extends AbstractExpression {
       
   281		public AssignmentExpression() {
   282		}
       
   283		public String repr_() {
   284			return "AssignmentExpression";
   285		}
   286	}
   287	
       
   288	2019-01-11 06:34    tripleo/elijah/lang/AbstractTypeName.java     Page 1
       
       
   289	// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
   290	// Jad home page: http://www.geocities.com/kpdus/jad.html
   291	// Decompiler options: packimports(3) 
   292	// Source File Name:   AbstractTypeName.java
       
   293	package tripleo.elijah.lang;
       
   294	// Referenced classes of package pak2:
   295	//			TypeName
       
   296	public abstract class AbstractTypeName implements TypeName {
       
   297		public AbstractTypeName() {
   298		}
       
   299		public boolean isNull() {
   300			return !pr_constant && !pr_reference && !pr_out && !pr_in
   301					&& pr_name == "";
   302		}
       
   303		public boolean getConstant() {
   304			return pr_constant;
   305		}
       
   306		public void setConstant(boolean s) {
   307			pr_constant = s;
   308		}
       
   309		public boolean getReference() {
   310			return pr_reference;
   311		}
       
   312		public void setReference(boolean s) {
   313			pr_reference = s;
   314		}
       
   315		public boolean getOut() {
   316			return pr_out;
   317		}
       
   318		public void setOut(boolean s) {
   319			pr_out = s;
   320		}
       
   321		public boolean getIn() {
   322			return pr_in;
   323		}
       
   324		public void setIn(boolean s) {
   325			pr_in = s;
   326		}
       
   327		public String getName() {
   328			return pr_name;
   329		}
       
   330	
       
   331	2019-01-11 06:34    tripleo/elijah/lang/AbstractTypeName.java     Page 2
       
       
   332		public void setName(String s) {
   333			pr_name = s;
   334		}
       
   335		private TypeModifiers tm;
       
   336		public void type(TypeModifiers atm) {
   337	tm=atm;		
   338		}
   339		
   340		public void set(int aType) {
   341			type = aType;
   342		}
       
   343		protected boolean pr_constant;
       
   344		protected boolean pr_reference;
       
   345		protected boolean pr_out;
       
   346		protected boolean pr_in;
       
   347		protected String pr_name;
       
   348		int type;
   349	}
   350	
       
   351	2019-01-11 06:34      tripleo/elijah/lang/AddExpression.java      Page 1
       
       
   352	// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
   353	// Jad home page: http://www.geocities.com/kpdus/jad.html
   354	// Decompiler options: packimports(3) 
   355	// Source File Name:   AddExpression.java
       
   356	package tripleo.elijah.lang;
       
   357	// Referenced classes of package pak:
   358	//			AbstractExpression
       
   359	public class AddExpression extends AbstractExpression {
       
   360		public AddExpression() {
   361		}
       
   362		public String repr_() {
   363			return "AddExpression";
   364		}
   365	}
   366	
       
   367	2019-01-11 06:34 tripleo/elijah/lang/ProcedureCallExpression.java Page 1
       
       
   368	package tripleo.elijah.lang;
       
   369	// Referenced classes of package pak2:
   370	//			ParserClosure, ExpressionList
       
   371	public class ProcedureCallExpression implements StatementItem {
       
   372		public void identifier(String aIdent) {
   373			target=aIdent;
   374		}
       
   375		public ExpressionList exprList() {
   376			return args;
   377		}
   378		
   379		String target;
   380		ExpressionList args=new ExpressionList();
   381	}
   382	
       
   383	2019-01-11 06:34    tripleo/elijah/lang/BinaryExpression.java     Page 1
       
       
   384	package tripleo.elijah.lang;
       
   385	import tripleo.elijah.lang.*;
       
   386	// Referenced classes of package pak2:
   387	//			AbstractExpression, ExpressionType
       
   388	class BinaryExpression extends AbstractExpression {
       
   389		public BinaryExpression(IExpression aLast_exp, ExpressionType aType,
   390				String aSide) {
   391			left = aLast_exp;
   392			type = aType;
   393			StringExpression se=new StringExpression(aSide);
   394			right = se;
   395		}
       
   396	}
       
   397	
       
   398	2019-01-11 06:34       tripleo/elijah/lang/BlockMember.java       Page 1
       
       
   399	// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
   400	// Jad home page: http://www.geocities.com/kpdus/jad.html
   401	// Decompiler options: packimports(3) 
   402	// Source File Name:   VariableSequence.java
       
   403	package tripleo.elijah.lang;
       
   404	interface BlockMember {
   405	}
   406	
       
   407	2019-01-11 06:34     tripleo/elijah/lang/BlockStatement.java      Page 1
       
       
   408	package tripleo.elijah.lang;
       
   409	// Referenced classes of package pak2:
   410	//			Statement, StatementClosure, FormalArgList
       
   411	public class BlockStatement implements Statement, StatementItem {
       
   412		final private Scope parent;
   413		private TypeName tn=new RegularTypeName();
   414		private FormalArgList fal=new FormalArgList();
   415		private StatementClosure scope;
   416		
   417		public BlockStatement(Scope aParent) {
   418			parent = aParent;
   419			scope=new AbstractStatementClosure(parent);
   420		}
       
   421		public StatementClosure scope() {
   422			return scope;
   423		}
       
   424		public FormalArgList opfal() {
   425			return fal;
   426		}
       
   427		public TypeName returnType() {
   428			return tn;
   429		}
   430	}
   431	
       
   432	2019-01-11 06:34    tripleo/elijah/lang/ClassInheritance.java     Page 1
       
       
   433	/*
   434	 * Created on Aug 30, 2005 9:01:37 PM
   435	 * 
   436	 * $Id$
   437	 *
   438	 * TODO To change the template for this generated file go to
   439	 * Window - Preferences - Java - Code Style - Code Templates
   440	 */
   441	package tripleo.elijah.lang;
       
   442	import java.util.*;
       
   443	public class ClassInheritance {
       
   444		private ClassStatement parent;
       
   445		public ClassInheritance(ClassStatement aStatement) {
   446			parent=aStatement;
   447		}
       
   448		List<TypeName> tns=new ArrayList<TypeName>();
   449		
   450		public TypeName next() {
   451			TypeName tn = new RegularTypeName();
   452			tns.add(tn);
   453			return tn;
   454		}
   455	}
       
   456	
       
   457	2019-01-11 06:34        tripleo/elijah/lang/ClassItem.java        Page 1
       
       
   458	/**
   459	 * 
   460	 */
   461	package tripleo.elijah.lang;
   462	
   463	import java.io.IOException;
   464	
   465	
   466	import tripleo.elijah.gen.java.JavaCodeGen;
   467	import tripleo.elijah.util.TabbedOutputStream;
   468	
   469	public interface ClassItem extends OS_Element {
   470	
   471		void print_osi(TabbedOutputStream aTos) throws IOException;
   472	
   473		void visit(JavaCodeGen gen);
   474	
   475	}
   476	
       
   477	2019-01-11 06:34     tripleo/elijah/lang/ClassStatement.java      Page 1
       
       
   478	package tripleo.elijah.lang;
       
   479	import java.io.IOException;
   480	import java.util.*;
       
       
   481	import tripleo.elijah.gen.java.JavaCodeGen;
   482	import tripleo.elijah.util.*;
       
   483	// Referenced classes of package pak2:
   484	//			Scope, ExpressionWrapper, AbstractStatementClosure, StatementClosure, 
   485	//			BlockStatement
       
   486	/**
   487	 * Represents a "class"
   488	 * 
   489	 * items -> ClassItems
   490	 * docstrings 
   491	 * variables
   492	 * 
   493	 */
   494	public class ClassStatement implements Scope, ModuleItem, OS_Element {
       
   495		public ClassStatement(OS_Module aModule) {
   496			parent = aModule;
   497			aModule.add(this);
   498		}
       
   499		public void add(ClassItem aDef) {
   500			items.add (aDef);
   501		}
       
   502		public void add(StatementItem aItem) {
   503			if (aItem instanceof ClassItem) {
   504				ClassItem new_name = (ClassItem) aItem;
   505				items.add (new_name);
   506			} else assert false;
   507		}
       
   508		public void addDocString(String aText) {
   509			mDocs.add(aText);
   510		}
       
   511		public BlockStatement blockStatement() {
   512			return null;
   513		}
       
   514		public ClassInheritance classInheritance() {
   515			return new ClassInheritance(this);
   516		}
       
   517		public IExpression fixme_expr() {
   518			IExpression R = new ExpressionWrapper();
   519			mExprs.add(R);
   520			return R;
   521		}
   522	
       
   523	2019-01-11 06:34     tripleo/elijah/lang/ClassStatement.java      Page 2
       
       
       
   524		public FunctionDef funcDef() {
   525			return new FunctionDef(this);
   526		}
       
   527		public void print_osi(TabbedOutputStream tos) throws IOException {
   528			System.out.println("Klass print_osi");
   529			tos.incr_tabs();
   530			tos.put_string("Class (");
   531			tos.put_string(clsName);
   532			tos.put_string_ln(") {");
   533			tos.put_string_ln("//");
   534			for (ClassItem item : items) {
   535				item.print_osi(tos);
   536			}
   537			tos.dec_tabs();
   538			tos.put_string_ln((new StringBuilder("} // class ")).append(clsName)
   539					.toString());
   540		}
       
   541		public void setName(String aText) {
   542			clsName=aText;
   543		}
       
   544		public StatementClosure statementClosure() {
   545			return new AbstractStatementClosure(this);
   546		}
       
   547		public IExpression statementWrapper() {
   548			IExpression R = new ExpressionWrapper();
   549			mExprs.add(R);
   550			return R;
   551		}
       
   552		public void statementWrapper(IExpression aExpr) {
   553			// TODO Auto-generated method stub
   554			throw new NotImplementedException();
   555			
   556		}
   557		public void visitGen(JavaCodeGen visit) {
   558			visit.addClass(this);
   559		}
       
   560		public String clsName;
       
   561		private final List<ClassItem> items=new ArrayList<ClassItem>();
   562		private final ArrayList<String> mDocs = new ArrayList<String>();
   563		private final ArrayList<IExpression> mExprs = new ArrayList<IExpression>();
       
   564		public final OS_Module parent;
       
   565		public synchronized Collection<ClassItem> items() {
   566			return items;
   567		}
   568	}
   569	
       
   570	2019-01-11 06:34   tripleo/elijah/lang/ConstantExpression.java    Page 1
       
       
   571	/*
   572	 * Created on Sep 1, 2005 6:44:49 PM
   573	 * 
   574	 * $Id$
   575	 *
   576	 * TODO To change the template for this generated file go to
   577	 * Window - Preferences - Java - Code Style - Code Templates
   578	 */
   579	package tripleo.elijah.lang;
       
       
   580	public class ConstantExpression extends AbstractExpression {
       
   581		public ConstantExpression(Scope aScope) {
   582		}
   583	}
   584	
       
   585	2019-01-11 06:34   tripleo/elijah/lang/ConstructExpression.java   Page 1
       
       
   586	/*
   587	 * Created on Sep 1, 2005 6:47:16 PM
   588	 * 
   589	 * $Id$
   590	 *
   591	 * TODO To change the template for this generated file go to
   592	 * Window - Preferences - Java - Code Style - Code Templates
   593	 */
   594	package tripleo.elijah.lang;
       
       
   595	public class ConstructExpression extends AbstractExpression implements StatementItem {
       
   596		public ConstructExpression(Scope aScope) {
   597		}
   598	}
   599	
       
   600	2019-01-11 06:34         tripleo/elijah/lang/Context.java         Page 1
       
       
   601	// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
   602	// Jad home page: http://www.geocities.com/kpdus/jad.html
   603	// Decompiler options: packimports(3) 
   604	// Source File Name:   Context.java
       
   605	package tripleo.elijah.lang;
       
   606	public class Context {
       
   607		public Context() {
   608		}
   609	}
   610	
       
   611	2019-01-11 06:34    tripleo/elijah/lang/ExprListListener.java     Page 1
       
       
   612	// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
   613	// Jad home page: http://www.geocities.com/kpdus/jad.html
   614	// Decompiler options: packimports(3) 
   615	// Source File Name:   ExprListListener.java
       
   616	package tripleo.elijah.lang;
       
   617	// Referenced classes of package pak:
   618	//			IExpression
       
   619	public interface ExprListListener {
       
   620		public abstract void change(IExpression iexpression);
       
   621		public abstract String repr_();
       
   622		public abstract boolean isEmpty();
   623	}
   624	
       
   625	2019-01-11 06:34    tripleo/elijah/lang/ExpressionBuilder.java    Page 1
       
       
   626	/*
   627	 * Created on Sep 2, 2005 2:28:42 PM
   628	 * 
   629	 * $Id$
   630	 *
   631	 * TODO To change the template for this generated file go to
   632	 * Window - Preferences - Java - Code Style - Code Templates
   633	 */
   634	package tripleo.elijah.lang;
       
   635	import tripleo.elijah.lang.*;
       
   636	public class ExpressionBuilder {
       
   637		public static IBinaryExpression buildPartial(IExpression aE, ExpressionType aAssignment) {
   638			// TODO Auto-generated method stub
   639			return new AbstractExpression(aE, aAssignment, null);
   640		}
       
   641		public static IBinaryExpression build(IExpression aE, ExpressionType aIs_a, IExpression aExpression) {
   642			return new AbstractExpression(aE, aIs_a, aExpression);
   643		}
       
   644		public static IExpression build(IExpression aE, ExpressionType aPost_decrement) {
   645			// TODO Auto-generated method stub
   646			return null;
   647		}
       
   648	}
       
   649	
       
   650	2019-01-11 06:34     tripleo/elijah/lang/ExpressionList.java      Page 1
       
       
   651	package tripleo.elijah.lang;
       
   652	import java.util.*;
       
       
   653	// Referenced classes of package pak2:
   654	//			AbstractExpression
       
   655	public class ExpressionList {
       
   656		public IExpression next(IExpression aExpr) {
   657			exprs.add(aExpr);
   658			return aExpr;
   659		}
       
   660		private final List<IExpression> exprs = new ArrayList<IExpression>();
   661	}
   662	
       
   663	2019-01-11 06:34     tripleo/elijah/lang/ExpressionType.java      Page 1
       
       
   664	package tripleo.elijah.lang;
       
   665	public enum ExpressionType {
       
   666		ADDITION, 
   667		ASSIGNMENT,
   668		AUG_PLUS,
   669		AUG_MINUS,
   670		AUG_MULT,
   671		AUG_DIV,
   672		AUG_MOD,
   673		AUG_SR,
   674		AUG_BSR,
   675		AUG_SL,
   676		AUG_BAND,
   677		AUG_BXOR,
   678		AUG_BOR,
   679		IS_A, xy,
   680		QIDENT,
   681		INCREMENT,
   682		DECREMENT,
   683		NEGATION,
   684		POSITIVITY,
   685		POST_INCREMENT,
   686		POST_DECREMENT, SUBTRACTION, BNOT, LNOT, 
   687		SIMPLE // TODO
   688	}
   689	
       
   690	2019-01-11 06:34    tripleo/elijah/lang/ExpressionWrapper.java    Page 1
       
       
   691	// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
   692	// Jad home page: http://www.geocities.com/kpdus/jad.html
   693	// Decompiler options: packimports(3) 
   694	// Source File Name:   ExpressionWrapper.java
       
   695	package tripleo.elijah.lang;
       
   696	import tripleo.elijah.lang.*;
       
   697	public class ExpressionWrapper extends AbstractExpression implements
   698			IBinaryExpression {
       
   699		public ExpressionWrapper() {
   700		}
   701	}
   702	
       
   703	2019-01-11 06:34      tripleo/elijah/lang/FormalArgList.java      Page 1
       
       
   704	package tripleo.elijah.lang;
       
   705	import java.util.*;
       
   706	// Referenced classes of package pak2:
   707	//			FormalArgListItem
       
   708	public class FormalArgList {
       
   709		private List<FormalArgListItem> falis=new ArrayList<FormalArgListItem>();
       
   710		public FormalArgListItem next() {
   711			FormalArgListItem fali = new FormalArgListItem();
   712			falis.add(fali);
   713			return fali;
   714		}
       
   715	}
   716	
       
   717	2019-01-11 06:34    tripleo/elijah/lang/FormalArgListItem.java    Page 1
       
       
   718	// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
   719	// Jad home page: http://www.geocities.com/kpdus/jad.html
   720	// Decompiler options: packimports(3) 
   721	// Source File Name:   FormalArgListItem.java
       
   722	package tripleo.elijah.lang;
       
   723	// Referenced classes of package pak2:
   724	//			TypeName
       
   725	public class FormalArgListItem {
   726		
   727		String name;
   728		TypeName tn=new RegularTypeName();
       
   729		public TypeName typeName() {
   730			return tn;
   731		}
       
   732		public void setName(String s) {
   733			name=s;
   734		}
   735	}
   736	
       
   737	2019-01-11 06:34       tripleo/elijah/lang/FunctionDef.java       Page 1
       
       
   738	/*
   739	 * Created on Aug 30, 2005 8:43:27 PM
   740	 * 
   741	 * $Id$
   742	 */
   743	package tripleo.elijah.lang;
       
   744	import java.io.IOException;
   745	import java.util.*;
       
       
   746	import tripleo.elijah.gen.java.JavaCodeGen;
   747	import tripleo.elijah.util.*;
       
   748	public class FunctionDef implements ClassItem {
   749		static class StatementWrapper implements StatementItem, FunctionItem {
       
   750			private IExpression expr;
       
   751			public StatementWrapper(IExpression aexpr) {
   752				expr = aexpr;
   753			}
       
   754			public void print_osi(TabbedOutputStream aTos) throws IOException {
   755				// TODO Auto-generated method stub
   756				
   757			}
   758		}
   759		
   760		private final class FunctionDefScope implements Scope {
       
   761			public void add(StatementItem aItem) {
   762				if (aItem instanceof FunctionItem)
   763					items.add((FunctionItem) aItem);
   764				else
   765					System.err.println("adding false StatementItem "
   766							+ aItem.getClass().getName());
   767			}
       
   768			public void addDocString(String aS) {
   769				docstrings.add(aS);
   770			}
       
   771			public BlockStatement blockStatement() {
   772				return new BlockStatement(this);
   773			}
       
   774			public StatementClosure statementClosure() {
   775				return new AbstractStatementClosure(this);
   776			}
       
   777			public void statementWrapper(IExpression aExpr) {
   778				add(new StatementWrapper(aExpr));
   779	//			throw new NotImplementedException(); // TODO
   780			}
   781		}
   782	
       
   783	2019-01-11 06:34       tripleo/elijah/lang/FunctionDef.java       Page 2
       
       
       
   784		public List<String> docstrings = new ArrayList<String>();
   785		public String funName;
   786		List<FunctionItem> items = new ArrayList<FunctionItem>();
   787		private final FormalArgList mFal = new FormalArgList();
   788		private FunctionDefScope mScope;
   789		private ClassStatement parent;
       
   790		public FunctionDef(ClassStatement aStatement) {
   791			parent = aStatement;
   792			parent.add(this);
   793		}
       
   794		public FormalArgList fal() {
   795			return mFal;
   796		}
       
   797		public void print_osi(TabbedOutputStream tos) throws IOException {
   798			System.out.println("Klass print_osi");
   799			tos.incr_tabs();
   800			tos.put_string("Class (");
   801			tos.put_string(funName);
   802			tos.put_string_ln(") {");
   803			tos.put_string_ln("//");
   804			for (FunctionItem item : items) {
   805				item.print_osi(tos);
   806			}
   807			tos.dec_tabs();
   808			tos.put_string_ln((("} // class ")) + (funName));
   809		}
       
   810		public Scope scope() {
   811			assert mScope == null;
   812			mScope = new FunctionDefScope();
   813			return mScope;
   814		}
       
   815		public void setName(String aText) {
   816			funName = aText;
   817		}
       
   818		public void visit(JavaCodeGen gen) {
   819			// TODO Auto-generated method stub
   820			for (FunctionItem element : items)
   821				gen.addFunctionItem(element);
   822		}
   823	}
   824	
       
   825	2019-01-11 06:34      tripleo/elijah/lang/FunctionItem.java       Page 1
       
       
   826	/**
   827	 * 
   828	 */
   829	package tripleo.elijah.lang;
   830	
   831	import java.io.IOException;
   832	
   833	import tripleo.elijah.util.TabbedOutputStream;
   834	
   835	public interface FunctionItem extends OS_Element {
   836	
   837		void print_osi(TabbedOutputStream aTos) throws IOException;
   838	
   839	}
   840	
       
   841	2019-01-11 06:34    tripleo/elijah/lang/FunctionParameter.java    Page 1
       
       
   842	// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
   843	// Jad home page: http://www.geocities.com/kpdus/jad.html
   844	// Decompiler options: packimports(3) 
   845	// Source File Name:   FunctionParameter.java
       
   846	package tripleo.elijah.lang;
       
       
   847	public class FunctionParameter extends AbstractTypeName implements TypeName {
       
   848		public FunctionParameter() {
   849			pr_constant = false;
   850			pr_reference = false;
   851			pr_out = false;
   852			pr_in = false;
   853			pr_name = "";
   854		}
       
   855		public TypeName typeof() {
   856			return null;
   857		}
       
   858		public TypeName returnValue() {
   859			return null;
   860		}
       
   861		public void type(int i) {
   862		}
       
   863		public TypeNameList argList() {
   864			return null;
   865		}
       
   866		public TypeName typeof(String aXy) {
   867			return null;
   868		}
       
   869		public TypeName typeName(String aTypeName) {
   870			return null;
   871		}
       
   872		public void set(TypeModifiers aModifiers) {
   873			// TODO Auto-generated method stub
   874			
   875		}
   876	}
   877	
       
   878	2019-01-11 06:34    tripleo/elijah/lang/FunctionTypeName.java     Page 1
       
       
   879	// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
   880	// Jad home page: http://www.geocities.com/kpdus/jad.html
   881	// Decompiler options: packimports(3) 
   882	// Source File Name:   FunctionTypeName.java
       
   883	package tripleo.elijah.lang;
       
   884	// Referenced classes of package pak2:
   885	//			AbstractTypeName, TypeNameList, TypeName
       
   886	public class FunctionTypeName extends AbstractTypeName {
       
   887		public FunctionTypeName() {
   888		}
       
   889		public TypeNameList argList() {
   890			return null;
   891		}
       
   892		public TypeName returnValue() {
   893			return null;
   894		}
       
   895		public TypeName typeName() {
   896			return null;
   897		}
       
   898		public TypeName typeof(String aXy) {
   899			return null;
   900		}
       
   901		public void type(int i) {
   902		}
       
   903		public TypeName typeName(String aTypeName) {
   904			return null;
   905		}
       
   906		public void set(TypeModifiers aModifiers) {
   907			// TODO Auto-generated method stub
   908			
   909		}
   910	}
   911	
       
   912	2019-01-11 06:34    tripleo/elijah/lang/IBinaryExpression.java    Page 1
       
       
   913	package tripleo.elijah.lang;
       
       
       
   914	public interface IBinaryExpression extends IExpression {
       
   915		public abstract IExpression getRight();
       
   916		public abstract void setRight(IExpression iexpression);
       
   917		public abstract void shift(ExpressionType aType);
       
   918		void set(IBinaryExpression aEx);
       
   919	}
   920	
       
   921	2019-01-11 06:34       tripleo/elijah/lang/IExpression.java       Page 1
       
       
   922	/*
   923	 * Created on Sep 2, 2005 2:08:03 PM
   924	 * 
   925	 * $Id$
   926	 *
   927	 * TODO To change the template for this generated file go to
   928	 * Window - Preferences - Java - Code Style - Code Templates
   929	 */
   930	package tripleo.elijah.lang;
       
   931	import java.io.IOException;
       
   932	import tripleo.elijah.util.TabbedOutputStream;
       
   933	public interface IExpression {
       
   934		void print_osi(TabbedOutputStream tabbedoutputstream) throws IOException;
       
   935		IExpression getLeft();
       
   936		void setLeft(IExpression iexpression);
       
   937		String repr_();
       
   938		IExpression UNASSIGNED = new AbstractExpression() {
   939		};
       
   940		ExpressionType getType();
       
   941		void set(ExpressionType aIncrement);
       
   942	}
   943	
       
   944	2019-01-11 06:34        tripleo/elijah/lang/IdentList.java        Page 1
       
       
   945	// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
   946	// Jad home page: http://www.geocities.com/kpdus/jad.html
   947	// Decompiler options: packimports(3) 
   948	// Source File Name:   IdentList.java
       
   949	package tripleo.elijah.lang;
       
   950	import java.util.*;
       
   951	public class IdentList {
       
   952		List<String> idents=new ArrayList<String>();
   953		
   954		public void push(String aa){
   955			idents.add(aa);
   956		}
   957	}
       
   958	
       
   959	2019-01-11 06:34      tripleo/elijah/lang/IfExpression.java       Page 1
       
       
   960	// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
   961	// Jad home page: http://www.geocities.com/kpdus/jad.html
   962	// Decompiler options: packimports(3) 
   963	// Source File Name:   IfExpression.java
       
   964	package tripleo.elijah.lang;
       
       
   965	// Referenced classes of package pak2:
   966	//			Scope
       
   967	public class IfExpression implements StatementItem {
       
   968		public IfExpression(Scope aClosure) {
   969		}
       
   970		public Scope scope() {
   971			return null;
   972		}
       
   973		public IExpression expr() {
   974			return null;
   975		}
       
   976		public IfExpression else_() {
   977			return null;
   978		}
       
   979		public IfExpression elseif() {
   980			return null;
   981		}
   982	}
   983	
       
   984	2019-01-11 06:34     tripleo/elijah/lang/ImportStatement.java     Page 1
       
       
   985	package tripleo.elijah.lang;
       
   986	import java.io.IOException;
       
       
   987	import tripleo.elijah.gen.java.JavaCodeGen;
   988	import tripleo.elijah.util.*;
       
   989	// Referenced classes of package pak2:
   990	//			IdentList
       
   991	public class ImportStatement implements ModuleItem {
       
   992		final OS_Module parent;
       
   993		public ImportStatement(OS_Module aParent) {
   994			parent = aParent;
   995			parent.add(this);
   996		}
       
   997		public void importRoot(String aRoot) {
   998			root = aRoot;
   999		}
       
  1000		public IdentList importList() {
  1001			assert importList==null; // TODO??
  1002			importList=new IdentList();
  1003			return importList;
  1004		}
       
  1005		private String root;
       
  1006		private IdentList importList;
       
  1007		public void print_osi(TabbedOutputStream aTos) throws IOException {
  1008			// TODO Auto-generated method stub
  1009			throw new NotImplementedException();
  1010		}
       
  1011		public void visitGen(JavaCodeGen visit) {
  1012			// TODO Auto-generated method stub
  1013			throw new NotImplementedException();
  1014			
  1015		}
  1016	}
       
       
  1017	
       
  1018	2019-01-11 06:34         tripleo/elijah/lang/IntRef.java          Page 1
       
       
  1019	// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
  1020	// Jad home page: http://www.geocities.com/kpdus/jad.html
  1021	// Decompiler options: packimports(3) 
  1022	// Source File Name:   IntRef.java
       
  1023	package tripleo.elijah.lang;
       
  1024	// Referenced classes of package pak:
  1025	//			AbstractExpression
       
  1026	public class IntRef extends AbstractExpression {
       
  1027		public IntRef(int n) {
  1028			value = n;
  1029		}
       
  1030		public String repr_() {
  1031			return (new StringBuilder("IntRef (")).append(
  1032					(new Integer(value)).toString()).append(")").toString();
  1033		}
       
  1034		public int value;
  1035	}
  1036	
       
  1037	2019-01-11 06:34          tripleo/elijah/lang/Klass.java          Page 1
       
       
  1038	package tripleo.elijah.lang;
  1039	//
  1040	//package pak;
  1041	//
  1042	//import java.io.IOException;
  1043	//import java.io.PrintStream;
  1044	//import java.util.Iterator;
  1045	//import java.util.Vector;
  1046	//import org.oluworld.util.TabbedOutputStream;
  1047	//
  1048	//// Referenced classes of package pak:
  1049	////			_Scope, ScopeElement, ExprListListener
  1050	//
  1051	//public class Klass implements _Scope {
  1052	//
  1053	//	public Klass(String s) {
  1054	//		className = s;
  1055	//		elts = new Vector();
  1056	//	}
  1057	//
  1058	//	public String getName() {
  1059	//		return className;
  1060	//	}
  1061	//
  1062	//	public String repr_() {
  1063	//		return (new StringBuilder("Klass (")).append(getName()).append(")")
  1064	//				.toString();
  1065	//	}
  1066	//
  1067	//	public ExprListListener getListener() {
  1068	//		return new _Scope.ScopeExprListener() {
  1069	//
  1070	//			String getScopeListenerName() {
  1071	//				return "ClassScopeListener";
  1072	//			}
  1073	//
  1074	//		};
  1075	//	}
  1076	//
  1077	//	public void print_osi(TabbedOutputStream tos) throws IOException {
  1078	//		System.out.println("Klass print_osi");
  1079	//		tos.incr_tabs();
  1080	//		tos.put_string("Class (");
  1081	//		tos.put_string(className);
  1082	//		tos.put_string_ln(") {");
  1083	//		tos.put_string_ln("//");
  1084	//		synchronized (elts) {
  1085	//			for (Iterator e = elts.iterator(); e.hasNext(); ((ScopeElement) (ScopeElement) e
  1086	//					.next()).print_osi(tos))
  1087	//				;
  1088	//		}
  1089	//		tos.dec_tabs();
  1090	//		tos.put_string_ln((new StringBuilder("} // class ")).append(className)
  1091	//				.toString());
  1092	//	}
  1093	//
  1094	
       
  1095	2019-01-11 06:34          tripleo/elijah/lang/Klass.java          Page 2
       
       
  1096	//	public void push(ScopeElement se) {
  1097	//		elts.add(se);
  1098	//	}
  1099	//
  1100	//	String className;
  1101	//
  1102	//	Vector elts;
  1103	//}
  1104	
       
  1105	2019-01-11 06:34     tripleo/elijah/lang/ListExpression.java      Page 1
       
       
  1106	/*
  1107	 * Created on Sep 1, 2005 8:28:55 PM
  1108	 * 
  1109	 * $Id$
  1110	 *
  1111	 * TODO To change the template for this generated file go to
  1112	 * Window - Preferences - Java - Code Style - Code Templates
  1113	 */
  1114	package tripleo.elijah.lang;
       
       
  1115	public class ListExpression extends AbstractExpression {
       
  1116		public ExpressionList contents() {
  1117			return contents;
  1118		}
       
  1119		ExpressionList contents=new ExpressionList();
  1120	}
  1121	
       
  1122	2019-01-11 06:34          tripleo/elijah/lang/Loop.java           Page 1
       
       
  1123	package tripleo.elijah.lang;
       
       
  1124	// Referenced classes of package pak2:
  1125	//			Statement, LoopTypes, Scope
       
  1126	public class Loop implements Statement, LoopTypes, StatementItem {
       
  1127		public Loop() {
  1128		}
       
  1129		public void type(int aType) {
  1130			type = aType;
  1131		}
       
  1132		public Scope scope() {
  1133			return null;
  1134		}
       
  1135		public void expr(IExpression aExpr) {
  1136			expr=aExpr;
  1137		}
       
  1138		public void topart(IExpression aExpr) {
  1139			topart=aExpr;
  1140		}
       
  1141		public void frompart(IExpression aExpr) {
  1142			frompart=aExpr;
  1143		}
       
  1144		public void iterName(String s) {
  1145	//		assert type == ITER_TYPE;
  1146			iterName=s;
  1147		}
       
  1148		String iterName;
  1149		int type;
  1150	IExpression topart,expr; 
  1151	IExpression frompart;
       
  1152		public final int FROM_TO_TYPE = 82;
       
  1153		public final int TO_TYPE = 81;
  1154		public final int ITER_TYPE = 86;
       
  1155		public final int EXPR_TYPE = 83;
  1156	}
  1157	
       
  1158	2019-01-11 06:34        tripleo/elijah/lang/LoopTypes.java        Page 1
       
       
  1159	// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
  1160	// Jad home page: http://www.geocities.com/kpdus/jad.html
  1161	// Decompiler options: packimports(3) 
  1162	// Source File Name:   LoopTypes.java
       
  1163	package tripleo.elijah.lang;
       
  1164	public interface LoopTypes {
       
  1165		public static final int WHILE = 2;
       
  1166		public static final int DO_WHILE = 1;
  1167	}
  1168	
       
  1169	2019-01-11 06:34         tripleo/elijah/lang/Method.java          Page 1
       
       
  1170	// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
  1171	// Jad home page: http://www.geocities.com/kpdus/jad.html
  1172	// Decompiler options: packimports(3) 
  1173	// Source File Name:   Method.java
       
  1174	package tripleo.elijah.lang;
       
  1175	import java.io.IOException;
  1176	import java.util.*;
       
  1177	import tripleo.elijah.util.TabbedOutputStream;
       
  1178	// Referenced classes of package pak:
  1179	//			_Scope, ScopeElement, TypeRef, ExprListListener
       
  1180	public class Method implements _Scope {
       
  1181		public Method(String name, int type) {
  1182			methodName = name;
  1183			methodType = type;
  1184			elts = new Vector<ScopeElement>();
  1185		}
       
  1186		public void print_osi(TabbedOutputStream tos) throws IOException {
  1187			System.out.println("Method print_osi");
  1188			String r;
  1189			if (methodType == 2 || methodType == 0)
  1190				r = "Function (";
  1191			else
  1192				r = "Procedure (";
  1193			tos.put_string(r);
  1194			tos.put_string(methodName);
  1195			tos.put_string_ln(") {");
  1196			synchronized (elts) {
  1197				for (Iterator<ScopeElement> e = elts.iterator(); e.hasNext(); e
  1198						.next().print_osi(tos))
  1199					;
  1200			}
  1201			tos.dec_tabs();
  1202			tos.put_string_ln("} // Method");
  1203		}
       
  1204		public String typeString() {
  1205			switch (methodType) {
  1206			case 0: // '\0'
  1207				return "UNSPECIFIED";
       
  1208			case 1: // '\001'
  1209				return "PROCEDURE";
       
  1210			case 2: // '\002'
  1211				return "FUNCTION";
       
  1212			case 3: // '\003'
  1213				return "HARDMETHOD";
       
  1214	
       
  1215	2019-01-11 06:34         tripleo/elijah/lang/Method.java          Page 2
       
       
  1216			case 4: // '\004'
  1217				return "HARDFUNCTION";
  1218			}
  1219			throw new IllegalStateException("bad type on Method");
  1220		}
       
  1221		public String repr_() {
  1222			return (new StringBuilder("Method (")).append(methodName).append(" {")
  1223					.append(typeString()).append("})").toString();
  1224		}
       
  1225		public void push(ScopeElement se) {
  1226			if (se == null)
  1227				System.out.println("se is null");
  1228			try {
  1229				se.print_osi(new TabbedOutputStream(System.out));
  1230				elts.add(se);
  1231			} catch (IOException ioexception) {
  1232			}
  1233		}
       
  1234		public ExprListListener getListener() {
  1235			return new _Scope.ScopeExprListener() {
       
  1236				String getScopeListenerName() {
  1237					return "MethodScopeListener";
  1238				}
  1239			};
  1240		}
       
  1241		public static final int UNSPECIFIED = 0;
       
  1242		public static final int PROCEDURE = 1;
       
  1243		public static final int FUNCTION = 2;
       
  1244		public static final int COMMAND = 3;
       
  1245		public static final int HARDMETHOD = 3;
       
  1246		public static final int HARDFUNCTION = 4;
       
  1247		String methodName;
       
  1248		int methodType;
       
  1249		TypeRef returnType;
       
  1250		Vector args;
       
  1251		Vector<ScopeElement> elts;
  1252	}
  1253	
       
  1254	2019-01-11 06:34         tripleo/elijah/lang/Module.java          Page 1
       
       
  1255	package tripleo.elijah.lang;
  1256	//// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
  1257	//// Jad home page: http://www.geocities.com/kpdus/jad.html
  1258	//// Decompiler options: packimports(3) 
  1259	//// Source File Name:   Module.java
  1260	//
  1261	//package pak;
  1262	//
  1263	//import antlr.collections.Stack;
  1264	//import antlr.collections.impl.LList;
  1265	//import java.io.IOException;
  1266	//import java.io.PrintStream;
  1267	//import java.util.*;
  1268	//import org.oluworld.util.TabbedOutputStream;
  1269	//
  1270	//// Referenced classes of package pak:
  1271	////			_Scope, Klass, ScopeElement, ExprListListener
  1272	//
  1273	//public class Module implements _Scope {
  1274	//
  1275	//	public Module() {
  1276	//		classStack = new LList();
  1277	//		elts = new Vector();
  1278	//	}
  1279	//
  1280	//	public String getPackageName() {
  1281	//		return packageName;
  1282	//	}
  1283	//
  1284	//	public void setPackageName(String s) {
  1285	//		packageName = s;
  1286	//	}
  1287	//
  1288	//	public Klass pushClass(String s) {
  1289	//		Klass k = new Klass(s);
  1290	//		classStack.push(k);
  1291	//		addElement(k);
  1292	//		return k;
  1293	//	}
  1294	//
  1295	//	public void addElement(ScopeElement e) {
  1296	//		elts.add(e);
  1297	//	}
  1298	//
  1299	//	public ExprListListener getListener() {
  1300	//		return new _Scope.ScopeExprListener() {
  1301	//
  1302	//			String getScopeListenerName() {
  1303	//				return "ModuleScopeListener";
  1304	//			}
  1305	//
  1306	//		};
  1307	//	}
  1308	//
  1309	//	public String repr_() {
  1310	//		return String.format("Module (%s)",packageName);
  1311	
       
  1312	2019-01-11 06:34         tripleo/elijah/lang/Module.java          Page 2
       
       
  1313	//	}
  1314	//
  1315	//	public void finish(TabbedOutputStream tos) throws IOException {
  1316	//		tos.close();
  1317	//	}
  1318	//
  1319	//	public void print_osi(TabbedOutputStream tos) throws IOException {
  1320	//		System.out.println("Module print_osi");
  1321	//		if (packageName != null) {
  1322	//			tos.put_string("package ");
  1323	//			tos.put_string_ln(packageName);
  1324	//			tos.put_string_ln("");
  1325	//		}
  1326	//		tos.put_string_ln("//");
  1327	//		synchronized (elts) {
  1328	//			for (ScopeElement element : elts)
  1329	//				element.print_osi(tos);
  1330	//
  1331	//		}
  1332	//	}
  1333	//
  1334	//	public void push(ScopeElement se) {
  1335	//		addElement(se);
  1336	//	}
  1337	//
  1338	//	public void end() {
  1339	//	}
  1340	//
  1341	//	private String packageName;
  1342	//	Stack classStack;
  1343	//	List<ScopeElement> elts;
  1344	//}
  1345	
       
  1346	2019-01-11 06:34       tripleo/elijah/lang/ModuleItem.java        Page 1
       
       
  1347	/**
  1348	 * 
  1349	 */
  1350	package tripleo.elijah.lang;
  1351	
  1352	import java.io.IOException;
  1353	
  1354	
  1355	import tripleo.elijah.gen.java.JavaCodeGen;
  1356	import tripleo.elijah.util.TabbedOutputStream;
  1357	
  1358	public interface ModuleItem {
  1359	
  1360		void print_osi(TabbedOutputStream aTos) throws IOException;
  1361	
  1362		void visitGen(JavaCodeGen visit);
  1363	}
  1364	
       
  1365	2019-01-11 06:34   tripleo/elijah/lang/MultiplyExpression.java    Page 1
       
       
  1366	// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
  1367	// Jad home page: http://www.geocities.com/kpdus/jad.html
  1368	// Decompiler options: packimports(3) 
  1369	// Source File Name:   MultiplyExpression.java
       
  1370	package tripleo.elijah.lang;
       
  1371	// Referenced classes of package pak:
  1372	//			AbstractExpression
       
  1373	public class MultiplyExpression extends AbstractExpression {
       
  1374		public MultiplyExpression() {
  1375		}
       
  1376		public String repr_() {
  1377			return "MultiplyExpression";
  1378		}
  1379	}
  1380	
       
  1381	2019-01-11 06:34    tripleo/elijah/lang/NumericExpression.java    Page 1
       
       
  1382	package tripleo.elijah.lang;
       
  1383	import java.io.IOException;
       
  1384	import tripleo.elijah.util.*;
       
       
       
  1385	/*
  1386	 * Created on Sep 1, 2005 8:16:32 PM
  1387	 * 
  1388	 * $Id$
  1389	 *
  1390	 */
       
  1391	public class NumericExpression implements IExpression {
       
  1392		int carrier;
       
  1393		public NumericExpression(int aCarrier) {
  1394			carrier = aCarrier;
  1395		}
       
  1396		public IExpression getLeft() {
  1397			return this;
  1398		}
       
  1399		public void setLeft(IExpression aLeft) {
  1400			throw new NotImplementedException(); // TODO
  1401		}
       
  1402		public void print_osi(TabbedOutputStream aTabbedoutputstream) throws IOException {
  1403			throw new NotImplementedException(); // TODO
  1404		}
       
  1405		public String repr_() {
  1406			throw new NotImplementedException(); // TODO
  1407	//		return null;
  1408		}
       
  1409		public ExpressionType getType() {
  1410			return ExpressionType.SIMPLE; // TODO
  1411		}
       
  1412		public void set(ExpressionType aIncrement) {
  1413			throw new NotImplementedException(); // TODO
  1414		}
       
  1415	}
  1416	
       
  1417	2019-01-11 06:34       tripleo/elijah/lang/OS_Element.java        Page 1
       
       
  1418	package tripleo.elijah.lang;
  1419	
  1420	public interface OS_Element {
  1421	
  1422	}
  1423	
       
  1424	2019-01-11 06:34        tripleo/elijah/lang/OS_Module.java        Page 1
       
       
  1425	/*
  1426	 * Created on Aug 30, 2005 8:21:52 PM
  1427	 * 
  1428	 * $Id$
  1429	 *
  1430	 */
  1431	package tripleo.elijah.lang;
       
  1432	import java.io.IOException;
  1433	import java.util.*;
       
       
  1434	import tripleo.elijah.gen.java.JavaCodeGen;
  1435	import tripleo.elijah.util.TabbedOutputStream;
       
  1436	public class OS_Module implements OS_Element {
       
  1437		public void add(ModuleItem aStatement) {
  1438			items.add(aStatement);
  1439		}
  1440		
  1441		public void finish(TabbedOutputStream tos) throws IOException {
  1442			tos.close();
  1443		}
       
  1444		public void print_osi(TabbedOutputStream tos) throws IOException {
  1445			System.out.println("Module print_osi");
  1446			if (packageName != null) {
  1447				tos.put_string("package ");
  1448				tos.put_string_ln(packageName);
  1449				tos.put_string_ln("");
  1450			}
  1451			tos.put_string_ln("//");
  1452			synchronized (items) {
  1453				for (ModuleItem element : items)
  1454					element.print_osi(tos);
       
  1455			}
  1456		}
       
  1457		public List<ModuleItem> items=new ArrayList<ModuleItem>();
       
  1458		public String packageName;
       
  1459		public String moduleName="default";
       
  1460		public void visitGen(JavaCodeGen visit) {
  1461			visit.addModule(this);
  1462		}
  1463	}
  1464	
       
  1465	2019-01-11 06:34      tripleo/elijah/lang/ParserClosure.java      Page 1
       
       
  1466	package tripleo.elijah.lang;
       
       
  1467	// Referenced classes of package pak2:
  1468	//			BinaryExpression, StatementClosure, ClassStatement, ImportStatement, 
  1469	//			ExpressionType
       
  1470	public class ParserClosure {
       
  1471		public ParserClosure() {
  1472			module = new OS_Module();
  1473		}
       
  1474		public ClassStatement classStatement() {
  1475			return new ClassStatement(module());
  1476		}
       
  1477		public ImportStatement importStatement() {
  1478			return new ImportStatement(module());
  1479		}
       
  1480		private OS_Module module() {
  1481			return module;
  1482		}
       
  1483		public void packageName(String aXy) {
  1484			assert module.packageName ==null;
  1485			module.packageName = aXy;
  1486		}
       
  1487		public final OS_Module module;
       
  1488	}
       
  1489	
       
  1490	2019-01-11 06:34      tripleo/elijah/lang/ProcedureCall.java      Page 1
       
       
  1491	// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
  1492	// Jad home page: http://www.geocities.com/kpdus/jad.html
  1493	// Decompiler options: packimports(3) 
  1494	// Source File Name:   ProcedureCall.java
       
  1495	package tripleo.elijah.lang;
       
  1496	import tripleo.elijah.util.TabbedOutputStream;
       
  1497	import antlr.collections.impl.LList;
       
  1498	// Referenced classes of package pak:
  1499	//			AbstractExpression, ExprListListener, ScopeElement, VariableReference, 
  1500	//			IExpression
       
  1501	public class ProcedureCall extends AbstractExpression implements
  1502			ExprListListener, ScopeElement {
       
  1503		public ProcedureCall(VariableReference ref) {
  1504			name = ref;
  1505		}
       
  1506		public void setArgs(LList s) {
  1507			args = s;
  1508		}
       
  1509		public boolean isEmpty() {
  1510			return _args == null;
  1511		}
       
  1512		public void change(IExpression e) {
  1513			if (!isEmpty()) {
  1514				throw new IllegalStateException("_args!=null");
  1515			} else {
  1516				_args = e;
  1517				return;
  1518			}
  1519		}
       
  1520		public void print_osi(TabbedOutputStream tos) {
  1521			try {
  1522				tos.incr_tabs();
  1523				tos.put_string_ln("ProcedureCall {");
  1524				tos.put_string("name = ");
  1525				name.print_osi(tos);
  1526				tos.put_string("name = ");
  1527				tos.dec_tabs();
  1528				tos.put_string_ln("}");
  1529			} catch (Exception e) {
  1530				e.printStackTrace();
  1531			}
  1532		}
       
  1533		private VariableReference name;
       
  1534		private LList args;
  1535	
       
  1536	2019-01-11 06:34      tripleo/elijah/lang/ProcedureCall.java      Page 2
       
       
       
  1537		private IExpression _args;
  1538	}
  1539	
       
  1540	2019-01-11 06:34    tripleo/elijah/lang/StatementClosure.java     Page 1
       
       
  1541	// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
  1542	// Jad home page: http://www.geocities.com/kpdus/jad.html
  1543	// Decompiler options: packimports(3) 
  1544	// Source File Name:   StatementClosure.java
       
  1545	package tripleo.elijah.lang;
       
       
  1546	// Referenced classes of package pak2:
  1547	//			VariableSequence, ProcedureCallExpression, Loop, YieldExpression, 
  1548	//			IfExpression
       
  1549	public interface StatementClosure {
       
  1550		public abstract VariableSequence varSeq();
       
  1551		public abstract ProcedureCallExpression procedureCallExpression();
       
  1552		public abstract Loop loop();
       
  1553		public abstract StatementClosure procCallExpr();
       
  1554		public abstract void constructExpression(IExpression aExpr);
       
  1555		public abstract void yield(IExpression aExpr);
       
  1556		public abstract IfExpression ifExpression();
       
  1557		public abstract BlockStatement blockClosure();
  1558	}
  1559	
       
  1560	2019-01-11 06:34      tripleo/elijah/lang/QualidentList.java      Page 1
       
       
  1561	// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
  1562	// Jad home page: http://www.geocities.com/kpdus/jad.html
  1563	// Decompiler options: packimports(3) 
  1564	// Source File Name:   QualidentList.java
       
  1565	package tripleo.elijah.lang;
       
  1566	public class QualidentList {
       
  1567		public QualidentList() {
  1568		}
       
  1569		public void add(String s) {
  1570		}
  1571	}
  1572	
       
  1573	2019-01-11 06:34     tripleo/elijah/lang/RegularTypeName.java     Page 1
       
       
  1574	/*
  1575	 * Created on Aug 30, 2005 9:05:24 PM
  1576	 * 
  1577	 * $Id$
  1578	 *
  1579	 * TODO To change the template for this generated file go to
  1580	 * Window - Preferences - Java - Code Style - Code Templates
  1581	 */
  1582	package tripleo.elijah.lang;
       
  1583	public class RegularTypeName implements TypeName {
       
  1584	public boolean isNull() {
  1585		// TODO Auto-generated method stub
  1586		return false;
  1587	}
       
  1588	public boolean getConstant() {
  1589		// TODO Auto-generated method stub
  1590		return false;
  1591	}
       
  1592	public void setConstant(boolean aFlag) {
  1593		// TODO Auto-generated method stub
  1594		
  1595	}
       
  1596	public boolean getReference() {
  1597		// TODO Auto-generated method stub
  1598		return false;
  1599	}
       
  1600	public void setReference(boolean aFlag) {
  1601		// TODO Auto-generated method stub
  1602		
  1603	}
       
  1604	public boolean getOut() {
  1605		// TODO Auto-generated method stub
  1606		return false;
  1607	}
       
  1608	public void setOut(boolean aFlag) {
  1609		// TODO Auto-generated method stub
  1610		
  1611	}
       
  1612	public boolean getIn() {
  1613		// TODO Auto-generated method stub
  1614		return false;
  1615	}
       
  1616	public void setIn(boolean aFlag) {
  1617		// TODO Auto-generated method stub
  1618		
  1619	}
  1620	
       
  1621	2019-01-11 06:34     tripleo/elijah/lang/RegularTypeName.java     Page 2
       
       
       
  1622	public String getName() {
  1623		// TODO Auto-generated method stub
  1624		return null;
  1625	}
       
  1626	public void setName(String aS) {
  1627		// TODO Auto-generated method stub
  1628		
  1629	}
       
  1630	public void set(int aI) {
  1631		// TODO Auto-generated method stub
  1632		
  1633	}
       
  1634	public TypeName typeName(String aS) {
  1635		// TODO Auto-generated method stub
  1636		return null;
  1637	}
       
  1638	public TypeName typeof(String aS) {
  1639		// TODO Auto-generated method stub
  1640		return null;
  1641	}
       
  1642	public TypeName returnValue() {
  1643		// TODO Auto-generated method stub
  1644		return null;
  1645	}
       
       
  1646	private TypeModifiers tm;
       
  1647	public void type(TypeModifiers atm) {
  1648	tm=atm;		
  1649	}
  1650	public TypeNameList argList() {
  1651		// TODO Auto-generated method stub
  1652		return null;
  1653	}
       
  1654	public void set(TypeModifiers aModifiers) {
  1655		// TODO Auto-generated method stub
  1656		
  1657	}
  1658	}
       
  1659	
       
  1660	2019-01-11 06:34          tripleo/elijah/lang/Scope.java          Page 1
       
       
  1661	// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
  1662	// Jad home page: http://www.geocities.com/kpdus/jad.html
  1663	// Decompiler options: packimports(3) 
  1664	// Source File Name:   Scope.java
       
  1665	package tripleo.elijah.lang;
       
       
  1666	// Referenced classes of package pak2:
  1667	//			StatementClosure, BlockStatement
       
  1668	public interface Scope {
       
  1669		public abstract void statementWrapper(IExpression aExpr);
       
  1670		public abstract void addDocString(String s);
       
  1671		public abstract StatementClosure statementClosure();
       
  1672		public abstract BlockStatement blockStatement();
       
  1673		public abstract void add(StatementItem aItem);
  1674	}
  1675	
       
  1676	2019-01-11 06:34      tripleo/elijah/lang/ScopeElement.java       Page 1
       
       
  1677	// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
  1678	// Jad home page: http://www.geocities.com/kpdus/jad.html
  1679	// Decompiler options: packimports(3) 
  1680	// Source File Name:   ScopeElement.java
       
  1681	package tripleo.elijah.lang;
       
  1682	import java.io.IOException;
       
  1683	import tripleo.elijah.util.TabbedOutputStream;
       
  1684	public interface ScopeElement {
       
  1685		public abstract void print_osi(TabbedOutputStream tabbedoutputstream)
  1686				throws IOException;
  1687	}
  1688	
       
  1689	2019-01-11 06:34        tripleo/elijah/lang/Statement.java        Page 1
       
       
  1690	// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
  1691	// Jad home page: http://www.geocities.com/kpdus/jad.html
  1692	// Decompiler options: packimports(3) 
  1693	// Source File Name:   Statement.java
       
  1694	package tripleo.elijah.lang;
       
  1695	public interface Statement {
  1696	}
  1697	
       
  1698	2019-01-11 06:34    tripleo/elijah/lang/StringExpression.java     Page 1
       
       
  1699	// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
  1700	// Jad home page: http://www.geocities.com/kpdus/jad.html
  1701	// Decompiler options: packimports(3) 
  1702	// Source File Name:   IExpression.java
       
  1703	package tripleo.elijah.lang;
       
  1704	import java.io.IOException;
       
  1705	import tripleo.elijah.util.TabbedOutputStream;
       
  1706	public class StringExpression extends AbstractExpression {
       
  1707	public StringExpression(String g) {
  1708	set(g);
  1709	}
       
  1710		public  void print_osi(TabbedOutputStream tabbedoutputstream)
  1711				throws IOException {
  1712			assert false;
  1713		}
       
  1714		public  IExpression getLeft() {
  1715			assert false;
  1716			return null;
  1717		}
       
  1718		public void setLeft(IExpression iexpression) {
  1719			assert false;
  1720		}
       
  1721		public  IExpression getRight() {
  1722			assert false;
  1723			return null;
  1724		}
       
  1725		public  void setRight(IExpression iexpression){
  1726			assert false;
  1727		}
       
  1728		public  String repr_() {return repr_;}
       
  1729		public void set(String g) {repr_ = g;}
  1730		String repr_;
  1731	}
  1732	
       
  1733	2019-01-11 06:34      tripleo/elijah/lang/StatementItem.java      Page 1
       
       
  1734	/*
  1735	 * Created on Sep 1, 2005 6:33:13 PM
  1736	 * 
  1737	 * $Id$
  1738	 *
  1739	 * TODO To change the template for this generated file go to
  1740	 * Window - Preferences - Java - Code Style - Code Templates
  1741	 */
  1742	package tripleo.elijah.lang;
       
  1743	/**
  1744	 * @author olu
  1745	 *
  1746	 */
  1747	public interface StatementItem {
       
  1748	}
       
  1749	
       
  1750	2019-01-11 06:34         tripleo/elijah/lang/StrRef.java          Page 1
       
       
  1751	// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
  1752	// Jad home page: http://www.geocities.com/kpdus/jad.html
  1753	// Decompiler options: packimports(3) 
  1754	// Source File Name:   StrRef.java
       
  1755	package tripleo.elijah.lang;
       
  1756	// Referenced classes of package pak:
  1757	//			AbstractExpression
       
  1758	public class StrRef extends AbstractExpression {
       
  1759		public StrRef(String n) {
  1760			value = n;
  1761		}
       
  1762		public String repr_() {
  1763			return (new StringBuilder("StrRef (")).append(value).append(")")
  1764					.toString();
  1765		}
       
  1766		public String value;
  1767	}
  1768	
       
  1769	2019-01-11 06:34   tripleo/elijah/lang/SubtractExpression.java    Page 1
       
       
  1770	// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
  1771	// Jad home page: http://www.geocities.com/kpdus/jad.html
  1772	// Decompiler options: packimports(3) 
  1773	// Source File Name:   SubtractExpression.java
       
  1774	package tripleo.elijah.lang;
       
  1775	// Referenced classes of package pak:
  1776	//			AbstractExpression
       
  1777	public class SubtractExpression extends AbstractExpression {
       
  1778		public SubtractExpression() {
  1779		}
       
  1780		public String repr_() {
  1781			return "SubtractExpression";
  1782		}
  1783	}
  1784	
       
  1785	2019-01-11 06:34      tripleo/elijah/lang/SubExpression.java      Page 1
       
       
  1786	/*
  1787	 * Created on Sep 1, 2005 8:28:33 PM
  1788	 * 
  1789	 * $Id$
  1790	 *
  1791	 * TODO To change the template for this generated file go to
  1792	 * Window - Preferences - Java - Code Style - Code Templates
  1793	 */
  1794	package tripleo.elijah.lang;
       
       
  1795	public class SubExpression extends AbstractExpression {
       
  1796	}
  1797	
       
  1798	2019-01-11 06:34   tripleo/elijah/lang/TypeNameExpression.java    Page 1
       
       
  1799	package tripleo.elijah.lang;
       
       
  1800	/*
  1801	 * Created on Sep 1, 2005 8:10:27 PM
  1802	 * 
  1803	 * $Id$
  1804	 *
  1805	 * TODO To change the template for this generated file go to
  1806	 * Window - Preferences - Java - Code Style - Code Templates
  1807	 */
       
  1808	public class TypeNameExpression extends AbstractExpression {
       
  1809		public TypeNameExpression(TypeName aVr) {
  1810			// TODO Auto-generated constructor stub
  1811		}
       
  1812	}
       
  1813	
       
  1814	2019-01-11 06:34      tripleo/elijah/lang/TypeModifiers.java      Page 1
       
       
  1815	package tripleo.elijah.lang;
       
  1816	public enum TypeModifiers {
  1817	NORMAL,CONST,GC,TAGGED,POOLED,MANUAL,
  1818	LOCAL,ONCE,PROCEDURE,FUNTION,REFPAR,GENERIC, FUNCTION;
  1819	}
       
  1820	
       
  1821	2019-01-11 06:34        tripleo/elijah/lang/TypeName.java         Page 1
       
       
  1822	// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
  1823	// Jad home page: http://www.geocities.com/kpdus/jad.html
  1824	// Decompiler options: packimports(3) 
  1825	// Source File Name:   TypeName.java
       
  1826	package tripleo.elijah.lang;
       
  1827	// Referenced classes of package pak2:
  1828	//			TypeNameList
       
  1829	public interface TypeName {
       
  1830		public abstract boolean isNull();
       
  1831		public abstract boolean getConstant();
       
  1832		public abstract void setConstant(boolean flag);
       
  1833		public abstract boolean getReference();
       
  1834		public abstract void setReference(boolean flag);
       
  1835		public abstract boolean getOut();
       
  1836		public abstract void setOut(boolean flag);
       
  1837		public abstract boolean getIn();
       
  1838		public abstract void setIn(boolean flag);
       
  1839		public abstract String getName();
       
  1840		public abstract void setName(String s);
       
  1841		public abstract void set(TypeModifiers aModifiers);
       
  1842		public abstract TypeName typeName(String s);
       
  1843		public abstract TypeName typeof(String s);
       
  1844		public abstract TypeName returnValue();
       
  1845		public abstract void type(TypeModifiers modifiers);
       
  1846		public abstract TypeNameList argList();
       
  1847	//	public static final int NORMAL = 0;
  1848	//
  1849	//	public static final int CONST = 1;
  1850	//
  1851	//	public static final int GC = 2;
  1852	//
  1853	//	public static final int TAGGED = 3;
  1854	//
  1855	//	public static final int POOLED = 4;
  1856	//
  1857	
       
  1858	2019-01-11 06:34        tripleo/elijah/lang/TypeName.java         Page 2
       
       
  1859	//	public static final int MANUAL = 5;
  1860	//
  1861	//	public static final int LOCAL = 6;
  1862	//
  1863	//	public static final int ONCE = 7;
  1864	//
  1865	//	public static final int PROCEDURE = 32;
  1866	//
  1867	//	public static final int FUNCTION = 33;
       
  1868	}
  1869	
       
  1870	2019-01-11 06:34    tripleo/elijah/lang/VariableReference.java    Page 1
       
       
  1871	package tripleo.elijah.lang;
       
  1872	import java.io.IOException;
       
  1873	import tripleo.elijah.util.TabbedOutputStream;
       
  1874	// Referenced classes of package pak:
  1875	//			AbstractExpression, ProcedureCall, IExpression
       
  1876	public class VariableReference extends AbstractExpression {
       
  1877		public VariableReference() {
  1878		}
       
  1879		public VariableReference(String m) {
  1880			setMain(m);
  1881		}
       
  1882		public void addArrayPart(IExpression p) {
  1883			System.out.println("~~ VarRef addArrayPart");
  1884		}
       
  1885		public void addIdentPart(String s) {
  1886			System.out.println((new StringBuilder("~~ VarRef addIdentPart ("))
  1887					.append(s).append(")").toString());
  1888		}
       
  1889		public void addProcCallPart(ProcedureCall p) {
  1890			System.out.println("~~ VarRef addProcCallPart");
  1891		}
       
  1892		public void print_osi(TabbedOutputStream tos) throws IOException {
  1893			tos.put_string_ln((new StringBuilder("VariableReference { name = \""))
  1894					.append(main).append("\"}").toString());
  1895		}
       
  1896		public String repr_() {
  1897			return (new StringBuilder("VariableReference (")).append(main).append(
  1898					")").toString();
  1899		}
       
  1900		public void setMain(String s) {
  1901			main = s;
  1902			System.out.println(repr_());
  1903		}
       
  1904		public String toString() {
  1905			return repr_();
  1906		}
       
  1907		String main;
       
  1908		public void addColonIdentPart(String aText) {
  1909			System.out.println((new StringBuilder("~~ VarRef addColonIdentPart ("))
  1910					.append(aText).append(")").toString());
  1911		}
  1912	
       
  1913	2019-01-11 06:34    tripleo/elijah/lang/VariableReference.java    Page 2
       
       
  1914	}
  1915	
       
  1916	2019-01-11 06:34      tripleo/elijah/lang/TypeNameList.java       Page 1
       
       
  1917	// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
  1918	// Jad home page: http://www.geocities.com/kpdus/jad.html
  1919	// Decompiler options: packimports(3) 
  1920	// Source File Name:   TypeNameList.java
       
  1921	package tripleo.elijah.lang;
       
  1922	// Referenced classes of package pak2:
  1923	//			TypeName
       
  1924	public class TypeNameList {
       
  1925		public TypeNameList() {
  1926		}
       
  1927		public TypeName next() {
  1928			return null;
  1929		}
  1930	}
  1931	
       
  1932	2019-01-11 06:34         tripleo/elijah/lang/TypeRef.java         Page 1
       
       
  1933	// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
  1934	// Jad home page: http://www.geocities.com/kpdus/jad.html
  1935	// Decompiler options: packimports(3) 
  1936	// Source File Name:   TypeRef.java
       
  1937	package tripleo.elijah.lang;
       
  1938	import java.io.IOException;
       
  1939	import tripleo.elijah.util.TabbedOutputStream;
       
  1940	public class TypeRef {
       
  1941		public TypeRef(String n) {
  1942			basicName = n;
  1943		}
       
  1944		public String getTypeString() {
  1945			return basicName;
  1946		}
       
  1947		public String repr_() {
  1948			return (new StringBuilder("TypeRef (")).append(getTypeString()).append(
  1949					")").toString();
  1950		}
       
  1951		public void print_osi(TabbedOutputStream tos) throws IOException {
  1952			System.out.println(tos.t());
  1953			tos.put_string_ln((new StringBuilder("TypeRef { basicName = ")).append(
  1954					getTypeString()).append(" } ").toString());
  1955			System.out.println(tos.t());
  1956		}
       
  1957		public String basicName;
  1958	}
  1959	
       
  1960	2019-01-11 06:34    tripleo/elijah/lang/VariableSequence.java     Page 1
       
       
  1961	package tripleo.elijah.lang;
       
  1962	import java.io.IOException;
  1963	import java.util.*;
       
  1964	import tripleo.elijah.util.*;
       
       
  1965	// Referenced classes of package pak2:
  1966	//			BlockMember
       
  1967	public class VariableSequence implements BlockMember, StatementItem, FunctionItem {
       
  1968		public VariableSequence() {
  1969			stmts = new ArrayList<VariableStatement>();
  1970		}
       
  1971		private TypeModifiers def;
       
  1972		public void defaultModifiers(TypeModifiers aModifiers) {def=aModifiers;}
       
  1973		public VariableStatement next() {
  1974			VariableStatement st = new VariableStatement(this);
  1975			st.set(def);
  1976			stmts.add(st);
  1977			return st;
  1978		}
       
  1979		List<VariableStatement> stmts;
       
  1980		public void print_osi(TabbedOutputStream aTos) throws IOException {
  1981			NotImplementedException.raise();
  1982			//
  1983			aTos.incr_tabs();
  1984			aTos.put_string_ln("var");
  1985			for (VariableStatement stmt: stmts) {
  1986				stmt.print_osi(aTos);
  1987			}
  1988			aTos.dec_tabs();
  1989		}
       
  1990		public Collection<VariableStatement> items() {
  1991			return stmts;
  1992		}
  1993	}
       
  1994	
       
  1995	2019-01-11 06:34    tripleo/elijah/lang/VariableStatement.java    Page 1
       
       
  1996	package tripleo.elijah.lang;
       
  1997	import java.io.IOException;
       
       
  1998	import tripleo.elijah.util.TabbedOutputStream;
       
  1999	// Referenced classes of package pak:
  2000	//			TypeRef, IExpression
       
  2001	public class VariableStatement {
       
  2002		public VariableStatement(VariableSequence aSequence) {
  2003			parent = aSequence;
  2004		}
       
  2005		public String getName() {
  2006			return name;
  2007		}
       
  2008		public String getTypeString() {
  2009			return typeRef.getTypeString();
  2010		}
       
  2011		public void initial(IExpression aExpr) {
  2012			initialValue=aExpr;
  2013		}
       
  2014		public void print_osi(TabbedOutputStream tos) throws IOException {
  2015			tos.incr_tabs();
  2016			tos.put_string_ln("VariableDeclaration {");
  2017			tos.put_string("name = \"");
  2018			tos.put_string(getName());
  2019			tos.put_string_ln("\"");
  2020			if (typeRef != null) {
  2021				tos.incr_tabs();
  2022				tos.put_string_ln("type = {");
  2023				tos.dec_tabs();
  2024				typeRef.print_osi(tos);
  2025				tos.dec_tabs();
  2026				tos.put_string_ln("} // type = ...");
  2027			}
  2028			tos.put_string_ln("} // VariableDeclaration");
  2029		}
       
  2030		public void printDeclare() {
  2031			System.out.print("** Declare Variable: ");
  2032			System.out.print(name);
  2033			System.out.print(" as ");
  2034			System.out.print(getTypeString());
  2035			System.out.println(" (agn not shown at all) **");
  2036		}
       
  2037		public void set(TypeModifiers y) {
  2038			type = y;
  2039		}
  2040	
       
  2041	2019-01-11 06:34    tripleo/elijah/lang/VariableStatement.java    Page 2
       
       
       
  2042		public void setInitialValue(IExpression e) {
  2043			initialValue = e;
  2044		}
       
  2045		public void setName(String s) {
  2046			name = s;
  2047		}
       
  2048		public void setTypeObject(TypeRef t) {
  2049			typeRef = t;
  2050		}
       
  2051		public TypeName typeName() {
  2052			return typeName;
  2053		}
       
  2054		IExpression initialValue = IExpression.UNASSIGNED;
  2055		public String name;
  2056		private final VariableSequence parent;
  2057		TypeModifiers type;
  2058		TypeName typeName = new VariableTypeName();
  2059		TypeRef typeRef;
       
  2060	}
  2061	
       
  2062	2019-01-11 06:34    tripleo/elijah/lang/VariableTypeName.java     Page 1
       
       
  2063	/*
  2064	 * Created on Sep 1, 2005 4:55:12 PM
  2065	 * 
  2066	 * $Id$
  2067	 *
  2068	 * TODO To change the template for this generated file go to
  2069	 * Window - Preferences - Java - Code Style - Code Templates
  2070	 */
  2071	package tripleo.elijah.lang;
       
       
  2072	public class VariableTypeName extends AbstractTypeName implements TypeName {
       
  2073		public TypeName typeName(String aS) {
  2074			// TODO Auto-generated method stub
  2075			return null;
  2076		}
       
  2077		public TypeName typeof(String aS) {
  2078			// TODO Auto-generated method stub
  2079			return null;
  2080		}
       
  2081		public TypeName returnValue() {
  2082			// TODO Auto-generated method stub
  2083			return null;
  2084		}
       
  2085		public void type(int aI) {
  2086			// TODO Auto-generated method stub
       
  2087		}
       
  2088		public TypeNameList argList() {
  2089			// TODO Auto-generated method stub
  2090			return null;
  2091		}
       
  2092		public void set(TypeModifiers aModifiers) {
  2093			// TODO Auto-generated method stub
  2094			
  2095		}
       
  2096	}
       
  2097	
       
  2098	2019-01-11 06:34     tripleo/elijah/lang/YieldExpression.java     Page 1
       
       
  2099	// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
  2100	// Jad home page: http://www.geocities.com/kpdus/jad.html
  2101	// Decompiler options: packimports(3) 
  2102	// Source File Name:   YieldExpression.java
       
  2103	package tripleo.elijah.lang;
       
       
  2104	public class YieldExpression extends AbstractExpression implements StatementItem {
       
  2105		public YieldExpression(Scope aScope) {
  2106		}
  2107	}
  2108	
       
  2109	2019-01-11 06:34         tripleo/elijah/lang/_Scope.java          Page 1
       
       
  2110	// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
  2111	// Jad home page: http://www.geocities.com/kpdus/jad.html
  2112	// Decompiler options: packimports(3) 
  2113	// Source File Name:   _Scope.java
       
  2114	package tripleo.elijah.lang;
       
       
  2115	// Referenced classes of package pak:
  2116	//			ScopeElement, ExprListListener, IExpression
       
  2117	public interface _Scope extends ScopeElement {
  2118		public static abstract class ScopeExprListener implements ExprListListener {
       
  2119			abstract String getScopeListenerName();
       
  2120			public void change(IExpression e) {
  2121				System.out.println((new StringBuilder(String
  2122						.valueOf(getScopeListenerName()))).append(" changed")
  2123						.toString());
  2124				changed++;
  2125			}
       
  2126			public String repr_() {
  2127				return (new StringBuilder("{")).append(getScopeListenerName())
  2128						.append("}").toString();
  2129			}
       
  2130			public boolean isEmpty() {
  2131				return changed == 0;
  2132			}
       
  2133			int changed;
       
  2134			public ScopeExprListener() {
  2135			}
  2136		}
       
  2137		public abstract String repr_();
       
  2138		public abstract void push(ScopeElement scopeelement);
       
  2139		public abstract ExprListListener getListener();
  2140	}
  2141	
       
  2142	2019-01-11 06:34 tripleo/elijah/util/NotImplementedException.java Page 1
       
       
  2143	package tripleo.elijah.util;
  2144	
  2145	public class NotImplementedException extends RuntimeException {
  2146	public NotImplementedException() {
  2147		int y=2;
  2148	}
  2149	
  2150	public static void raise() {
  2151		int y=2;
  2152		
  2153	}
  2154	}
  2155	
  2156	
       
  2157	2019-01-11 06:34   tripleo/elijah/util/TabbedOutputStream.java    Page 1
       
       
  2158	// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
  2159	// Jad home page: http://www.geocities.com/kpdus/jad.html
  2160	// Decompiler options: packimports(3) 
  2161	// Source File Name:   TabbedOutputStream.java
       
  2162	package tripleo.elijah.util;
       
  2163	import java.io.*;
       
  2164	public class TabbedOutputStream
  2165	{
       
  2166		public int t()
  2167		{
  2168			return tabwidth;
  2169		}
       
  2170		void doIndent()
  2171			throws IOException
  2172		{
  2173			for(int i = 0; i < tabwidth; i++)
  2174				myStream.write(9);
       
  2175		}
       
  2176		public TabbedOutputStream(OutputStream os)
  2177		{
  2178			tabwidth = 0;
  2179			myStream = new BufferedWriter(new OutputStreamWriter(os));
  2180		}
       
  2181		public boolean is_connected()
  2182		{
  2183			return myStream != null;
  2184		}
       
  2185		public void put_string_ln(String s)
  2186			throws IOException
  2187		{
  2188			myStream.write(s);
  2189			myStream.write(10);
  2190		}
       
  2191		public void put_newline()
  2192			throws IOException
  2193		{
  2194			doIndent();
  2195		}
       
  2196		public void put_string(String s)
  2197			throws InvalidObjectException, IOException
  2198		{
  2199			if(!is_connected())
  2200			{
  2201				throw new InvalidObjectException("is_connected assertion failed");
  2202			} else
  2203	
       
  2204	2019-01-11 06:34   tripleo/elijah/util/TabbedOutputStream.java    Page 2
       
       
  2205			{
  2206				myStream.write(s);
  2207				return;
  2208			}
  2209		}
       
  2210		public void quote_string(String s)
  2211			throws IOException
  2212		{
  2213			myStream.write(34);
  2214			myStream.write(s);
  2215			myStream.write(34);
  2216		}
       
  2217		public void close()
  2218			throws IOException
  2219		{
  2220			if(myStream != null)
  2221			{
  2222				myStream.close();
  2223				myStream = null;
  2224			} else
  2225			{
  2226				System.out.println("closing twice");
  2227			}
  2228		}
       
  2229		public void incr_tabs()
  2230		{
  2231			tabwidth++;
  2232		}
       
  2233		public void dec_tabs()
  2234		{
  2235			tabwidth--;
  2236		}
       
  2237		public static void main(String args[])
  2238		{
  2239			TabbedOutputStream tos = new TabbedOutputStream(System.out);
  2240			int i = 0;
  2241			int j = 0;
  2242			try
  2243			{
  2244				for(; i < 10; i++)
  2245				{
  2246					tos.put_string_ln((new Integer(i)).toString());
  2247					tos.incr_tabs();
  2248				}
       
  2249				tos.close();
  2250			}
  2251			catch(IOException ex)
  2252			{
  2253				System.out.println("error");
  2254			}
  2255	
       
  2256	2019-01-11 06:34   tripleo/elijah/util/TabbedOutputStream.java    Page 3
       
       
  2257		}
       
  2258		int tabwidth;
  2259		Writer myStream;
  2260	}
  2261	
       
  2262	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java          Page 1
       
       
  2263	package tripleo.elijah;
       
  2264	// $ANTLR 2.7.1: "osc.g" -> "elijahLexer.java"$
       
  2265	import java.io.*;
  2266	import java.util.Hashtable;
       
  2267	import antlr.*;
  2268	import antlr.collections.impl.BitSet;
       
  2269	public class ElijahLexer extends antlr.debug.DebuggingCharScanner implements
  2270			ElijahTokenTypes, TokenStream {
  2271		public ElijahLexer(InputStream in) {
  2272			this(new ByteBuffer(in));
  2273		}
       
  2274		public ElijahLexer(Reader in) {
  2275			this(new CharBuffer(in));
  2276		}
       
  2277		public ElijahLexer(InputBuffer ib) {
  2278			this(
  2279					new LexerSharedInputState(new antlr.debug.DebuggingInputBuffer(
  2280							ib)));
  2281		}
       
  2282		public ElijahLexer(LexerSharedInputState state) {
  2283			super(state);
  2284			ruleNames = _ruleNames;
  2285			semPredNames = _semPredNames;
  2286			setupDebugging();
  2287			literals = new Hashtable();
  2288			literals.put(new ANTLRHashString("block", this), new Integer(96));
  2289			literals.put(new ANTLRHashString("class", this), new Integer(16));
  2290			literals.put(new ANTLRHashString("procedure", this), new Integer(55));
  2291			literals.put(new ANTLRHashString("tagged", this), new Integer(43));
  2292			literals.put(new ANTLRHashString("to", this), new Integer(32));
  2293			literals.put(new ANTLRHashString("package", this), new Integer(10));
  2294			literals.put(new ANTLRHashString("indexing", this), new Integer(7));
  2295			literals.put(new ANTLRHashString("iterate", this), new Integer(31));
  2296			literals.put(new ANTLRHashString("yield", this), new Integer(28));
  2297			literals.put(new ANTLRHashString("import", this), new Integer(26));
  2298			literals.put(new ANTLRHashString("dtor", this), new Integer(24));
  2299			literals.put(new ANTLRHashString("const", this), new Integer(35));
  2300			literals.put(new ANTLRHashString("gc", this), new Integer(46));
  2301			literals.put(new ANTLRHashString("local", this), new Integer(42));
  2302			literals.put(new ANTLRHashString("while", this), new Integer(29));
  2303			literals.put(new ANTLRHashString("namespace", this), new Integer(12));
  2304			literals.put(new ANTLRHashString("generic", this), new Integer(50));
  2305			literals.put(new ANTLRHashString("ctor", this), new Integer(22));
  2306			literals.put(new ANTLRHashString("alias", this), new Integer(99));
  2307			literals.put(new ANTLRHashString("type", this), new Integer(98));
  2308			literals.put(new ANTLRHashString("do", this), new Integer(30));
  2309			literals.put(new ANTLRHashString("in", this), new Integer(48));
  2310			literals.put(new ANTLRHashString("pooled", this), new Integer(44));
  2311			literals.put(new ANTLRHashString("function", this), new Integer(53));
  2312	
       
  2313	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java          Page 2
       
       
  2314			literals.put(new ANTLRHashString("imports", this), new Integer(15));
  2315			literals.put(new ANTLRHashString("once", this), new Integer(41));
  2316			literals.put(new ANTLRHashString("closure", this), new Integer(97));
  2317			literals.put(new ANTLRHashString("is_a", this), new Integer(80));
  2318			literals.put(new ANTLRHashString("elseif", this), new Integer(39));
  2319			literals.put(new ANTLRHashString("ref", this), new Integer(47));
  2320			literals.put(new ANTLRHashString("from", this), new Integer(25));
  2321			literals.put(new ANTLRHashString("typeof", this), new Integer(40));
  2322			literals.put(new ANTLRHashString("out", this), new Integer(49));
  2323			literals.put(new ANTLRHashString("if", this), new Integer(37));
  2324			literals.put(new ANTLRHashString("constructor", this), new Integer(21));
  2325			literals.put(new ANTLRHashString("struct", this), new Integer(100));
  2326			literals.put(new ANTLRHashString("manual", this), new Integer(45));
  2327			literals.put(new ANTLRHashString("construct", this), new Integer(27));
  2328			literals.put(new ANTLRHashString("else", this), new Integer(38));
  2329			literals.put(new ANTLRHashString("var", this), new Integer(34));
  2330			literals.put(new ANTLRHashString("with", this), new Integer(33));
  2331			literals.put(new ANTLRHashString("destructor", this), new Integer(23));
  2332			caseSensitiveLiterals = true;
  2333			setCaseSensitive(true);
  2334		}
       
  2335		private static final String _ruleNames[] = { "mVOCAB", "mWS_",
  2336				"mTOK_ARROW", "mLPAREN", "mRPAREN", "mLBRACK", "mRBRACK",
  2337				"mLCURLY", "mRCURLY", "mPLUS", "mMINUS", "mEQUALITY",
  2338				"mNOT_EQUALS", "mBECOMES", "mGT", "mLT_", "mGTE", "mLTE", "mTIMES",
  2339				"mDIV", "mMOD", "mLNOT", "mDOT", "mQUESTION", "mTOK_COLON",
  2340				"mSEMI", "mLAND", "mLOR", "mCOMMA", "mBNOT", "mDIV_ASSIGN",
  2341				"mPLUS_ASSIGN", "mINC", "mMINUS_ASSIGN", "mDEC", "mSTAR_ASSIGN",
  2342				"mMOD_ASSIGN", "mSR", "mSR_ASSIGN", "mSL", "mSL_ASSIGN", "mBXOR",
  2343				"mBXOR_ASSIGN", "mBOR", "mBOR_ASSIGN", "mBAND", "mBAND_ASSIGN",
  2344				"mSL_COMMENT", "mML_COMMENT", "mCHAR_LITERAL", "mESC", "mTQUOT",
  2345				"mSTRING_LITERAL", "mHEX_DIGIT", "mIDENT", "mQIDENT", "mNUM_INT",
  2346				"mEXPONENT", "mFLOAT_SUFFIX", };
       
  2347		public Token nextToken() throws TokenStreamException {
  2348			Token theRetToken = null;
  2349			tryAgain: for (;;) {
  2350				Token _token = null;
  2351				int _ttype = Token.INVALID_TYPE;
  2352				resetText();
  2353				try { // for char stream error handling
  2354					try { // for lexical error handling
  2355						switch (LA(1)) {
  2356						case '\t':
  2357						case '\n':
  2358						case '\u000c':
  2359						case '\r':
  2360						case ' ': {
  2361							mWS_(true);
  2362							theRetToken = _returnToken;
  2363							break;
  2364						}
  2365						case '(': {
  2366							mLPAREN(true);
  2367							theRetToken = _returnToken;
  2368	
       
  2369	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java          Page 3
       
       
  2370							break;
  2371						}
  2372						case ')': {
  2373							mRPAREN(true);
  2374							theRetToken = _returnToken;
  2375							break;
  2376						}
  2377						case '[': {
  2378							mLBRACK(true);
  2379							theRetToken = _returnToken;
  2380							break;
  2381						}
  2382						case ']': {
  2383							mRBRACK(true);
  2384							theRetToken = _returnToken;
  2385							break;
  2386						}
  2387						case '{': {
  2388							mLCURLY(true);
  2389							theRetToken = _returnToken;
  2390							break;
  2391						}
  2392						case '}': {
  2393							mRCURLY(true);
  2394							theRetToken = _returnToken;
  2395							break;
  2396						}
  2397						case '?': {
  2398							mQUESTION(true);
  2399							theRetToken = _returnToken;
  2400							break;
  2401						}
  2402						case ':': {
  2403							mTOK_COLON(true);
  2404							theRetToken = _returnToken;
  2405							break;
  2406						}
  2407						case ';': {
  2408							mSEMI(true);
  2409							theRetToken = _returnToken;
  2410							break;
  2411						}
  2412						case ',': {
  2413							mCOMMA(true);
  2414							theRetToken = _returnToken;
  2415							break;
  2416						}
  2417						case '~': {
  2418							mBNOT(true);
  2419							theRetToken = _returnToken;
  2420							break;
  2421						}
  2422						case '\'': {
  2423							mCHAR_LITERAL(true);
  2424							theRetToken = _returnToken;
  2425							break;
  2426	
       
  2427	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java          Page 4
       
       
  2428						}
  2429						case '"': {
  2430							mSTRING_LITERAL(true);
  2431							theRetToken = _returnToken;
  2432							break;
  2433						}
  2434						case '$':
  2435						case 'A':
  2436						case 'B':
  2437						case 'C':
  2438						case 'D':
  2439						case 'E':
  2440						case 'F':
  2441						case 'G':
  2442						case 'H':
  2443						case 'I':
  2444						case 'J':
  2445						case 'K':
  2446						case 'L':
  2447						case 'M':
  2448						case 'N':
  2449						case 'O':
  2450						case 'P':
  2451						case 'Q':
  2452						case 'R':
  2453						case 'S':
  2454						case 'T':
  2455						case 'U':
  2456						case 'V':
  2457						case 'W':
  2458						case 'X':
  2459						case 'Y':
  2460						case 'Z':
  2461						case '_':
  2462						case 'a':
  2463						case 'b':
  2464						case 'c':
  2465						case 'd':
  2466						case 'e':
  2467						case 'f':
  2468						case 'g':
  2469						case 'h':
  2470						case 'i':
  2471						case 'j':
  2472						case 'k':
  2473						case 'l':
  2474						case 'm':
  2475						case 'n':
  2476						case 'o':
  2477						case 'p':
  2478						case 'q':
  2479						case 'r':
  2480						case 's':
  2481						case 't':
  2482						case 'u':
  2483						case 'v':
  2484	
       
  2485	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java          Page 5
       
       
  2486						case 'w':
  2487						case 'x':
  2488						case 'y':
  2489						case 'z': {
  2490							mIDENT(true);
  2491							theRetToken = _returnToken;
  2492							break;
  2493						}
  2494						case '`': {
  2495							mQIDENT(true);
  2496							theRetToken = _returnToken;
  2497							break;
  2498						}
  2499						default:
  2500							if ((LA(1) == '/') && (LA(2) == '*')
  2501									&& ((LA(3) >= '\u0003' && LA(3) <= '\u00ff'))
  2502									&& ((LA(4) >= '\u0003' && LA(4) <= '\u00ff'))) {
  2503								mML_COMMENT(true);
  2504								theRetToken = _returnToken;
  2505							} else if ((LA(1) == '-') && (LA(2) == '-')
  2506									&& (_tokenSet_0.member(LA(3))) && (true)) {
  2507								mDEC(true);
  2508								theRetToken = _returnToken;
  2509							} else if ((LA(1) == '>') && (LA(2) == '>')
  2510									&& (LA(3) == '=')) {
  2511								mSR_ASSIGN(true);
  2512								theRetToken = _returnToken;
  2513							} else if ((LA(1) == '<') && (LA(2) == '<')
  2514									&& (LA(3) == '=')) {
  2515								mSL_ASSIGN(true);
  2516								theRetToken = _returnToken;
  2517							} else if ((LA(1) == '-') && (LA(2) == '>') && (true)
  2518									&& (true)) {
  2519								mTOK_ARROW(true);
  2520								theRetToken = _returnToken;
  2521							} else if ((LA(1) == '=') && (LA(2) == '=')) {
  2522								mEQUALITY(true);
  2523								theRetToken = _returnToken;
  2524							} else if ((LA(1) == '!') && (LA(2) == '=')) {
  2525								mNOT_EQUALS(true);
  2526								theRetToken = _returnToken;
  2527							} else if ((LA(1) == '>') && (LA(2) == '=')) {
  2528								mGTE(true);
  2529								theRetToken = _returnToken;
  2530							} else if ((LA(1) == '<') && (LA(2) == '=')) {
  2531								mLTE(true);
  2532								theRetToken = _returnToken;
  2533							} else if ((LA(1) == '&') && (LA(2) == '&')) {
  2534								mLAND(true);
  2535								theRetToken = _returnToken;
  2536							} else if ((LA(1) == '|') && (LA(2) == '|')) {
  2537								mLOR(true);
  2538								theRetToken = _returnToken;
  2539							} else if ((LA(1) == '/') && (LA(2) == '=') && (true)
  2540									&& (true)) {
  2541								mDIV_ASSIGN(true);
  2542	
       
  2543	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java          Page 6
       
       
  2544								theRetToken = _returnToken;
  2545							} else if ((LA(1) == '+') && (LA(2) == '=')) {
  2546								mPLUS_ASSIGN(true);
  2547								theRetToken = _returnToken;
  2548							} else if ((LA(1) == '+') && (LA(2) == '+')) {
  2549								mINC(true);
  2550								theRetToken = _returnToken;
  2551							} else if ((LA(1) == '-') && (LA(2) == '=') && (true)
  2552									&& (true)) {
  2553								mMINUS_ASSIGN(true);
  2554								theRetToken = _returnToken;
  2555							} else if ((LA(1) == '*') && (LA(2) == '=')) {
  2556								mSTAR_ASSIGN(true);
  2557								theRetToken = _returnToken;
  2558							} else if ((LA(1) == '%') && (LA(2) == '=')) {
  2559								mMOD_ASSIGN(true);
  2560								theRetToken = _returnToken;
  2561							} else if ((LA(1) == '>') && (LA(2) == '>') && (true)) {
  2562								mSR(true);
  2563								theRetToken = _returnToken;
  2564							} else if ((LA(1) == '<') && (LA(2) == '<') && (true)) {
  2565								mSL(true);
  2566								theRetToken = _returnToken;
  2567							} else if ((LA(1) == '^') && (LA(2) == '=')) {
  2568								mBXOR_ASSIGN(true);
  2569								theRetToken = _returnToken;
  2570							} else if ((LA(1) == '|') && (LA(2) == '=')) {
  2571								mBOR_ASSIGN(true);
  2572								theRetToken = _returnToken;
  2573							} else if ((LA(1) == '&') && (LA(2) == '=')) {
  2574								mBAND_ASSIGN(true);
  2575								theRetToken = _returnToken;
  2576							} else if ((LA(1) == '#' || LA(1) == '-' || LA(1) == '/')
  2577									&& ((LA(2) >= '\u0003' && LA(2) <= '\u00ff'))
  2578									&& (true) && (true)) {
  2579								mSL_COMMENT(true);
  2580								theRetToken = _returnToken;
  2581							} else if ((LA(1) == '+') && (true)) {
  2582								mPLUS(true);
  2583								theRetToken = _returnToken;
  2584							} else if ((LA(1) == '-') && (true)) {
  2585								mMINUS(true);
  2586								theRetToken = _returnToken;
  2587							} else if ((LA(1) == '=') && (true)) {
  2588								mBECOMES(true);
  2589								theRetToken = _returnToken;
  2590							} else if ((LA(1) == '>') && (true)) {
  2591								mGT(true);
  2592								theRetToken = _returnToken;
  2593							} else if ((LA(1) == '<') && (true)) {
  2594								mLT_(true);
  2595								theRetToken = _returnToken;
  2596							} else if ((LA(1) == '*') && (true)) {
  2597								mTIMES(true);
  2598								theRetToken = _returnToken;
  2599							} else if ((LA(1) == '/') && (true)) {
  2600	
       
  2601	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java          Page 7
       
       
  2602								mDIV(true);
  2603								theRetToken = _returnToken;
  2604							} else if ((LA(1) == '%') && (true)) {
  2605								mMOD(true);
  2606								theRetToken = _returnToken;
  2607							} else if ((LA(1) == '!') && (true)) {
  2608								mLNOT(true);
  2609								theRetToken = _returnToken;
  2610							} else if ((LA(1) == '.') && (true) && (true) && (true)) {
  2611								mDOT(true);
  2612								theRetToken = _returnToken;
  2613							} else if ((LA(1) == '^') && (true)) {
  2614								mBXOR(true);
  2615								theRetToken = _returnToken;
  2616							} else if ((LA(1) == '|') && (true)) {
  2617								mBOR(true);
  2618								theRetToken = _returnToken;
  2619							} else if ((LA(1) == '&') && (true)) {
  2620								mBAND(true);
  2621								theRetToken = _returnToken;
  2622							} else if ((_tokenSet_1.member(LA(1))) && (true) && (true) && (true)) {
  2623								mNUM_INT(true);
  2624								theRetToken = _returnToken;
  2625							} else {
  2626								if (LA(1) == EOF_CHAR) {
  2627									uponEOF();
  2628									_returnToken = makeToken(Token.EOF_TYPE);
  2629								} else {
  2630									throw new NoViableAltForCharException(
  2631											(char) LA(1), getFilename(), getLine());
  2632								}
  2633							}
  2634						}
  2635						if (_returnToken == null)
  2636							continue tryAgain; // found SKIP token
  2637						_ttype = _returnToken.getType();
  2638						_ttype = testLiteralsTable(_ttype);
  2639						_returnToken.setType(_ttype);
  2640						return _returnToken;
  2641					} catch (RecognitionException e) {
  2642						throw new TokenStreamRecognitionException(e);
  2643					}
  2644				} catch (CharStreamException cse) {
  2645					if (cse instanceof CharStreamIOException) {
  2646						throw new TokenStreamIOException(
  2647								((CharStreamIOException) cse).io);
  2648					} else {
  2649						throw new TokenStreamException(cse.getMessage());
  2650					}
  2651				}
  2652			}
  2653		}
       
  2654		protected final void mVOCAB(boolean _createToken)
  2655				throws RecognitionException, CharStreamException,
  2656				TokenStreamException {
  2657	
       
  2658	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java          Page 8
       
       
  2659			int _ttype;
  2660			Token _token = null;
  2661			int _begin = text.length();
  2662			_ttype = VOCAB;
  2663			int _saveIndex;
  2664			fireEnterRule(0, _ttype);
  2665			try { // debugging
       
  2666				matchRange('\3', '\377');
  2667				if (_createToken && _token == null && _ttype != Token.SKIP) {
  2668					_token = makeToken(_ttype);
  2669					_token.setText(new String(text.getBuffer(), _begin, text
  2670							.length()
  2671							- _begin));
  2672				}
  2673				_returnToken = _token;
  2674			} finally { // debugging
  2675				fireExitRule(0, _ttype);
  2676			}
  2677		}
       
  2678		public final void mWS_(boolean _createToken) throws RecognitionException,
  2679				CharStreamException, TokenStreamException {
  2680			int _ttype;
  2681			Token _token = null;
  2682			int _begin = text.length();
  2683			_ttype = WS_;
  2684			int _saveIndex;
  2685			fireEnterRule(1, _ttype);
  2686			try { // debugging
       
  2687				{
  2688					switch (LA(1)) {
  2689					case ' ': {
  2690						match(' ');
  2691						break;
  2692					}
  2693					case '\t': {
  2694						match('\t');
  2695						break;
  2696					}
  2697					case '\u000c': {
  2698						match('\f');
  2699						break;
  2700					}
  2701					case '\n':
  2702					case '\r': {
  2703						{
  2704							if ((LA(1) == '\r') && (LA(2) == '\n')) {
  2705								match("\r\n");
  2706							} else if ((LA(1) == '\r') && (true)) {
  2707								match('\r');
  2708							} else if ((LA(1) == '\n')) {
  2709								match('\n');
  2710							} else {
  2711								throw new NoViableAltForCharException((char) LA(1),
  2712	
       
  2713	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java          Page 9
       
       
  2714										getFilename(), getLine());
  2715							}
       
  2716						}
  2717						newline();
  2718						break;
  2719					}
  2720					default: {
  2721						throw new NoViableAltForCharException((char) LA(1),
  2722								getFilename(), getLine());
  2723					}
  2724					}
  2725				}
  2726				_ttype = Token.SKIP;
  2727				if (_createToken && _token == null && _ttype != Token.SKIP) {
  2728					_token = makeToken(_ttype);
  2729					_token.setText(new String(text.getBuffer(), _begin, text
  2730							.length()
  2731							- _begin));
  2732				}
  2733				_returnToken = _token;
  2734			} finally { // debugging
  2735				fireExitRule(1, _ttype);
  2736			}
  2737		}
       
  2738		public final void mTOK_ARROW(boolean _createToken)
  2739				throws RecognitionException, CharStreamException,
  2740				TokenStreamException {
  2741			int _ttype;
  2742			Token _token = null;
  2743			int _begin = text.length();
  2744			_ttype = TOK_ARROW;
  2745			int _saveIndex;
  2746			fireEnterRule(2, _ttype);
  2747			try { // debugging
       
  2748				match("->");
  2749				if (_createToken && _token == null && _ttype != Token.SKIP) {
  2750					_token = makeToken(_ttype);
  2751					_token.setText(new String(text.getBuffer(), _begin, text
  2752							.length()
  2753							- _begin));
  2754				}
  2755				_returnToken = _token;
  2756			} finally { // debugging
  2757				fireExitRule(2, _ttype);
  2758			}
  2759		}
       
  2760		public final void mLPAREN(boolean _createToken)
  2761				throws RecognitionException, CharStreamException,
  2762				TokenStreamException {
  2763			int _ttype;
  2764			Token _token = null;
  2765			int _begin = text.length();
  2766	
       
  2767	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 10
       
       
  2768			_ttype = LPAREN;
  2769			int _saveIndex;
  2770			fireEnterRule(3, _ttype);
  2771			try { // debugging
       
  2772				match('(');
  2773				if (_createToken && _token == null && _ttype != Token.SKIP) {
  2774					_token = makeToken(_ttype);
  2775					_token.setText(new String(text.getBuffer(), _begin, text
  2776							.length()
  2777							- _begin));
  2778				}
  2779				_returnToken = _token;
  2780			} finally { // debugging
  2781				fireExitRule(3, _ttype);
  2782			}
  2783		}
       
  2784		public final void mRPAREN(boolean _createToken)
  2785				throws RecognitionException, CharStreamException,
  2786				TokenStreamException {
  2787			int _ttype;
  2788			Token _token = null;
  2789			int _begin = text.length();
  2790			_ttype = RPAREN;
  2791			int _saveIndex;
  2792			fireEnterRule(4, _ttype);
  2793			try { // debugging
       
  2794				match(')');
  2795				if (_createToken && _token == null && _ttype != Token.SKIP) {
  2796					_token = makeToken(_ttype);
  2797					_token.setText(new String(text.getBuffer(), _begin, text
  2798							.length()
  2799							- _begin));
  2800				}
  2801				_returnToken = _token;
  2802			} finally { // debugging
  2803				fireExitRule(4, _ttype);
  2804			}
  2805		}
       
  2806		public final void mLBRACK(boolean _createToken)
  2807				throws RecognitionException, CharStreamException,
  2808				TokenStreamException {
  2809			int _ttype;
  2810			Token _token = null;
  2811			int _begin = text.length();
  2812			_ttype = LBRACK;
  2813			int _saveIndex;
  2814			fireEnterRule(5, _ttype);
  2815			try { // debugging
       
  2816				match('[');
  2817				if (_createToken && _token == null && _ttype != Token.SKIP) {
  2818					_token = makeToken(_ttype);
  2819	
       
  2820	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 11
       
       
  2821					_token.setText(new String(text.getBuffer(), _begin, text
  2822							.length()
  2823							- _begin));
  2824				}
  2825				_returnToken = _token;
  2826			} finally { // debugging
  2827				fireExitRule(5, _ttype);
  2828			}
  2829		}
       
  2830		public final void mRBRACK(boolean _createToken)
  2831				throws RecognitionException, CharStreamException,
  2832				TokenStreamException {
  2833			int _ttype;
  2834			Token _token = null;
  2835			int _begin = text.length();
  2836			_ttype = RBRACK;
  2837			int _saveIndex;
  2838			fireEnterRule(6, _ttype);
  2839			try { // debugging
       
  2840				match(']');
  2841				if (_createToken && _token == null && _ttype != Token.SKIP) {
  2842					_token = makeToken(_ttype);
  2843					_token.setText(new String(text.getBuffer(), _begin, text
  2844							.length()
  2845							- _begin));
  2846				}
  2847				_returnToken = _token;
  2848			} finally { // debugging
  2849				fireExitRule(6, _ttype);
  2850			}
  2851		}
       
  2852		public final void mLCURLY(boolean _createToken)
  2853				throws RecognitionException, CharStreamException,
  2854				TokenStreamException {
  2855			int _ttype;
  2856			Token _token = null;
  2857			int _begin = text.length();
  2858			_ttype = LCURLY;
  2859			int _saveIndex;
  2860			fireEnterRule(7, _ttype);
  2861			try { // debugging
       
  2862				match('{');
  2863				if (_createToken && _token == null && _ttype != Token.SKIP) {
  2864					_token = makeToken(_ttype);
  2865					_token.setText(new String(text.getBuffer(), _begin, text
  2866							.length()
  2867							- _begin));
  2868				}
  2869				_returnToken = _token;
  2870			} finally { // debugging
  2871				fireExitRule(7, _ttype);
  2872			}
  2873	
       
  2874	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 12
       
       
  2875		}
       
  2876		public final void mRCURLY(boolean _createToken)
  2877				throws RecognitionException, CharStreamException,
  2878				TokenStreamException {
  2879			int _ttype;
  2880			Token _token = null;
  2881			int _begin = text.length();
  2882			_ttype = RCURLY;
  2883			int _saveIndex;
  2884			fireEnterRule(8, _ttype);
  2885			try { // debugging
       
  2886				match('}');
  2887				if (_createToken && _token == null && _ttype != Token.SKIP) {
  2888					_token = makeToken(_ttype);
  2889					_token.setText(new String(text.getBuffer(), _begin, text
  2890							.length()
  2891							- _begin));
  2892				}
  2893				_returnToken = _token;
  2894			} finally { // debugging
  2895				fireExitRule(8, _ttype);
  2896			}
  2897		}
       
  2898		public final void mPLUS(boolean _createToken) throws RecognitionException,
  2899				CharStreamException, TokenStreamException {
  2900			int _ttype;
  2901			Token _token = null;
  2902			int _begin = text.length();
  2903			_ttype = PLUS;
  2904			int _saveIndex;
  2905			fireEnterRule(9, _ttype);
  2906			try { // debugging
       
  2907				match('+');
  2908				if (_createToken && _token == null && _ttype != Token.SKIP) {
  2909					_token = makeToken(_ttype);
  2910					_token.setText(new String(text.getBuffer(), _begin, text
  2911							.length()
  2912							- _begin));
  2913				}
  2914				_returnToken = _token;
  2915			} finally { // debugging
  2916				fireExitRule(9, _ttype);
  2917			}
  2918		}
       
  2919		public final void mMINUS(boolean _createToken) throws RecognitionException,
  2920				CharStreamException, TokenStreamException {
  2921			int _ttype;
  2922			Token _token = null;
  2923			int _begin = text.length();
  2924			_ttype = MINUS;
  2925			int _saveIndex;
  2926	
       
  2927	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 13
       
       
  2928			fireEnterRule(10, _ttype);
  2929			try { // debugging
       
  2930				match('-');
  2931				if (_createToken && _token == null && _ttype != Token.SKIP) {
  2932					_token = makeToken(_ttype);
  2933					_token.setText(new String(text.getBuffer(), _begin, text
  2934							.length()
  2935							- _begin));
  2936				}
  2937				_returnToken = _token;
  2938			} finally { // debugging
  2939				fireExitRule(10, _ttype);
  2940			}
  2941		}
       
  2942		public final void mEQUALITY(boolean _createToken)
  2943				throws RecognitionException, CharStreamException,
  2944				TokenStreamException {
  2945			int _ttype;
  2946			Token _token = null;
  2947			int _begin = text.length();
  2948			_ttype = EQUALITY;
  2949			int _saveIndex;
  2950			fireEnterRule(11, _ttype);
  2951			try { // debugging
       
  2952				match("==");
  2953				if (_createToken && _token == null && _ttype != Token.SKIP) {
  2954					_token = makeToken(_ttype);
  2955					_token.setText(new String(text.getBuffer(), _begin, text
  2956							.length()
  2957							- _begin));
  2958				}
  2959				_returnToken = _token;
  2960			} finally { // debugging
  2961				fireExitRule(11, _ttype);
  2962			}
  2963		}
       
  2964		public final void mNOT_EQUALS(boolean _createToken)
  2965				throws RecognitionException, CharStreamException,
  2966				TokenStreamException {
  2967			int _ttype;
  2968			Token _token = null;
  2969			int _begin = text.length();
  2970			_ttype = NOT_EQUALS;
  2971			int _saveIndex;
  2972			fireEnterRule(12, _ttype);
  2973			try { // debugging
       
  2974				match("!=");
  2975				if (_createToken && _token == null && _ttype != Token.SKIP) {
  2976					_token = makeToken(_ttype);
  2977					_token.setText(new String(text.getBuffer(), _begin, text
  2978							.length()
  2979	
       
  2980	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 14
       
       
  2981							- _begin));
  2982				}
  2983				_returnToken = _token;
  2984			} finally { // debugging
  2985				fireExitRule(12, _ttype);
  2986			}
  2987		}
       
  2988		public final void mBECOMES(boolean _createToken)
  2989				throws RecognitionException, CharStreamException,
  2990				TokenStreamException {
  2991			int _ttype;
  2992			Token _token = null;
  2993			int _begin = text.length();
  2994			_ttype = BECOMES;
  2995			int _saveIndex;
  2996			fireEnterRule(13, _ttype);
  2997			try { // debugging
       
  2998				match('=');
  2999				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3000					_token = makeToken(_ttype);
  3001					_token.setText(new String(text.getBuffer(), _begin, text
  3002							.length()
  3003							- _begin));
  3004				}
  3005				_returnToken = _token;
  3006			} finally { // debugging
  3007				fireExitRule(13, _ttype);
  3008			}
  3009		}
       
  3010		public final void mGT(boolean _createToken) throws RecognitionException,
  3011				CharStreamException, TokenStreamException {
  3012			int _ttype;
  3013			Token _token = null;
  3014			int _begin = text.length();
  3015			_ttype = GT;
  3016			int _saveIndex;
  3017			fireEnterRule(14, _ttype);
  3018			try { // debugging
       
  3019				match(">");
  3020				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3021					_token = makeToken(_ttype);
  3022					_token.setText(new String(text.getBuffer(), _begin, text
  3023							.length()
  3024							- _begin));
  3025				}
  3026				_returnToken = _token;
  3027			} finally { // debugging
  3028				fireExitRule(14, _ttype);
  3029			}
  3030		}
       
  3031		public final void mLT_(boolean _createToken) throws RecognitionException,
  3032	
       
  3033	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 15
       
       
  3034				CharStreamException, TokenStreamException {
  3035			int _ttype;
  3036			Token _token = null;
  3037			int _begin = text.length();
  3038			_ttype = LT_;
  3039			int _saveIndex;
  3040			fireEnterRule(15, _ttype);
  3041			try { // debugging
       
  3042				match("<");
  3043				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3044					_token = makeToken(_ttype);
  3045					_token.setText(new String(text.getBuffer(), _begin, text
  3046							.length()
  3047							- _begin));
  3048				}
  3049				_returnToken = _token;
  3050			} finally { // debugging
  3051				fireExitRule(15, _ttype);
  3052			}
  3053		}
       
  3054		public final void mGTE(boolean _createToken) throws RecognitionException,
  3055				CharStreamException, TokenStreamException {
  3056			int _ttype;
  3057			Token _token = null;
  3058			int _begin = text.length();
  3059			_ttype = GTE;
  3060			int _saveIndex;
  3061			fireEnterRule(16, _ttype);
  3062			try { // debugging
       
  3063				match(">=");
  3064				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3065					_token = makeToken(_ttype);
  3066					_token.setText(new String(text.getBuffer(), _begin, text
  3067							.length()
  3068							- _begin));
  3069				}
  3070				_returnToken = _token;
  3071			} finally { // debugging
  3072				fireExitRule(16, _ttype);
  3073			}
  3074		}
       
  3075		public final void mLTE(boolean _createToken) throws RecognitionException,
  3076				CharStreamException, TokenStreamException {
  3077			int _ttype;
  3078			Token _token = null;
  3079			int _begin = text.length();
  3080			_ttype = LTE;
  3081			int _saveIndex;
  3082			fireEnterRule(17, _ttype);
  3083			try { // debugging
       
  3084				match("<=");
  3085	
       
  3086	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 16
       
       
  3087				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3088					_token = makeToken(_ttype);
  3089					_token.setText(new String(text.getBuffer(), _begin, text
  3090							.length()
  3091							- _begin));
  3092				}
  3093				_returnToken = _token;
  3094			} finally { // debugging
  3095				fireExitRule(17, _ttype);
  3096			}
  3097		}
       
  3098		public final void mTIMES(boolean _createToken) throws RecognitionException,
  3099				CharStreamException, TokenStreamException {
  3100			int _ttype;
  3101			Token _token = null;
  3102			int _begin = text.length();
  3103			_ttype = TIMES;
  3104			int _saveIndex;
  3105			fireEnterRule(18, _ttype);
  3106			try { // debugging
       
  3107				match('*');
  3108				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3109					_token = makeToken(_ttype);
  3110					_token.setText(new String(text.getBuffer(), _begin, text
  3111							.length()
  3112							- _begin));
  3113				}
  3114				_returnToken = _token;
  3115			} finally { // debugging
  3116				fireExitRule(18, _ttype);
  3117			}
  3118		}
       
  3119		public final void mDIV(boolean _createToken) throws RecognitionException,
  3120				CharStreamException, TokenStreamException {
  3121			int _ttype;
  3122			Token _token = null;
  3123			int _begin = text.length();
  3124			_ttype = DIV;
  3125			int _saveIndex;
  3126			fireEnterRule(19, _ttype);
  3127			try { // debugging
       
  3128				match('/');
  3129				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3130					_token = makeToken(_ttype);
  3131					_token.setText(new String(text.getBuffer(), _begin, text
  3132							.length()
  3133							- _begin));
  3134				}
  3135				_returnToken = _token;
  3136			} finally { // debugging
  3137				fireExitRule(19, _ttype);
  3138			}
  3139	
       
  3140	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 17
       
       
  3141		}
       
  3142		public final void mMOD(boolean _createToken) throws RecognitionException,
  3143				CharStreamException, TokenStreamException {
  3144			int _ttype;
  3145			Token _token = null;
  3146			int _begin = text.length();
  3147			_ttype = MOD;
  3148			int _saveIndex;
  3149			fireEnterRule(20, _ttype);
  3150			try { // debugging
       
  3151				match('%');
  3152				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3153					_token = makeToken(_ttype);
  3154					_token.setText(new String(text.getBuffer(), _begin, text
  3155							.length()
  3156							- _begin));
  3157				}
  3158				_returnToken = _token;
  3159			} finally { // debugging
  3160				fireExitRule(20, _ttype);
  3161			}
  3162		}
       
  3163		public final void mLNOT(boolean _createToken) throws RecognitionException,
  3164				CharStreamException, TokenStreamException {
  3165			int _ttype;
  3166			Token _token = null;
  3167			int _begin = text.length();
  3168			_ttype = LNOT;
  3169			int _saveIndex;
  3170			fireEnterRule(21, _ttype);
  3171			try { // debugging
       
  3172				match('!');
  3173				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3174					_token = makeToken(_ttype);
  3175					_token.setText(new String(text.getBuffer(), _begin, text
  3176							.length()
  3177							- _begin));
  3178				}
  3179				_returnToken = _token;
  3180			} finally { // debugging
  3181				fireExitRule(21, _ttype);
  3182			}
  3183		}
       
  3184		public final void mDOT(boolean _createToken) throws RecognitionException,
  3185				CharStreamException, TokenStreamException {
  3186			int _ttype;
  3187			Token _token = null;
  3188			int _begin = text.length();
  3189			_ttype = DOT;
  3190			int _saveIndex;
  3191			fireEnterRule(22, _ttype);
  3192	
       
  3193	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 18
       
       
  3194			try { // debugging
       
  3195				match('.');
  3196				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3197					_token = makeToken(_ttype);
  3198					_token.setText(new String(text.getBuffer(), _begin, text
  3199							.length()
  3200							- _begin));
  3201				}
  3202				_returnToken = _token;
  3203			} finally { // debugging
  3204				fireExitRule(22, _ttype);
  3205			}
  3206		}
       
  3207		public final void mQUESTION(boolean _createToken)
  3208				throws RecognitionException, CharStreamException,
  3209				TokenStreamException {
  3210			int _ttype;
  3211			Token _token = null;
  3212			int _begin = text.length();
  3213			_ttype = QUESTION;
  3214			int _saveIndex;
  3215			fireEnterRule(23, _ttype);
  3216			try { // debugging
       
  3217				match('?');
  3218				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3219					_token = makeToken(_ttype);
  3220					_token.setText(new String(text.getBuffer(), _begin, text
  3221							.length()
  3222							- _begin));
  3223				}
  3224				_returnToken = _token;
  3225			} finally { // debugging
  3226				fireExitRule(23, _ttype);
  3227			}
  3228		}
       
  3229		public final void mTOK_COLON(boolean _createToken)
  3230				throws RecognitionException, CharStreamException,
  3231				TokenStreamException {
  3232			int _ttype;
  3233			Token _token = null;
  3234			int _begin = text.length();
  3235			_ttype = TOK_COLON;
  3236			int _saveIndex;
  3237			fireEnterRule(24, _ttype);
  3238			try { // debugging
       
  3239				match(':');
  3240				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3241					_token = makeToken(_ttype);
  3242					_token.setText(new String(text.getBuffer(), _begin, text
  3243							.length()
  3244							- _begin));
  3245	
       
  3246	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 19
       
       
  3247				}
  3248				_returnToken = _token;
  3249			} finally { // debugging
  3250				fireExitRule(24, _ttype);
  3251			}
  3252		}
       
  3253		public final void mSEMI(boolean _createToken) throws RecognitionException,
  3254				CharStreamException, TokenStreamException {
  3255			int _ttype;
  3256			Token _token = null;
  3257			int _begin = text.length();
  3258			_ttype = SEMI;
  3259			int _saveIndex;
  3260			fireEnterRule(25, _ttype);
  3261			try { // debugging
       
  3262				match(';');
  3263				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3264					_token = makeToken(_ttype);
  3265					_token.setText(new String(text.getBuffer(), _begin, text
  3266							.length()
  3267							- _begin));
  3268				}
  3269				_returnToken = _token;
  3270			} finally { // debugging
  3271				fireExitRule(25, _ttype);
  3272			}
  3273		}
       
  3274		public final void mLAND(boolean _createToken) throws RecognitionException,
  3275				CharStreamException, TokenStreamException {
  3276			int _ttype;
  3277			Token _token = null;
  3278			int _begin = text.length();
  3279			_ttype = LAND;
  3280			int _saveIndex;
  3281			fireEnterRule(26, _ttype);
  3282			try { // debugging
       
  3283				match("&&");
  3284				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3285					_token = makeToken(_ttype);
  3286					_token.setText(new String(text.getBuffer(), _begin, text
  3287							.length()
  3288							- _begin));
  3289				}
  3290				_returnToken = _token;
  3291			} finally { // debugging
  3292				fireExitRule(26, _ttype);
  3293			}
  3294		}
       
  3295		public final void mLOR(boolean _createToken) throws RecognitionException,
  3296				CharStreamException, TokenStreamException {
  3297			int _ttype;
  3298	
       
  3299	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 20
       
       
  3300			Token _token = null;
  3301			int _begin = text.length();
  3302			_ttype = LOR;
  3303			int _saveIndex;
  3304			fireEnterRule(27, _ttype);
  3305			try { // debugging
       
  3306				match("||");
  3307				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3308					_token = makeToken(_ttype);
  3309					_token.setText(new String(text.getBuffer(), _begin, text
  3310							.length()
  3311							- _begin));
  3312				}
  3313				_returnToken = _token;
  3314			} finally { // debugging
  3315				fireExitRule(27, _ttype);
  3316			}
  3317		}
       
  3318		public final void mCOMMA(boolean _createToken) throws RecognitionException,
  3319				CharStreamException, TokenStreamException {
  3320			int _ttype;
  3321			Token _token = null;
  3322			int _begin = text.length();
  3323			_ttype = COMMA;
  3324			int _saveIndex;
  3325			fireEnterRule(28, _ttype);
  3326			try { // debugging
       
  3327				match(',');
  3328				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3329					_token = makeToken(_ttype);
  3330					_token.setText(new String(text.getBuffer(), _begin, text
  3331							.length()
  3332							- _begin));
  3333				}
  3334				_returnToken = _token;
  3335			} finally { // debugging
  3336				fireExitRule(28, _ttype);
  3337			}
  3338		}
       
  3339		public final void mBNOT(boolean _createToken) throws RecognitionException,
  3340				CharStreamException, TokenStreamException {
  3341			int _ttype;
  3342			Token _token = null;
  3343			int _begin = text.length();
  3344			_ttype = BNOT;
  3345			int _saveIndex;
  3346			fireEnterRule(29, _ttype);
  3347			try { // debugging
       
  3348				match('~');
  3349				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3350					_token = makeToken(_ttype);
  3351	
       
  3352	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 21
       
       
  3353					_token.setText(new String(text.getBuffer(), _begin, text
  3354							.length()
  3355							- _begin));
  3356				}
  3357				_returnToken = _token;
  3358			} finally { // debugging
  3359				fireExitRule(29, _ttype);
  3360			}
  3361		}
       
  3362		public final void mDIV_ASSIGN(boolean _createToken)
  3363				throws RecognitionException, CharStreamException,
  3364				TokenStreamException {
  3365			int _ttype;
  3366			Token _token = null;
  3367			int _begin = text.length();
  3368			_ttype = DIV_ASSIGN;
  3369			int _saveIndex;
  3370			fireEnterRule(30, _ttype);
  3371			try { // debugging
       
  3372				match("/=");
  3373				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3374					_token = makeToken(_ttype);
  3375					_token.setText(new String(text.getBuffer(), _begin, text
  3376							.length()
  3377							- _begin));
  3378				}
  3379				_returnToken = _token;
  3380			} finally { // debugging
  3381				fireExitRule(30, _ttype);
  3382			}
  3383		}
       
  3384		public final void mPLUS_ASSIGN(boolean _createToken)
  3385				throws RecognitionException, CharStreamException,
  3386				TokenStreamException {
  3387			int _ttype;
  3388			Token _token = null;
  3389			int _begin = text.length();
  3390			_ttype = PLUS_ASSIGN;
  3391			int _saveIndex;
  3392			fireEnterRule(31, _ttype);
  3393			try { // debugging
       
  3394				match("+=");
  3395				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3396					_token = makeToken(_ttype);
  3397					_token.setText(new String(text.getBuffer(), _begin, text
  3398							.length()
  3399							- _begin));
  3400				}
  3401				_returnToken = _token;
  3402			} finally { // debugging
  3403				fireExitRule(31, _ttype);
  3404			}
  3405	
       
  3406	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 22
       
       
  3407		}
       
  3408		public final void mINC(boolean _createToken) throws RecognitionException,
  3409				CharStreamException, TokenStreamException {
  3410			int _ttype;
  3411			Token _token = null;
  3412			int _begin = text.length();
  3413			_ttype = INC;
  3414			int _saveIndex;
  3415			fireEnterRule(32, _ttype);
  3416			try { // debugging
       
  3417				match("++");
  3418				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3419					_token = makeToken(_ttype);
  3420					_token.setText(new String(text.getBuffer(), _begin, text
  3421							.length()
  3422							- _begin));
  3423				}
  3424				_returnToken = _token;
  3425			} finally { // debugging
  3426				fireExitRule(32, _ttype);
  3427			}
  3428		}
       
  3429		public final void mMINUS_ASSIGN(boolean _createToken)
  3430				throws RecognitionException, CharStreamException,
  3431				TokenStreamException {
  3432			int _ttype;
  3433			Token _token = null;
  3434			int _begin = text.length();
  3435			_ttype = MINUS_ASSIGN;
  3436			int _saveIndex;
  3437			fireEnterRule(33, _ttype);
  3438			try { // debugging
       
  3439				match("-=");
  3440				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3441					_token = makeToken(_ttype);
  3442					_token.setText(new String(text.getBuffer(), _begin, text
  3443							.length()
  3444							- _begin));
  3445				}
  3446				_returnToken = _token;
  3447			} finally { // debugging
  3448				fireExitRule(33, _ttype);
  3449			}
  3450		}
       
  3451		public final void mDEC(boolean _createToken) throws RecognitionException,
  3452				CharStreamException, TokenStreamException {
  3453			int _ttype;
  3454			Token _token = null;
  3455			int _begin = text.length();
  3456			_ttype = DEC;
  3457			int _saveIndex;
  3458	
       
  3459	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 23
       
       
  3460			fireEnterRule(34, _ttype);
  3461			try { // debugging
       
  3462				match("--");
  3463				{
  3464					{
  3465						match(_tokenSet_0);
  3466					}
  3467				}
  3468				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3469					_token = makeToken(_ttype);
  3470					_token.setText(new String(text.getBuffer(), _begin, text
  3471							.length()
  3472							- _begin));
  3473				}
  3474				_returnToken = _token;
  3475			} finally { // debugging
  3476				fireExitRule(34, _ttype);
  3477			}
  3478		}
       
  3479		public final void mSTAR_ASSIGN(boolean _createToken)
  3480				throws RecognitionException, CharStreamException,
  3481				TokenStreamException {
  3482			int _ttype;
  3483			Token _token = null;
  3484			int _begin = text.length();
  3485			_ttype = STAR_ASSIGN;
  3486			int _saveIndex;
  3487			fireEnterRule(35, _ttype);
  3488			try { // debugging
       
  3489				match("*=");
  3490				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3491					_token = makeToken(_ttype);
  3492					_token.setText(new String(text.getBuffer(), _begin, text
  3493							.length()
  3494							- _begin));
  3495				}
  3496				_returnToken = _token;
  3497			} finally { // debugging
  3498				fireExitRule(35, _ttype);
  3499			}
  3500		}
       
  3501		public final void mMOD_ASSIGN(boolean _createToken)
  3502				throws RecognitionException, CharStreamException,
  3503				TokenStreamException {
  3504			int _ttype;
  3505			Token _token = null;
  3506			int _begin = text.length();
  3507			_ttype = MOD_ASSIGN;
  3508			int _saveIndex;
  3509			fireEnterRule(36, _ttype);
  3510			try { // debugging
       
  3511	
       
  3512	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 24
       
       
  3513				match("%=");
  3514				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3515					_token = makeToken(_ttype);
  3516					_token.setText(new String(text.getBuffer(), _begin, text
  3517							.length()
  3518							- _begin));
  3519				}
  3520				_returnToken = _token;
  3521			} finally { // debugging
  3522				fireExitRule(36, _ttype);
  3523			}
  3524		}
       
  3525		public final void mSR(boolean _createToken) throws RecognitionException,
  3526				CharStreamException, TokenStreamException {
  3527			int _ttype;
  3528			Token _token = null;
  3529			int _begin = text.length();
  3530			_ttype = SR;
  3531			int _saveIndex;
  3532			fireEnterRule(37, _ttype);
  3533			try { // debugging
       
  3534				match(">>");
  3535				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3536					_token = makeToken(_ttype);
  3537					_token.setText(new String(text.getBuffer(), _begin, text
  3538							.length()
  3539							- _begin));
  3540				}
  3541				_returnToken = _token;
  3542			} finally { // debugging
  3543				fireExitRule(37, _ttype);
  3544			}
  3545		}
       
  3546		public final void mSR_ASSIGN(boolean _createToken)
  3547				throws RecognitionException, CharStreamException,
  3548				TokenStreamException {
  3549			int _ttype;
  3550			Token _token = null;
  3551			int _begin = text.length();
  3552			_ttype = SR_ASSIGN;
  3553			int _saveIndex;
  3554			fireEnterRule(38, _ttype);
  3555			try { // debugging
       
  3556				match(">>=");
  3557				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3558					_token = makeToken(_ttype);
  3559					_token.setText(new String(text.getBuffer(), _begin, text
  3560							.length()
  3561							- _begin));
  3562				}
  3563				_returnToken = _token;
  3564			} finally { // debugging
  3565	
       
  3566	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 25
       
       
  3567				fireExitRule(38, _ttype);
  3568			}
  3569		}
       
  3570		public final void mSL(boolean _createToken) throws RecognitionException,
  3571				CharStreamException, TokenStreamException {
  3572			int _ttype;
  3573			Token _token = null;
  3574			int _begin = text.length();
  3575			_ttype = SL;
  3576			int _saveIndex;
  3577			fireEnterRule(39, _ttype);
  3578			try { // debugging
       
  3579				match("<<");
  3580				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3581					_token = makeToken(_ttype);
  3582					_token.setText(new String(text.getBuffer(), _begin, text
  3583							.length()
  3584							- _begin));
  3585				}
  3586				_returnToken = _token;
  3587			} finally { // debugging
  3588				fireExitRule(39, _ttype);
  3589			}
  3590		}
       
  3591		public final void mSL_ASSIGN(boolean _createToken)
  3592				throws RecognitionException, CharStreamException,
  3593				TokenStreamException {
  3594			int _ttype;
  3595			Token _token = null;
  3596			int _begin = text.length();
  3597			_ttype = SL_ASSIGN;
  3598			int _saveIndex;
  3599			fireEnterRule(40, _ttype);
  3600			try { // debugging
       
  3601				match("<<=");
  3602				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3603					_token = makeToken(_ttype);
  3604					_token.setText(new String(text.getBuffer(), _begin, text
  3605							.length()
  3606							- _begin));
  3607				}
  3608				_returnToken = _token;
  3609			} finally { // debugging
  3610				fireExitRule(40, _ttype);
  3611			}
  3612		}
       
  3613		public final void mBXOR(boolean _createToken) throws RecognitionException,
  3614				CharStreamException, TokenStreamException {
  3615			int _ttype;
  3616			Token _token = null;
  3617			int _begin = text.length();
  3618	
       
  3619	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 26
       
       
  3620			_ttype = BXOR;
  3621			int _saveIndex;
  3622			fireEnterRule(41, _ttype);
  3623			try { // debugging
       
  3624				match('^');
  3625				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3626					_token = makeToken(_ttype);
  3627					_token.setText(new String(text.getBuffer(), _begin, text
  3628							.length()
  3629							- _begin));
  3630				}
  3631				_returnToken = _token;
  3632			} finally { // debugging
  3633				fireExitRule(41, _ttype);
  3634			}
  3635		}
       
  3636		public final void mBXOR_ASSIGN(boolean _createToken)
  3637				throws RecognitionException, CharStreamException,
  3638				TokenStreamException {
  3639			int _ttype;
  3640			Token _token = null;
  3641			int _begin = text.length();
  3642			_ttype = BXOR_ASSIGN;
  3643			int _saveIndex;
  3644			fireEnterRule(42, _ttype);
  3645			try { // debugging
       
  3646				match("^=");
  3647				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3648					_token = makeToken(_ttype);
  3649					_token.setText(new String(text.getBuffer(), _begin, text
  3650							.length()
  3651							- _begin));
  3652				}
  3653				_returnToken = _token;
  3654			} finally { // debugging
  3655				fireExitRule(42, _ttype);
  3656			}
  3657		}
       
  3658		public final void mBOR(boolean _createToken) throws RecognitionException,
  3659				CharStreamException, TokenStreamException {
  3660			int _ttype;
  3661			Token _token = null;
  3662			int _begin = text.length();
  3663			_ttype = BOR;
  3664			int _saveIndex;
  3665			fireEnterRule(43, _ttype);
  3666			try { // debugging
       
  3667				match('|');
  3668				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3669					_token = makeToken(_ttype);
  3670					_token.setText(new String(text.getBuffer(), _begin, text
  3671	
       
  3672	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 27
       
       
  3673							.length()
  3674							- _begin));
  3675				}
  3676				_returnToken = _token;
  3677			} finally { // debugging
  3678				fireExitRule(43, _ttype);
  3679			}
  3680		}
       
  3681		public final void mBOR_ASSIGN(boolean _createToken)
  3682				throws RecognitionException, CharStreamException,
  3683				TokenStreamException {
  3684			int _ttype;
  3685			Token _token = null;
  3686			int _begin = text.length();
  3687			_ttype = BOR_ASSIGN;
  3688			int _saveIndex;
  3689			fireEnterRule(44, _ttype);
  3690			try { // debugging
       
  3691				match("|=");
  3692				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3693					_token = makeToken(_ttype);
  3694					_token.setText(new String(text.getBuffer(), _begin, text
  3695							.length()
  3696							- _begin));
  3697				}
  3698				_returnToken = _token;
  3699			} finally { // debugging
  3700				fireExitRule(44, _ttype);
  3701			}
  3702		}
       
  3703		public final void mBAND(boolean _createToken) throws RecognitionException,
  3704				CharStreamException, TokenStreamException {
  3705			int _ttype;
  3706			Token _token = null;
  3707			int _begin = text.length();
  3708			_ttype = BAND;
  3709			int _saveIndex;
  3710			fireEnterRule(45, _ttype);
  3711			try { // debugging
       
  3712				match('&');
  3713				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3714					_token = makeToken(_ttype);
  3715					_token.setText(new String(text.getBuffer(), _begin, text
  3716							.length()
  3717							- _begin));
  3718				}
  3719				_returnToken = _token;
  3720			} finally { // debugging
  3721				fireExitRule(45, _ttype);
  3722			}
  3723		}
       
  3724	
       
  3725	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 28
       
       
  3726		public final void mBAND_ASSIGN(boolean _createToken)
  3727				throws RecognitionException, CharStreamException,
  3728				TokenStreamException {
  3729			int _ttype;
  3730			Token _token = null;
  3731			int _begin = text.length();
  3732			_ttype = BAND_ASSIGN;
  3733			int _saveIndex;
  3734			fireEnterRule(46, _ttype);
  3735			try { // debugging
       
  3736				match("&=");
  3737				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3738					_token = makeToken(_ttype);
  3739					_token.setText(new String(text.getBuffer(), _begin, text
  3740							.length()
  3741							- _begin));
  3742				}
  3743				_returnToken = _token;
  3744			} finally { // debugging
  3745				fireExitRule(46, _ttype);
  3746			}
  3747		}
       
  3748		public final void mSL_COMMENT(boolean _createToken)
  3749				throws RecognitionException, CharStreamException,
  3750				TokenStreamException {
  3751			int _ttype;
  3752			Token _token = null;
  3753			int _begin = text.length();
  3754			_ttype = SL_COMMENT;
  3755			int _saveIndex;
  3756			fireEnterRule(47, _ttype);
  3757			try { // debugging
       
  3758				{
  3759					switch (LA(1)) {
  3760					case '/': {
  3761						match("//");
  3762						break;
  3763					}
  3764					case '#': {
  3765						match("#");
  3766						break;
  3767					}
  3768					case '-': {
  3769						match("--");
  3770						{
  3771							switch (LA(1)) {
  3772							case ' ': {
  3773								match(' ');
  3774								break;
  3775							}
  3776							case '\t': {
  3777								match('\t');
  3778								break;
  3779	
       
  3780	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 29
       
       
  3781							}
  3782							case '*': {
  3783								match('*');
  3784								break;
  3785							}
  3786							default: {
  3787								throw new NoViableAltForCharException((char) LA(1),
  3788										getFilename(), getLine());
  3789							}
  3790							}
  3791						}
  3792						break;
  3793					}
  3794					default: {
  3795						throw new NoViableAltForCharException((char) LA(1),
  3796								getFilename(), getLine());
  3797					}
  3798					}
  3799				}
  3800				{
  3801					_loop240: do {
  3802						if ((_tokenSet_2.member(LA(1)))) {
  3803							{
  3804								match(_tokenSet_2);
  3805							}
  3806						} else {
  3807							break _loop240;
  3808						}
       
  3809					} while (true);
  3810				}
  3811				{
  3812					switch (LA(1)) {
  3813					case '\n': {
  3814						match('\n');
  3815						break;
  3816					}
  3817					case '\r': {
  3818						match('\r');
  3819						{
  3820							if ((LA(1) == '\n')) {
  3821								match('\n');
  3822							} else {
  3823							}
       
  3824						}
  3825						break;
  3826					}
  3827					default: {
  3828						throw new NoViableAltForCharException((char) LA(1),
  3829								getFilename(), getLine());
  3830					}
  3831					}
  3832				}
  3833				_ttype = Token.SKIP;
  3834				newline();
  3835	
       
  3836	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 30
       
       
  3837				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3838					_token = makeToken(_ttype);
  3839					_token.setText(new String(text.getBuffer(), _begin, text
  3840							.length()
  3841							- _begin));
  3842				}
  3843				_returnToken = _token;
  3844			} finally { // debugging
  3845				fireExitRule(47, _ttype);
  3846			}
  3847		}
       
  3848		public final void mML_COMMENT(boolean _createToken)
  3849				throws RecognitionException, CharStreamException,
  3850				TokenStreamException {
  3851			int _ttype;
  3852			Token _token = null;
  3853			int _begin = text.length();
  3854			_ttype = ML_COMMENT;
  3855			int _saveIndex;
  3856			fireEnterRule(48, _ttype);
  3857			try { // debugging
       
  3858				match("/*");
  3859				{
  3860					_loop246: do {
  3861						if ((LA(1) == '\r') && (LA(2) == '\n')
  3862								&& ((LA(3) >= '\u0003' && LA(3) <= '\u00ff'))
  3863								&& ((LA(4) >= '\u0003' && LA(4) <= '\u00ff'))) {
  3864							match('\r');
  3865							match('\n');
  3866							newline();
  3867						} else if (((LA(1) == '*')
  3868								&& ((LA(2) >= '\u0003' && LA(2) <= '\u00ff')) && ((LA(3) >= '\u0003' && LA(3) <= '\u00ff')))
  3869								&& fireSemanticPredicateEvaluated(
  3870										antlr.debug.SemanticPredicateEvent.PREDICTING,
  3871										0, LA(2) != '/')) {
  3872							match('*');
  3873						} else if ((LA(1) == '\r')
  3874								&& ((LA(2) >= '\u0003' && LA(2) <= '\u00ff'))
  3875								&& ((LA(3) >= '\u0003' && LA(3) <= '\u00ff'))
  3876								&& (true)) {
  3877							match('\r');
  3878							newline();
  3879						} else if ((LA(1) == '\n')) {
  3880							match('\n');
  3881							newline();
  3882						} else if ((_tokenSet_3.member(LA(1)))) {
  3883							{
  3884								match(_tokenSet_3);
  3885							}
  3886						} else {
  3887							break _loop246;
  3888						}
       
  3889					} while (true);
  3890	
       
  3891	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 31
       
       
  3892				}
  3893				match("*/");
  3894				_ttype = Token.SKIP;
  3895				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3896					_token = makeToken(_ttype);
  3897					_token.setText(new String(text.getBuffer(), _begin, text
  3898							.length()
  3899							- _begin));
  3900				}
  3901				_returnToken = _token;
  3902			} finally { // debugging
  3903				fireExitRule(48, _ttype);
  3904			}
  3905		}
       
  3906		public final void mCHAR_LITERAL(boolean _createToken)
  3907				throws RecognitionException, CharStreamException,
  3908				TokenStreamException {
  3909			int _ttype;
  3910			Token _token = null;
  3911			int _begin = text.length();
  3912			_ttype = CHAR_LITERAL;
  3913			int _saveIndex;
  3914			fireEnterRule(49, _ttype);
  3915			try { // debugging
       
  3916				match('\'');
  3917				{
  3918					if ((LA(1) == '\\')) {
  3919						mESC(false);
  3920					} else if ((_tokenSet_4.member(LA(1)))) {
  3921						matchNot('\'');
  3922					} else {
  3923						throw new NoViableAltForCharException((char) LA(1),
  3924								getFilename(), getLine());
  3925					}
       
  3926				}
  3927				match('\'');
  3928				if (_createToken && _token == null && _ttype != Token.SKIP) {
  3929					_token = makeToken(_ttype);
  3930					_token.setText(new String(text.getBuffer(), _begin, text
  3931							.length()
  3932							- _begin));
  3933				}
  3934				_returnToken = _token;
  3935			} finally { // debugging
  3936				fireExitRule(49, _ttype);
  3937			}
  3938		}
       
  3939		protected final void mESC(boolean _createToken)
  3940				throws RecognitionException, CharStreamException,
  3941				TokenStreamException {
  3942			int _ttype;
  3943			Token _token = null;
  3944	
       
  3945	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 32
       
       
  3946			int _begin = text.length();
  3947			_ttype = ESC;
  3948			int _saveIndex;
  3949			fireEnterRule(50, _ttype);
  3950			try { // debugging
       
  3951				match('\\');
  3952				{
  3953					switch (LA(1)) {
  3954					case 'n': {
  3955						match('n');
  3956						break;
  3957					}
  3958					case 'r': {
  3959						match('r');
  3960						break;
  3961					}
  3962					case 't': {
  3963						match('t');
  3964						break;
  3965					}
  3966					case 'b': {
  3967						match('b');
  3968						break;
  3969					}
  3970					case 'f': {
  3971						match('f');
  3972						break;
  3973					}
  3974					case '"': {
  3975						match('"');
  3976						break;
  3977					}
  3978					case '\'': {
  3979						match('\'');
  3980						break;
  3981					}
  3982					case '\\': {
  3983						match('\\');
  3984						break;
  3985					}
  3986					case 'u': {
  3987						{
  3988							int _cnt257 = 0;
  3989							_loop257: do {
  3990								if ((LA(1) == 'u')) {
  3991									match('u');
  3992								} else {
  3993									if (_cnt257 >= 1) {
  3994										break _loop257;
  3995									} else {
  3996										throw new NoViableAltForCharException(
  3997												(char) LA(1), getFilename(),
  3998												getLine());
  3999									}
  4000								}
  4001	
       
  4002	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 33
       
       
       
  4003								_cnt257++;
  4004							} while (true);
  4005						}
  4006						mHEX_DIGIT(false);
  4007						mHEX_DIGIT(false);
  4008						mHEX_DIGIT(false);
  4009						mHEX_DIGIT(false);
  4010						break;
  4011					}
  4012					case '0':
  4013					case '1':
  4014					case '2':
  4015					case '3': {
  4016						{
  4017							matchRange('0', '3');
  4018						}
  4019						{
  4020							if (((LA(1) >= '0' && LA(1) <= '7'))
  4021									&& ((LA(2) >= '\u0003' && LA(2) <= '\u00ff'))
  4022									&& (true) && (true)) {
  4023								{
  4024									matchRange('0', '7');
  4025								}
  4026								{
  4027									if (((LA(1) >= '0' && LA(1) <= '7'))
  4028											&& ((LA(2) >= '\u0003' && LA(2) <= '\u00ff'))
  4029											&& (true) && (true)) {
  4030										matchRange('0', '7');
  4031									} else if (((LA(1) >= '\u0003' && LA(1) <= '\u00ff')) && (true) && (true) && (true)) {
  4032									} else {
  4033										throw new NoViableAltForCharException(
  4034												(char) LA(1), getFilename(),
  4035												getLine());
  4036									}
       
  4037								}
  4038							} else if (((LA(1) >= '\u0003' && LA(1) <= '\u00ff')) && (true) && (true) && (true)) {
  4039							} else {
  4040								throw new NoViableAltForCharException((char) LA(1),
  4041										getFilename(), getLine());
  4042							}
       
  4043						}
  4044						break;
  4045					}
  4046					case '4':
  4047					case '5':
  4048					case '6':
  4049					case '7': {
  4050						{
  4051							matchRange('4', '7');
  4052						}
  4053						{
  4054							if (((LA(1) >= '0' && LA(1) <= '9'))
  4055									&& ((LA(2) >= '\u0003' && LA(2) <= '\u00ff'))
  4056	
       
  4057	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 34
       
       
  4058									&& (true) && (true)) {
  4059								{
  4060									matchRange('0', '9');
  4061								}
  4062							} else if (((LA(1) >= '\u0003' && LA(1) <= '\u00ff')) && (true) && (true) && (true)) {
  4063							} else {
  4064								throw new NoViableAltForCharException((char) LA(1),
  4065										getFilename(), getLine());
  4066							}
       
  4067						}
  4068						break;
  4069					}
  4070					default: {
  4071						throw new NoViableAltForCharException((char) LA(1),
  4072								getFilename(), getLine());
  4073					}
  4074					}
  4075				}
  4076				if (_createToken && _token == null && _ttype != Token.SKIP) {
  4077					_token = makeToken(_ttype);
  4078					_token.setText(new String(text.getBuffer(), _begin, text
  4079							.length()
  4080							- _begin));
  4081				}
  4082				_returnToken = _token;
  4083			} finally { // debugging
  4084				fireExitRule(50, _ttype);
  4085			}
  4086		}
       
  4087		protected final void mTQUOT(boolean _createToken)
  4088				throws RecognitionException, CharStreamException,
  4089				TokenStreamException {
  4090			int _ttype;
  4091			Token _token = null;
  4092			int _begin = text.length();
  4093			_ttype = TQUOT;
  4094			int _saveIndex;
  4095			fireEnterRule(51, _ttype);
  4096			try { // debugging
       
  4097				match("\"\"\"");
  4098				if (_createToken && _token == null && _ttype != Token.SKIP) {
  4099					_token = makeToken(_ttype);
  4100					_token.setText(new String(text.getBuffer(), _begin, text
  4101							.length()
  4102							- _begin));
  4103				}
  4104				_returnToken = _token;
  4105			} finally { // debugging
  4106				fireExitRule(51, _ttype);
  4107			}
  4108		}
       
  4109		public final void mSTRING_LITERAL(boolean _createToken)
  4110	
       
  4111	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 35
       
       
  4112				throws RecognitionException, CharStreamException,
  4113				TokenStreamException {
  4114			int _ttype;
  4115			Token _token = null;
  4116			int _begin = text.length();
  4117			_ttype = STRING_LITERAL;
  4118			int _saveIndex;
  4119			fireEnterRule(52, _ttype);
  4120			try { // debugging
       
  4121				match('"');
  4122				{
  4123					_loop253: do {
  4124						if ((LA(1) == '\\')) {
  4125							mESC(false);
  4126						} else if ((_tokenSet_5.member(LA(1)))) {
  4127							{
  4128								match(_tokenSet_5);
  4129							}
  4130						} else {
  4131							break _loop253;
  4132						}
       
  4133					} while (true);
  4134				}
  4135				match('"');
  4136				if (_createToken && _token == null && _ttype != Token.SKIP) {
  4137					_token = makeToken(_ttype);
  4138					_token.setText(new String(text.getBuffer(), _begin, text
  4139							.length()
  4140							- _begin));
  4141				}
  4142				_returnToken = _token;
  4143			} finally { // debugging
  4144				fireExitRule(52, _ttype);
  4145			}
  4146		}
       
  4147		protected final void mHEX_DIGIT(boolean _createToken)
  4148				throws RecognitionException, CharStreamException,
  4149				TokenStreamException {
  4150			int _ttype;
  4151			Token _token = null;
  4152			int _begin = text.length();
  4153			_ttype = HEX_DIGIT;
  4154			int _saveIndex;
  4155			fireEnterRule(53, _ttype);
  4156			try { // debugging
       
  4157				{
  4158					switch (LA(1)) {
  4159					case '0':
  4160					case '1':
  4161					case '2':
  4162					case '3':
  4163					case '4':
  4164	
       
  4165	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 36
       
       
  4166					case '5':
  4167					case '6':
  4168					case '7':
  4169					case '8':
  4170					case '9': {
  4171						matchRange('0', '9');
  4172						break;
  4173					}
  4174					case 'A':
  4175					case 'B':
  4176					case 'C':
  4177					case 'D':
  4178					case 'E':
  4179					case 'F': {
  4180						matchRange('A', 'F');
  4181						break;
  4182					}
  4183					case 'a':
  4184					case 'b':
  4185					case 'c':
  4186					case 'd':
  4187					case 'e':
  4188					case 'f': {
  4189						matchRange('a', 'f');
  4190						break;
  4191					}
  4192					default: {
  4193						throw new NoViableAltForCharException((char) LA(1),
  4194								getFilename(), getLine());
  4195					}
  4196					}
  4197				}
  4198				if (_createToken && _token == null && _ttype != Token.SKIP) {
  4199					_token = makeToken(_ttype);
  4200					_token.setText(new String(text.getBuffer(), _begin, text
  4201							.length()
  4202							- _begin));
  4203				}
  4204				_returnToken = _token;
  4205			} finally { // debugging
  4206				fireExitRule(53, _ttype);
  4207			}
  4208		}
       
  4209		public final void mIDENT(boolean _createToken) throws RecognitionException,
  4210				CharStreamException, TokenStreamException {
  4211			int _ttype;
  4212			Token _token = null;
  4213			int _begin = text.length();
  4214			_ttype = IDENT;
  4215			int _saveIndex;
  4216			fireEnterRule(54, _ttype);
  4217			try { // debugging
       
  4218				{
  4219					switch (LA(1)) {
  4220	
       
  4221	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 37
       
       
  4222					case 'a':
  4223					case 'b':
  4224					case 'c':
  4225					case 'd':
  4226					case 'e':
  4227					case 'f':
  4228					case 'g':
  4229					case 'h':
  4230					case 'i':
  4231					case 'j':
  4232					case 'k':
  4233					case 'l':
  4234					case 'm':
  4235					case 'n':
  4236					case 'o':
  4237					case 'p':
  4238					case 'q':
  4239					case 'r':
  4240					case 's':
  4241					case 't':
  4242					case 'u':
  4243					case 'v':
  4244					case 'w':
  4245					case 'x':
  4246					case 'y':
  4247					case 'z': {
  4248						matchRange('a', 'z');
  4249						break;
  4250					}
  4251					case 'A':
  4252					case 'B':
  4253					case 'C':
  4254					case 'D':
  4255					case 'E':
  4256					case 'F':
  4257					case 'G':
  4258					case 'H':
  4259					case 'I':
  4260					case 'J':
  4261					case 'K':
  4262					case 'L':
  4263					case 'M':
  4264					case 'N':
  4265					case 'O':
  4266					case 'P':
  4267					case 'Q':
  4268					case 'R':
  4269					case 'S':
  4270					case 'T':
  4271					case 'U':
  4272					case 'V':
  4273					case 'W':
  4274					case 'X':
  4275					case 'Y':
  4276					case 'Z': {
  4277						matchRange('A', 'Z');
  4278	
       
  4279	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 38
       
       
  4280						break;
  4281					}
  4282					case '_': {
  4283						match('_');
  4284						break;
  4285					}
  4286					case '$': {
  4287						match('$');
  4288						break;
  4289					}
  4290					default: {
  4291						throw new NoViableAltForCharException((char) LA(1),
  4292								getFilename(), getLine());
  4293					}
  4294					}
  4295				}
  4296				{
  4297					_loop270: do {
  4298						switch (LA(1)) {
  4299						case 'a':
  4300						case 'b':
  4301						case 'c':
  4302						case 'd':
  4303						case 'e':
  4304						case 'f':
  4305						case 'g':
  4306						case 'h':
  4307						case 'i':
  4308						case 'j':
  4309						case 'k':
  4310						case 'l':
  4311						case 'm':
  4312						case 'n':
  4313						case 'o':
  4314						case 'p':
  4315						case 'q':
  4316						case 'r':
  4317						case 's':
  4318						case 't':
  4319						case 'u':
  4320						case 'v':
  4321						case 'w':
  4322						case 'x':
  4323						case 'y':
  4324						case 'z': {
  4325							matchRange('a', 'z');
  4326							break;
  4327						}
  4328						case 'A':
  4329						case 'B':
  4330						case 'C':
  4331						case 'D':
  4332						case 'E':
  4333						case 'F':
  4334						case 'G':
  4335						case 'H':
  4336	
       
  4337	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 39
       
       
  4338						case 'I':
  4339						case 'J':
  4340						case 'K':
  4341						case 'L':
  4342						case 'M':
  4343						case 'N':
  4344						case 'O':
  4345						case 'P':
  4346						case 'Q':
  4347						case 'R':
  4348						case 'S':
  4349						case 'T':
  4350						case 'U':
  4351						case 'V':
  4352						case 'W':
  4353						case 'X':
  4354						case 'Y':
  4355						case 'Z': {
  4356							matchRange('A', 'Z');
  4357							break;
  4358						}
  4359						case '_': {
  4360							match('_');
  4361							break;
  4362						}
  4363						case '0':
  4364						case '1':
  4365						case '2':
  4366						case '3':
  4367						case '4':
  4368						case '5':
  4369						case '6':
  4370						case '7':
  4371						case '8':
  4372						case '9': {
  4373							matchRange('0', '9');
  4374							break;
  4375						}
  4376						default: {
  4377							break _loop270;
  4378						}
  4379						}
  4380					} while (true);
  4381				}
  4382				_ttype = testLiteralsTable(_ttype);
  4383				if (_createToken && _token == null && _ttype != Token.SKIP) {
  4384					_token = makeToken(_ttype);
  4385					_token.setText(new String(text.getBuffer(), _begin, text
  4386							.length()
  4387							- _begin));
  4388				}
  4389				_returnToken = _token;
  4390			} finally { // debugging
  4391				fireExitRule(54, _ttype);
  4392			}
  4393		}
  4394	
       
  4395	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 40
       
       
       
  4396		public final void mQIDENT(boolean _createToken)
  4397				throws RecognitionException, CharStreamException,
  4398				TokenStreamException {
  4399			int _ttype;
  4400			Token _token = null;
  4401			int _begin = text.length();
  4402			_ttype = QIDENT;
  4403			int _saveIndex;
  4404			fireEnterRule(55, _ttype);
  4405			try { // debugging
       
  4406				match('`');
  4407				mIDENT(false);
  4408				if (_createToken && _token == null && _ttype != Token.SKIP) {
  4409					_token = makeToken(_ttype);
  4410					_token.setText(new String(text.getBuffer(), _begin, text
  4411							.length()
  4412							- _begin));
  4413				}
  4414				_returnToken = _token;
  4415			} finally { // debugging
  4416				fireExitRule(55, _ttype);
  4417			}
  4418		}
       
  4419		public final void mNUM_INT(boolean _createToken)
  4420				throws RecognitionException, CharStreamException,
  4421				TokenStreamException {
  4422			int _ttype;
  4423			Token _token = null;
  4424			int _begin = text.length();
  4425			_ttype = NUM_INT;
  4426			int _saveIndex;
  4427			fireEnterRule(56, _ttype);
  4428			try { // debugging
  4429				boolean isDecimal = false;
       
  4430				switch (LA(1)) {
  4431				case '.': {
  4432					match('.');
  4433					_ttype = DOT;
  4434					{
  4435						if (((LA(1) >= '0' && LA(1) <= '9'))) {
  4436							{
  4437								int _cnt275 = 0;
  4438								_loop275: do {
  4439									if (((LA(1) >= '0' && LA(1) <= '9'))) {
  4440										matchRange('0', '9');
  4441									} else {
  4442										if (_cnt275 >= 1) {
  4443											break _loop275;
  4444										} else {
  4445											throw new NoViableAltForCharException(
  4446													(char) LA(1), getFilename(),
  4447													getLine());
  4448	
       
  4449	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 41
       
       
  4450										}
  4451									}
       
  4452									_cnt275++;
  4453								} while (true);
  4454							}
  4455							{
  4456								if ((LA(1) == 'E' || LA(1) == 'e')) {
  4457									mEXPONENT(false);
  4458								} else {
  4459								}
       
  4460							}
  4461							{
  4462								if ((_tokenSet_6.member(LA(1)))) {
  4463									mFLOAT_SUFFIX(false);
  4464								} else {
  4465								}
       
  4466							}
  4467							_ttype = NUM_FLOAT;
  4468						} else {
  4469						}
       
  4470					}
  4471					break;
  4472				}
  4473				case '0':
  4474				case '1':
  4475				case '2':
  4476				case '3':
  4477				case '4':
  4478				case '5':
  4479				case '6':
  4480				case '7':
  4481				case '8':
  4482				case '9': {
  4483					{
  4484						switch (LA(1)) {
  4485						case '0': {
  4486							match('0');
  4487							isDecimal = true;
  4488							{
  4489								switch (LA(1)) {
  4490								case 'X':
  4491								case 'x': {
  4492									{
  4493										switch (LA(1)) {
  4494										case 'x': {
  4495											match('x');
  4496											break;
  4497										}
  4498										case 'X': {
  4499											match('X');
  4500											break;
  4501										}
  4502	
       
  4503	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 42
       
       
  4504										default: {
  4505											throw new NoViableAltForCharException(
  4506													(char) LA(1), getFilename(),
  4507													getLine());
  4508										}
  4509										}
  4510									}
  4511									{
  4512										int _cnt282 = 0;
  4513										_loop282: do {
  4514											if ((_tokenSet_7.member(LA(1))) && (true) && (true) && (true)) {
  4515												mHEX_DIGIT(false);
  4516											} else {
  4517												if (_cnt282 >= 1) {
  4518													break _loop282;
  4519												} else {
  4520													throw new NoViableAltForCharException(
  4521															(char) LA(1),
  4522															getFilename(),
  4523															getLine());
  4524												}
  4525											}
       
  4526											_cnt282++;
  4527										} while (true);
  4528									}
  4529									break;
  4530								}
  4531								case '0':
  4532								case '1':
  4533								case '2':
  4534								case '3':
  4535								case '4':
  4536								case '5':
  4537								case '6':
  4538								case '7': {
  4539									{
  4540										int _cnt284 = 0;
  4541										_loop284: do {
  4542											if (((LA(1) >= '0' && LA(1) <= '7'))) {
  4543												matchRange('0', '7');
  4544											} else {
  4545												if (_cnt284 >= 1) {
  4546													break _loop284;
  4547												} else {
  4548													throw new NoViableAltForCharException(
  4549															(char) LA(1),
  4550															getFilename(),
  4551															getLine());
  4552												}
  4553											}
       
  4554											_cnt284++;
  4555										} while (true);
  4556									}
  4557									break;
  4558	
       
  4559	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 43
       
       
  4560								}
  4561								default: {
  4562								}
  4563								}
  4564							}
  4565							break;
  4566						}
  4567						case '1':
  4568						case '2':
  4569						case '3':
  4570						case '4':
  4571						case '5':
  4572						case '6':
  4573						case '7':
  4574						case '8':
  4575						case '9': {
  4576							{
  4577								matchRange('1', '9');
  4578							}
  4579							{
  4580								_loop287: do {
  4581									if (((LA(1) >= '0' && LA(1) <= '9'))) {
  4582										matchRange('0', '9');
  4583									} else {
  4584										break _loop287;
  4585									}
       
  4586								} while (true);
  4587							}
  4588							isDecimal = true;
  4589							break;
  4590						}
  4591						default: {
  4592							throw new NoViableAltForCharException((char) LA(1),
  4593									getFilename(), getLine());
  4594						}
  4595						}
  4596					}
  4597					{
  4598						if ((LA(1) == 'L' || LA(1) == 'l')) {
  4599							{
  4600								switch (LA(1)) {
  4601								case 'l': {
  4602									match('l');
  4603									break;
  4604								}
  4605								case 'L': {
  4606									match('L');
  4607									break;
  4608								}
  4609								default: {
  4610									throw new NoViableAltForCharException(
  4611											(char) LA(1), getFilename(), getLine());
  4612								}
  4613								}
  4614							}
  4615	
       
  4616	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 44
       
       
  4617						} else if (((_tokenSet_8.member(LA(1))))
  4618								&& fireSemanticPredicateEvaluated(
  4619										antlr.debug.SemanticPredicateEvent.PREDICTING,
  4620										1, isDecimal)) {
  4621							{
  4622								switch (LA(1)) {
  4623								case '.': {
  4624									match('.');
  4625									{
  4626										_loop292: do {
  4627											if (((LA(1) >= '0' && LA(1) <= '9'))) {
  4628												matchRange('0', '9');
  4629											} else {
  4630												break _loop292;
  4631											}
       
  4632										} while (true);
  4633									}
  4634									{
  4635										if ((LA(1) == 'E' || LA(1) == 'e')) {
  4636											mEXPONENT(false);
  4637										} else {
  4638										}
       
  4639									}
  4640									{
  4641										if ((_tokenSet_6.member(LA(1)))) {
  4642											mFLOAT_SUFFIX(false);
  4643										} else {
  4644										}
       
  4645									}
  4646									break;
  4647								}
  4648								case 'E':
  4649								case 'e': {
  4650									mEXPONENT(false);
  4651									{
  4652										if ((_tokenSet_6.member(LA(1)))) {
  4653											mFLOAT_SUFFIX(false);
  4654										} else {
  4655										}
       
  4656									}
  4657									break;
  4658								}
  4659								case 'D':
  4660								case 'F':
  4661								case 'd':
  4662								case 'f': {
  4663									mFLOAT_SUFFIX(false);
  4664									break;
  4665								}
  4666								default: {
  4667									throw new NoViableAltForCharException(
  4668											(char) LA(1), getFilename(), getLine());
  4669	
       
  4670	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 45
       
       
  4671								}
  4672								}
  4673							}
  4674							_ttype = NUM_FLOAT;
  4675						} else {
  4676						}
       
  4677					}
  4678					break;
  4679				}
  4680				default: {
  4681					throw new NoViableAltForCharException((char) LA(1),
  4682							getFilename(), getLine());
  4683				}
  4684				}
  4685				if (_createToken && _token == null && _ttype != Token.SKIP) {
  4686					_token = makeToken(_ttype);
  4687					_token.setText(new String(text.getBuffer(), _begin, text
  4688							.length()
  4689							- _begin));
  4690				}
  4691				_returnToken = _token;
  4692			} finally { // debugging
  4693				fireExitRule(56, _ttype);
  4694			}
  4695		}
       
  4696		protected final void mEXPONENT(boolean _createToken)
  4697				throws RecognitionException, CharStreamException,
  4698				TokenStreamException {
  4699			int _ttype;
  4700			Token _token = null;
  4701			int _begin = text.length();
  4702			_ttype = EXPONENT;
  4703			int _saveIndex;
  4704			fireEnterRule(57, _ttype);
  4705			try { // debugging
       
  4706				{
  4707					switch (LA(1)) {
  4708					case 'e': {
  4709						match('e');
  4710						break;
  4711					}
  4712					case 'E': {
  4713						match('E');
  4714						break;
  4715					}
  4716					default: {
  4717						throw new NoViableAltForCharException((char) LA(1),
  4718								getFilename(), getLine());
  4719					}
  4720					}
  4721				}
  4722				{
  4723					switch (LA(1)) {
  4724	
       
  4725	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 46
       
       
  4726					case '+': {
  4727						match('+');
  4728						break;
  4729					}
  4730					case '-': {
  4731						match('-');
  4732						break;
  4733					}
  4734					case '0':
  4735					case '1':
  4736					case '2':
  4737					case '3':
  4738					case '4':
  4739					case '5':
  4740					case '6':
  4741					case '7':
  4742					case '8':
  4743					case '9': {
  4744						break;
  4745					}
  4746					default: {
  4747						throw new NoViableAltForCharException((char) LA(1),
  4748								getFilename(), getLine());
  4749					}
  4750					}
  4751				}
  4752				{
  4753					int _cnt300 = 0;
  4754					_loop300: do {
  4755						if (((LA(1) >= '0' && LA(1) <= '9'))) {
  4756							matchRange('0', '9');
  4757						} else {
  4758							if (_cnt300 >= 1) {
  4759								break _loop300;
  4760							} else {
  4761								throw new NoViableAltForCharException((char) LA(1),
  4762										getFilename(), getLine());
  4763							}
  4764						}
       
  4765						_cnt300++;
  4766					} while (true);
  4767				}
  4768				if (_createToken && _token == null && _ttype != Token.SKIP) {
  4769					_token = makeToken(_ttype);
  4770					_token.setText(new String(text.getBuffer(), _begin, text
  4771							.length()
  4772							- _begin));
  4773				}
  4774				_returnToken = _token;
  4775			} finally { // debugging
  4776				fireExitRule(57, _ttype);
  4777			}
  4778		}
       
  4779		protected final void mFLOAT_SUFFIX(boolean _createToken)
  4780	
       
  4781	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 47
       
       
  4782				throws RecognitionException, CharStreamException,
  4783				TokenStreamException {
  4784			int _ttype;
  4785			Token _token = null;
  4786			int _begin = text.length();
  4787			_ttype = FLOAT_SUFFIX;
  4788			int _saveIndex;
  4789			fireEnterRule(58, _ttype);
  4790			try { // debugging
       
  4791				switch (LA(1)) {
  4792				case 'f': {
  4793					match('f');
  4794					break;
  4795				}
  4796				case 'F': {
  4797					match('F');
  4798					break;
  4799				}
  4800				case 'd': {
  4801					match('d');
  4802					break;
  4803				}
  4804				case 'D': {
  4805					match('D');
  4806					break;
  4807				}
  4808				default: {
  4809					throw new NoViableAltForCharException((char) LA(1),
  4810							getFilename(), getLine());
  4811				}
  4812				}
  4813				if (_createToken && _token == null && _ttype != Token.SKIP) {
  4814					_token = makeToken(_ttype);
  4815					_token.setText(new String(text.getBuffer(), _begin, text
  4816							.length()
  4817							- _begin));
  4818				}
  4819				_returnToken = _token;
  4820			} finally { // debugging
  4821				fireExitRule(58, _ttype);
  4822			}
  4823		}
       
  4824		private String _semPredNames[] = { " LA(2)!='/' ", "isDecimal", };
       
  4825		private static final long _tokenSet_0_data_[] = { -4402341478920L, -1L,
  4826				-1L, -1L, 0L, 0L, 0L, 0L };
       
  4827		public static final BitSet _tokenSet_0 = new BitSet(_tokenSet_0_data_);
       
  4828		private static final long _tokenSet_1_data_[] = { 288019269919178752L, 0L,
  4829				0L, 0L, 0L };
       
  4830		public static final BitSet _tokenSet_1 = new BitSet(_tokenSet_1_data_);
       
  4831	
       
  4832	2019-01-11 06:34         tripleo/elijah/ElijahLexer.java         Page 48
       
       
  4833		private static final long _tokenSet_2_data_[] = { -9224L, -1L, -1L, -1L,
  4834				0L, 0L, 0L, 0L };
       
  4835		public static final BitSet _tokenSet_2 = new BitSet(_tokenSet_2_data_);
       
  4836		private static final long _tokenSet_3_data_[] = { -4398046520328L, -1L,
  4837				-1L, -1L, 0L, 0L, 0L, 0L };
       
  4838		public static final BitSet _tokenSet_3 = new BitSet(_tokenSet_3_data_);
       
  4839		private static final long _tokenSet_4_data_[] = { -549755813896L,
  4840				-268435457L, -1L, -1L, 0L, 0L, 0L, 0L };
       
  4841		public static final BitSet _tokenSet_4 = new BitSet(_tokenSet_4_data_);
       
  4842		private static final long _tokenSet_5_data_[] = { -17179869192L,
  4843				-268435457L, -1L, -1L, 0L, 0L, 0L, 0L };
       
  4844		public static final BitSet _tokenSet_5 = new BitSet(_tokenSet_5_data_);
       
  4845		private static final long _tokenSet_6_data_[] = { 0L, 343597383760L, 0L,
  4846				0L, 0L };
       
  4847		public static final BitSet _tokenSet_6 = new BitSet(_tokenSet_6_data_);
       
  4848		private static final long _tokenSet_7_data_[] = { 287948901175001088L,
  4849				541165879422L, 0L, 0L, 0L };
       
  4850		public static final BitSet _tokenSet_7 = new BitSet(_tokenSet_7_data_);
       
  4851		private static final long _tokenSet_8_data_[] = { 70368744177664L,
  4852				481036337264L, 0L, 0L, 0L };
       
  4853		public static final BitSet _tokenSet_8 = new BitSet(_tokenSet_8_data_);
       
  4854	}
  4855	
       
  4856	2019-01-11 06:34             tripleo/elijah/App.java              Page 1
       
       
  4857	package tripleo.elijah;
       
       
  4858	/**
  4859	 * Hello world!
  4860	 *
  4861	 * @author <a href="jason@zenplex.com">Jason van Zyl</a>
  4862	 *
  4863	 */
  4864	public class App  
  4865	{
       
  4866		public static void main(String args[]) {
  4867			Main.main(args);
  4868		}
       
  4869	} 
  4870	
       
  4871	2019-01-11 06:34       tripleo/elijah/ElijahTokenTypes.java       Page 1
       
       
  4872	package tripleo.elijah;
  4873	 
  4874	// $ANTLR 2.7.1: "osc.g" -> "OScriptLexer.java"$
       
       
  4875	public interface ElijahTokenTypes {
  4876		int EOF = 1;
  4877		int NULL_TREE_LOOKAHEAD = 3;
  4878		int PROCEDURE_CALL = 4;
  4879		int EXPR_LIST = 5;
  4880		int NUM_FLOAT = 6;
  4881		int LITERAL_indexing = 7;
  4882		int IDENT = 8;
  4883		int TOK_COLON = 9;
  4884		int LITERAL_package = 10;
  4885		int SEMI = 11;
  4886		int LITERAL_namespace = 12;
  4887		int LPAREN = 13;
  4888		int RPAREN = 14;
  4889		int LITERAL_imports = 15;
  4890		int LITERAL_class = 16;
  4891		int LCURLY = 17;
  4892		int RCURLY = 18;
  4893		int COMMA = 19;
  4894		int STRING_LITERAL = 20;
  4895		int LITERAL_constructor = 21;
  4896		int LITERAL_ctor = 22;
  4897		int LITERAL_destructor = 23;
  4898		int LITERAL_dtor = 24;
  4899		int LITERAL_from = 25;
  4900		int LITERAL_import = 26;
  4901		int LITERAL_construct = 27;
  4902		int LITERAL_yield = 28;
  4903		int LITERAL_while = 29;
  4904		int LITERAL_do = 30;
  4905		int LITERAL_iterate = 31;
  4906		int LITERAL_to = 32;
  4907		int LITERAL_with = 33;
  4908		int LITERAL_var = 34;
  4909		int LITERAL_const = 35;
  4910		int BECOMES = 36;
  4911		int LITERAL_if = 37;
  4912		int LITERAL_else = 38;
  4913		int LITERAL_elseif = 39;
  4914		int LITERAL_typeof = 40;
  4915		int LITERAL_once = 41;
  4916		int LITERAL_local = 42;
  4917		int LITERAL_tagged = 43;
  4918		int LITERAL_pooled = 44;
  4919		int LITERAL_manual = 45;
  4920		int LITERAL_gc = 46;
  4921		int LITERAL_ref = 47;
  4922		int LITERAL_in = 48;
  4923		int LITERAL_out = 49;
  4924		int LITERAL_generic = 50;
  4925		int LBRACK = 51;
  4926	
       
  4927	2019-01-11 06:34       tripleo/elijah/ElijahTokenTypes.java       Page 2
       
       
  4928		int RBRACK = 52;
  4929		int LITERAL_function = 53;
  4930		int TOK_ARROW = 54;
  4931		int LITERAL_procedure = 55;
  4932		int DOT = 56;
  4933		int PLUS_ASSIGN = 57;
  4934		int MINUS_ASSIGN = 58;
  4935		int STAR_ASSIGN = 59;
  4936		int DIV_ASSIGN = 60;
  4937		int MOD_ASSIGN = 61;
  4938		int SR_ASSIGN = 62;
  4939		int BSR_ASSIGN = 63;
  4940		int SL_ASSIGN = 64;
  4941		int BAND_ASSIGN = 65;
  4942		int BXOR_ASSIGN = 66;
  4943		int BOR_ASSIGN = 67;
  4944		int QUESTION = 68;
  4945		int LOR = 69;
  4946		int LAND = 70;
  4947		int BOR = 71;
  4948		int BXOR = 72;
  4949		int BAND = 73;
  4950		int EQUALITY = 74;
  4951		int NOT_EQUALS = 75;
  4952		int LT_ = 76;
  4953		int GT = 77;
  4954		int LTE = 78;
  4955		int GTE = 79;
  4956		int LITERAL_is_a = 80;
  4957		int SL = 81;
  4958		int SR = 82;
  4959		int BSR = 83;
  4960		int PLUS = 84;
  4961		int MINUS = 85;
  4962		int STAR = 86;
  4963		int DIV = 87;
  4964		int MOD = 88;
  4965		int QIDENT = 89;
  4966		int INC = 90;
  4967		int DEC = 91;
  4968		int BNOT = 92;
  4969		int LNOT = 93;
  4970		int CHAR_LITERAL = 94;
  4971		int NUM_INT = 95;
  4972		int LITERAL_block = 96;
  4973		int LITERAL_closure = 97;
  4974		int LITERAL_type = 98;
  4975		int LITERAL_alias = 99;
  4976		int LITERAL_struct = 100;
  4977		int VOCAB = 101;
  4978		int WS_ = 102;
  4979		int TIMES = 103;
  4980		int SL_COMMENT = 104;
  4981		int ML_COMMENT = 105;
  4982		int TQUOT = 106;
  4983		int ESC = 107;
  4984	
       
  4985	2019-01-11 06:34       tripleo/elijah/ElijahTokenTypes.java       Page 3
       
       
  4986		int HEX_DIGIT = 108;
  4987		int EXPONENT = 109;
  4988		int FLOAT_SUFFIX = 110;
  4989	}
  4990	
       
  4991	2019-01-11 06:34         tripleo/elijah/ElijahParser.java         Page 1
       
       
  4992	package tripleo.elijah;
  4993	 
  4994	// $ANTLR 2.7.1: "osc.g" -> "OScriptParser.java"$
       
  4995	import tripleo.elijah.lang.*;
       
  4996	import antlr.*;
  4997	import antlr.collections.impl.BitSet;
       
  4998	public class ElijahParser extends antlr.debug.LLkDebuggingParser
  4999	       implements ElijahTokenTypes
  5000	 {
  5001	private static final String _ruleNames[] = {
  5002	  "program",
  5003	  "constantValue",
  5004	  "qualident",
  5005	  "programStatement",
  5006	  "classStatement",
  5007	  "importStatement",
  5008	  "classInheritance",
  5009	  "docstrings",
  5010	  "classScope",
  5011	  "typeName",
  5012	  "scope",
  5013	  "functionDef",
  5014	  "varStmt",
  5015	  "typeAlias",
  5016	  "opfal",
  5017	  "baseStatement",
  5018	  "statement",
  5019	  "identList",
  5020	  "expression",
  5021	  "functionScope",
  5022	  "functionStatement",
  5023	  "block",
  5024	  "formalArgList",
  5025	  "procedureCallExpression",
  5026	  "ifConditional",
  5027	  "whileLoop",
  5028	  "frobeIteration",
  5029	  "procCallEx",
  5030	  "varStmt_i",
  5031	  "elseif_part",
  5032	  "structTypeName",
  5033	  "genericQualifiers",
  5034	  "abstractGenericTypeName_xx",
  5035	  "specifiedGenericTypeName_xx",
  5036	  "formalArgTypeName",
  5037	  "funcTypeExpr",
  5038	  "simpleTypeName_xx",
  5039	  "variableQualifiers",
  5040	  "regularQualifiers",
  5041	  "typeNameList",
  5042	  "ident2",
  5043	  "qualidentList",
  5044	  "formalArgListItem_priv",
  5045	
       
  5046	2019-01-11 06:34         tripleo/elijah/ElijahParser.java         Page 2
       
       
  5047	  "ident",
  5048	  "assignmentExpression",
  5049	  "expressionList",
  5050	  "conditionalExpression",
  5051	  "logicalOrExpression",
  5052	  "logicalAndExpression",
  5053	  "inclusiveOrExpression",
  5054	  "exclusiveOrExpression",
  5055	  "andExpression",
  5056	  "equalityExpression",
  5057	  "relationalExpression",
  5058	  "shiftExpression",
  5059	  "additiveExpression",
  5060	  "multiplicativeExpression",
  5061	  "qidentExpression",
  5062	  "unaryExpression",
  5063	  "unaryExpressionNotPlusMinus",
  5064	  "postfixExpression_priv",
  5065	  "primitiveElement",
  5066	  "variableReference",
  5067	  "procCallEx2",
  5068	};
       
  5069		public Out out;
  5070		private String xy;
  5071		private IExpression expr;
  5072	//	public final static Object null/*fixme*/=null;
       
  5073	protected ElijahParser(TokenBuffer tokenBuf, int k) {
  5074	  super(tokenBuf,k);
  5075	  tokenNames = _tokenNames;
  5076	  ruleNames  = _ruleNames;
  5077	  semPredNames = _semPredNames;
  5078	  setupDebugging(tokenBuf);
  5079	}
       
  5080	public ElijahParser(TokenBuffer tokenBuf) {
  5081	  this(tokenBuf,2);
  5082	}
       
  5083	protected ElijahParser(TokenStream lexer, int k) {
  5084	  super(lexer,k);
  5085	  tokenNames = _tokenNames;
  5086	  ruleNames  = _ruleNames;
  5087	  semPredNames = _semPredNames;
  5088	  setupDebugging(lexer);
  5089	}
       
  5090	public ElijahParser(TokenStream lexer) {
  5091	  this(lexer,2);
  5092	}
       
  5093	public ElijahParser(ParserSharedInputState state) {
  5094	  super(state,2);
  5095	  tokenNames = _tokenNames;
  5096	}
  5097	
       
  5098	2019-01-11 06:34         tripleo/elijah/ElijahParser.java         Page 3
       
       
       
  5099		public final void program() throws RecognitionException, TokenStreamException {
  5100			
  5101			fireEnterRule(0,0);
  5102			try { // debugging
  5103				ParserClosure pc=out.closure();
  5104				
  5105				{
  5106				switch ( LA(1)) {
  5107				case LITERAL_indexing:
  5108				{
  5109					match(LITERAL_indexing);
  5110					{
  5111					_loop4:
  5112					do {
  5113						if ((LA(1)==IDENT)) {
  5114							match(IDENT);
  5115							match(TOK_COLON);
  5116							constantValue();
  5117						}
  5118						else {
  5119							break _loop4;
  5120						}
  5121						
  5122					} while (true);
  5123					}
  5124					break;
  5125				}
  5126				case EOF:
  5127				case LITERAL_package:
  5128				case LITERAL_namespace:
  5129				case LITERAL_imports:
  5130				case LITERAL_class:
  5131				case LITERAL_from:
  5132				case LITERAL_import:
  5133				{
  5134					break;
  5135				}
  5136				default:
  5137				{
  5138					throw new NoViableAltException(LT(1), getFilename());
  5139				}
  5140				}
  5141				}
  5142				{
  5143				switch ( LA(1)) {
  5144				case LITERAL_package:
  5145				{
  5146					match(LITERAL_package);
  5147					xy=qualident();
  5148					if ( inputState.guessing==0 ) {
  5149						pc.packageName(xy);
  5150					}
  5151					{
  5152					switch ( LA(1)) {
  5153					case SEMI:
  5154	
       
  5155	2019-01-11 06:34         tripleo/elijah/ElijahParser.java         Page 4
       
       
  5156					{
  5157						match(SEMI);
  5158						break;
  5159					}
  5160					case EOF:
  5161					case LITERAL_namespace:
  5162					case LITERAL_imports:
  5163					case LITERAL_class:
  5164					case LITERAL_from:
  5165					case LITERAL_import:
  5166					{
  5167						break;
  5168					}
  5169					default:
  5170					{
  5171						throw new NoViableAltException(LT(1), getFilename());
  5172					}
  5173					}
  5174					}
  5175					break;
  5176				}
  5177				case EOF:
  5178				case LITERAL_namespace:
  5179				case LITERAL_imports:
  5180				case LITERAL_class:
  5181				case LITERAL_from:
  5182				case LITERAL_import:
  5183				{
  5184					break;
  5185				}
  5186				default:
  5187				{
  5188					throw new NoViableAltException(LT(1), getFilename());
  5189				}
  5190				}
  5191				}
  5192				{
  5193				_loop8:
  5194				do {
  5195					if ((_tokenSet_0.member(LA(1)))) {
  5196						programStatement(pc);
  5197					}
  5198					else {
  5199						break _loop8;
  5200					}
  5201					
  5202				} while (true);
  5203				}
  5204				{
  5205				match(Token.EOF_TYPE);
  5206				out.FinishModule();
  5207				}
  5208			} finally { // debugging
  5209				fireExitRule(0,0);
  5210			}
  5211		}
  5212	
       
  5213	2019-01-11 06:34         tripleo/elijah/ElijahParser.java         Page 5
       
       
  5214		
  5215		public final IExpression  constantValue() throws RecognitionException, TokenStreamException {
  5216			IExpression e;
  5217			
  5218			fireEnterRule(1,0);
  5219			try { // debugging
  5220				Token  s = null;
  5221				Token  c = null;
  5222				Token  n = null;
  5223				e=null;
  5224				
  5225				switch ( LA(1)) {
  5226				case STRING_LITERAL:
  5227				{
  5228					s = LT(1);
  5229					match(STRING_LITERAL);
  5230					if ( inputState.guessing==0 ) {
  5231						e=new StringExpression(s.getText());
  5232					}
  5233					break;
  5234				}
  5235				case CHAR_LITERAL:
  5236				{
  5237					c = LT(1);
  5238					match(CHAR_LITERAL);
  5239					if ( inputState.guessing==0 ) {
  5240						out.pushCharLit(c.getText());
  5241					}
  5242					break;
  5243				}
  5244				case NUM_INT:
  5245				{
  5246					n = LT(1);
  5247					match(NUM_INT);
  5248					if ( inputState.guessing==0 ) {
  5249						e=new NumericExpression(Integer.parseInt(n.getText()));
  5250					}
  5251					break;
  5252				}
  5253				case IDENT:
  5254				{
  5255					e=variableReference();
  5256					break;
  5257				}
  5258				case LBRACK:
  5259				{
  5260					match(LBRACK);
  5261					if ( inputState.guessing==0 ) {
  5262						e=new ListExpression();
  5263					}
  5264					expressionList(((ListExpression)e).contents());
  5265					match(RBRACK);
  5266					break;
  5267				}
  5268				default:
  5269				{
  5270	
       
  5271	2019-01-11 06:34         tripleo/elijah/ElijahParser.java         Page 6
       
       
  5272					throw new NoViableAltException(LT(1), getFilename());
  5273				}
  5274				}
  5275				return e;
  5276			} finally { // debugging
  5277				fireExitRule(1,0);
  5278			}
  5279		}
  5280		
  5281		public final String  qualident() throws RecognitionException, TokenStreamException {
  5282			String pc;
  5283			
  5284			fireEnterRule(2,0);
  5285			try { // debugging
  5286				Token  r1 = null;
  5287				Token  r2 = null;
  5288				StringBuffer r=new StringBuffer();pc=null;
  5289				
  5290				r1 = LT(1);
  5291				match(IDENT);
  5292				if ( inputState.guessing==0 ) {
  5293					r.append(r1.getText());
  5294				}
  5295				{
  5296				switch ( LA(1)) {
  5297				case DOT:
  5298				{
  5299					{
  5300					int _cnt99=0;
  5301					_loop99:
  5302					do {
  5303						if ((LA(1)==DOT)) {
  5304							match(DOT);
  5305							r2 = LT(1);
  5306							match(IDENT);
  5307							if ( inputState.guessing==0 ) {
  5308								r.append('.');r.append(r2.getText());
  5309							}
  5310						}
  5311						else {
  5312							if ( _cnt99>=1 ) { break _loop99; } else {throw new NoViableAltException(LT(1), getFilename());}
  5313						}
  5314						
  5315						_cnt99++;
  5316					} while (true);
  5317					}
  5318					if ( inputState.guessing==0 ) {
  5319						pc=r.toString();
  5320					}
  5321					break;
  5322				}
  5323				case EOF:
  5324				case IDENT:
  5325				case TOK_COLON:
  5326				case SEMI:
  5327				case LITERAL_namespace:
  5328	
       
  5329	2019-01-11 06:34         tripleo/elijah/ElijahParser.java         Page 7
       
       
  5330				case LPAREN:
  5331				case RPAREN:
  5332				case LITERAL_imports:
  5333				case LITERAL_class:
  5334				case LCURLY:
  5335				case RCURLY:
  5336				case COMMA:
  5337				case STRING_LITERAL:
  5338				case LITERAL_from:
  5339				case LITERAL_import:
  5340				case LITERAL_construct:
  5341				case LITERAL_yield:
  5342				case LITERAL_while:
  5343				case LITERAL_do:
  5344				case LITERAL_iterate:
  5345				case LITERAL_to:
  5346				case LITERAL_with:
  5347				case LITERAL_var:
  5348				case LITERAL_const:
  5349				case BECOMES:
  5350				case LITERAL_if:
  5351				case LITERAL_typeof:
  5352				case LITERAL_ref:
  5353				case LITERAL_generic:
  5354				case LBRACK:
  5355				case RBRACK:
  5356				case LITERAL_function:
  5357				case LITERAL_procedure:
  5358				case PLUS_ASSIGN:
  5359				case MINUS_ASSIGN:
  5360				case STAR_ASSIGN:
  5361				case DIV_ASSIGN:
  5362				case MOD_ASSIGN:
  5363				case SR_ASSIGN:
  5364				case BSR_ASSIGN:
  5365				case SL_ASSIGN:
  5366				case BAND_ASSIGN:
  5367				case BXOR_ASSIGN:
  5368				case BOR_ASSIGN:
  5369				case QUESTION:
  5370				case LOR:
  5371				case LAND:
  5372				case BOR:
  5373				case BXOR:
  5374				case BAND:
  5375				case EQUALITY:
  5376				case NOT_EQUALS:
  5377				case PLUS:
  5378				case MINUS:
  5379				case INC:
  5380				case DEC:
  5381				case BNOT:
  5382				case LNOT:
  5383				case CHAR_LITERAL:
  5384				case NUM_INT:
  5385				case LITERAL_block:
  5386	
       
  5387	2019-01-11 06:34         tripleo/elijah/ElijahParser.java         Page 8
       
       
  5388				{
  5389					break;
  5390				}
  5391				default:
  5392				{
  5393					throw new NoViableAltException(LT(1), getFilename());
  5394				}
  5395				}
  5396				}
  5397				return pc;
  5398			} finally { // debugging
  5399				fireExitRule(2,0);
  5400			}
  5401		}
  5402		
  5403		public final void programStatement(
  5404			ParserClosure pc
  5405		) throws RecognitionException, TokenStreamException {
  5406			
  5407			fireEnterRule(3,0);
  5408			try { // debugging
  5409				
  5410				switch ( LA(1)) {
  5411				case LITERAL_namespace:
  5412				{
  5413					match(LITERAL_namespace);
  5414					{
  5415					switch ( LA(1)) {
  5416					case IDENT:
  5417					{
  5418						match(IDENT);
  5419						break;
  5420					}
  5421					case LPAREN:
  5422					{
  5423						break;
  5424					}
  5425					default:
  5426					{
  5427						throw new NoViableAltException(LT(1), getFilename());
  5428					}
  5429					}
  5430					}
  5431					match(LPAREN);
  5432					match(RPAREN);
  5433					break;
  5434				}
  5435				case LITERAL_class:
  5436				{
  5437					classStatement(pc.classStatement());
  5438					break;
  5439				}
  5440				case LITERAL_from:
  5441				case LITERAL_import:
  5442				{
  5443					importStatement(pc.importStatement());
  5444	
       
  5445	2019-01-11 06:34         tripleo/elijah/ElijahParser.java         Page 9
       
       
  5446					break;
  5447				}
  5448				case LITERAL_imports:
  5449				{
  5450					match(LITERAL_imports);
  5451					break;
  5452				}
  5453				default:
  5454				{
  5455					throw new NoViableAltException(LT(1), getFilename());
  5456				}
  5457				}
  5458			} finally { // debugging
  5459				fireExitRule(3,0);
  5460			}
  5461		}
  5462		
  5463		public final void classStatement(
  5464			ClassStatement cls
  5465		) throws RecognitionException, TokenStreamException {
  5466			
  5467			fireEnterRule(4,0);
  5468			try { // debugging
  5469				Token  i1 = null;
  5470				
  5471				match(LITERAL_class);
  5472				i1 = LT(1);
  5473				match(IDENT);
  5474				if ( inputState.guessing==0 ) {
  5475					cls.setName(i1.getText());
  5476				}
  5477				{
  5478				switch ( LA(1)) {
  5479				case LPAREN:
  5480				{
  5481					classInheritance(cls.classInheritance());
  5482					break;
  5483				}
  5484				case LCURLY:
  5485				{
  5486					break;
  5487				}
  5488				default:
  5489				{
  5490					throw new NoViableAltException(LT(1), getFilename());
  5491				}
  5492				}
  5493				}
  5494				match(LCURLY);
  5495				{
  5496				switch ( LA(1)) {
  5497				case STRING_LITERAL:
  5498				{
  5499					docstrings(cls);
  5500					break;
  5501				}
  5502	
       
  5503	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 10
       
       
  5504				case IDENT:
  5505				case LITERAL_constructor:
  5506				case LITERAL_ctor:
  5507				case LITERAL_destructor:
  5508				case LITERAL_dtor:
  5509				case LITERAL_var:
  5510				case LITERAL_const:
  5511				case LITERAL_type:
  5512				case LITERAL_struct:
  5513				{
  5514					break;
  5515				}
  5516				default:
  5517				{
  5518					throw new NoViableAltException(LT(1), getFilename());
  5519				}
  5520				}
  5521				}
  5522				classScope(cls);
  5523				match(RCURLY);
  5524			} finally { // debugging
  5525				fireExitRule(4,0);
  5526			}
  5527		}
  5528		
  5529		public final void importStatement(
  5530			ImportStatement pc
  5531		) throws RecognitionException, TokenStreamException {
  5532			
  5533			fireEnterRule(5,0);
  5534			try { // debugging
  5535				
  5536				{
  5537				switch ( LA(1)) {
  5538				case LITERAL_from:
  5539				{
  5540					match(LITERAL_from);
  5541					xy=qualident();
  5542					if ( inputState.guessing==0 ) {
  5543						pc.importRoot(xy);
  5544					}
  5545					break;
  5546				}
  5547				case LITERAL_import:
  5548				{
  5549					break;
  5550				}
  5551				default:
  5552				{
  5553					throw new NoViableAltException(LT(1), getFilename());
  5554				}
  5555				}
  5556				}
  5557				match(LITERAL_import);
  5558				identList(pc.importList());
  5559			} finally { // debugging
  5560	
       
  5561	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 11
       
       
  5562				fireExitRule(5,0);
  5563			}
  5564		}
  5565		
  5566		private final void classInheritance(
  5567			ClassInheritance ci
  5568		) throws RecognitionException, TokenStreamException {
  5569			
  5570			fireEnterRule(6,0);
  5571			try { // debugging
  5572				
  5573				match(LPAREN);
  5574				typeName(ci.next());
  5575				{
  5576				_loop18:
  5577				do {
  5578					if ((_tokenSet_1.member(LA(1)))) {
  5579						{
  5580						switch ( LA(1)) {
  5581						case COMMA:
  5582						{
  5583							match(COMMA);
  5584							break;
  5585						}
  5586						case IDENT:
  5587						case LITERAL_const:
  5588						case LITERAL_typeof:
  5589						case LITERAL_ref:
  5590						case LITERAL_generic:
  5591						case LITERAL_function:
  5592						case LITERAL_procedure:
  5593						{
  5594							break;
  5595						}
  5596						default:
  5597						{
  5598							throw new NoViableAltException(LT(1), getFilename());
  5599						}
  5600						}
  5601						}
  5602						typeName(ci.next());
  5603					}
  5604					else {
  5605						break _loop18;
  5606					}
  5607					
  5608				} while (true);
  5609				}
  5610				match(RPAREN);
  5611			} finally { // debugging
  5612				fireExitRule(6,0);
  5613			}
  5614		}
  5615		
  5616		public final void docstrings(
  5617			Scope sc
  5618	
       
  5619	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 12
       
       
  5620		) throws RecognitionException, TokenStreamException {
  5621			
  5622			fireEnterRule(7,0);
  5623			try { // debugging
  5624				Token  s1 = null;
  5625				
  5626				{
  5627				int _cnt25=0;
  5628				_loop25:
  5629				do {
  5630					if ((LA(1)==STRING_LITERAL) && (_tokenSet_2.member(LA(2)))) {
  5631						s1 = LT(1);
  5632						match(STRING_LITERAL);
  5633						if ( inputState.guessing==0 ) {
  5634							sc.addDocString(s1.getText());
  5635						}
  5636					}
  5637					else {
  5638						if ( _cnt25>=1 ) { break _loop25; } else {throw new NoViableAltException(LT(1), getFilename());}
  5639					}
  5640					
  5641					_cnt25++;
  5642				} while (true);
  5643				}
  5644			} finally { // debugging
  5645				fireExitRule(7,0);
  5646			}
  5647		}
  5648		
  5649		public final void classScope(
  5650			ClassStatement pc
  5651		) throws RecognitionException, TokenStreamException {
  5652			
  5653			fireEnterRule(8,0);
  5654			try { // debugging
  5655				
  5656				switch ( LA(1)) {
  5657				case LITERAL_constructor:
  5658				case LITERAL_ctor:
  5659				{
  5660					{
  5661					switch ( LA(1)) {
  5662					case LITERAL_constructor:
  5663					{
  5664						match(LITERAL_constructor);
  5665						break;
  5666					}
  5667					case LITERAL_ctor:
  5668					{
  5669						match(LITERAL_ctor);
  5670						break;
  5671					}
  5672					default:
  5673					{
  5674						throw new NoViableAltException(LT(1), getFilename());
  5675					}
  5676	
       
  5677	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 13
       
       
  5678					}
  5679					}
  5680					{
  5681					switch ( LA(1)) {
  5682					case IDENT:
  5683					{
  5684						match(IDENT);
  5685						break;
  5686					}
  5687					case LCURLY:
  5688					{
  5689						break;
  5690					}
  5691					default:
  5692					{
  5693						throw new NoViableAltException(LT(1), getFilename());
  5694					}
  5695					}
  5696					}
  5697					scope(pc);
  5698					break;
  5699				}
  5700				case LITERAL_destructor:
  5701				case LITERAL_dtor:
  5702				{
  5703					{
  5704					switch ( LA(1)) {
  5705					case LITERAL_destructor:
  5706					{
  5707						match(LITERAL_destructor);
  5708						break;
  5709					}
  5710					case LITERAL_dtor:
  5711					{
  5712						match(LITERAL_dtor);
  5713						break;
  5714					}
  5715					default:
  5716					{
  5717						throw new NoViableAltException(LT(1), getFilename());
  5718					}
  5719					}
  5720					}
  5721					scope(pc);
  5722					break;
  5723				}
  5724				case IDENT:
  5725				{
  5726					functionDef(pc.funcDef());
  5727					break;
  5728				}
  5729				case LITERAL_var:
  5730				case LITERAL_const:
  5731				{
  5732					varStmt(pc.statementClosure());
  5733					break;
  5734	
       
  5735	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 14
       
       
  5736				}
  5737				case LITERAL_type:
  5738				case LITERAL_struct:
  5739				{
  5740					typeAlias();
  5741					break;
  5742				}
  5743				default:
  5744				{
  5745					throw new NoViableAltException(LT(1), getFilename());
  5746				}
  5747				}
  5748			} finally { // debugging
  5749				fireExitRule(8,0);
  5750			}
  5751		}
  5752		
  5753		public final void typeName(
  5754			TypeName pc
  5755		) throws RecognitionException, TokenStreamException {
  5756			
  5757			fireEnterRule(9,0);
  5758			try { // debugging
  5759				
  5760				if ((_tokenSet_3.member(LA(1))) && (_tokenSet_4.member(LA(2)))) {
  5761					structTypeName(pc);
  5762				}
  5763				else if ((LA(1)==LITERAL_function||LA(1)==LITERAL_procedure)) {
  5764					funcTypeExpr(pc);
  5765				}
  5766				else if ((LA(1)==IDENT) && (_tokenSet_4.member(LA(2)))) {
  5767					simpleTypeName_xx(pc);
  5768				}
  5769				else {
  5770					throw new NoViableAltException(LT(1), getFilename());
  5771				}
  5772				
  5773			} finally { // debugging
  5774				fireExitRule(9,0);
  5775			}
  5776		}
  5777		
  5778		public final void scope(
  5779			Scope pc
  5780		) throws RecognitionException, TokenStreamException {
  5781			
  5782			fireEnterRule(10,0);
  5783			try { // debugging
  5784				
  5785				match(LCURLY);
  5786				{
  5787				if ((LA(1)==STRING_LITERAL) && (_tokenSet_5.member(LA(2)))) {
  5788					docstrings(pc);
  5789				}
  5790				else if ((_tokenSet_5.member(LA(1))) && (_tokenSet_6.member(LA(2)))) {
  5791				}
  5792	
       
  5793	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 15
       
       
  5794				else {
  5795					throw new NoViableAltException(LT(1), getFilename());
  5796				}
  5797				
  5798				}
  5799				{
  5800				_loop37:
  5801				do {
  5802					if ((_tokenSet_7.member(LA(1))) && (_tokenSet_8.member(LA(2)))) {
  5803						baseStatement(pc.statementClosure());
  5804					}
  5805					else if ((_tokenSet_9.member(LA(1))) && (_tokenSet_10.member(LA(2)))) {
  5806						expr=expression();
  5807						if ( inputState.guessing==0 ) {
  5808							pc.statementWrapper(expr);
  5809						}
  5810					}
  5811					else {
  5812						break _loop37;
  5813					}
  5814					
  5815				} while (true);
  5816				}
  5817				match(RCURLY);
  5818			} finally { // debugging
  5819				fireExitRule(10,0);
  5820			}
  5821		}
  5822		
  5823		public final void functionDef(
  5824			FunctionDef fd
  5825		) throws RecognitionException, TokenStreamException {
  5826			
  5827			fireEnterRule(11,0);
  5828			try { // debugging
  5829				Token  i1 = null;
  5830				
  5831				i1 = LT(1);
  5832				match(IDENT);
  5833				if ( inputState.guessing==0 ) {
  5834					fd.setName(i1.getText());
  5835				}
  5836				opfal(fd.fal());
  5837				scope(fd.scope());
  5838			} finally { // debugging
  5839				fireExitRule(11,0);
  5840			}
  5841		}
  5842		
  5843		public final void varStmt(
  5844			StatementClosure pc
  5845		) throws RecognitionException, TokenStreamException {
  5846			
  5847			fireEnterRule(12,0);
  5848			try { // debugging
  5849				VariableSequence vsq=null;
  5850	
       
  5851	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 16
       
       
  5852				
  5853				{
  5854				switch ( LA(1)) {
  5855				case LITERAL_var:
  5856				{
  5857					match(LITERAL_var);
  5858					if ( inputState.guessing==0 ) {
  5859						vsq =pc.varSeq();/*= new VariableStatement();*/
  5860					}
  5861					break;
  5862				}
  5863				case LITERAL_const:
  5864				{
  5865					match(LITERAL_const);
  5866					if ( inputState.guessing==0 ) {
  5867						vsq =pc.varSeq();vsq.defaultModifiers(TypeModifiers.CONST);
  5868					}
  5869					break;
  5870				}
  5871				default:
  5872				{
  5873					throw new NoViableAltException(LT(1), getFilename());
  5874				}
  5875				}
  5876				}
  5877				varStmt_i(vsq.next());
  5878				{
  5879				_loop57:
  5880				do {
  5881					if ((LA(1)==COMMA)) {
  5882						match(COMMA);
  5883						varStmt_i(vsq.next());
  5884					}
  5885					else {
  5886						break _loop57;
  5887					}
  5888					
  5889				} while (true);
  5890				}
  5891			} finally { // debugging
  5892				fireExitRule(12,0);
  5893			}
  5894		}
  5895		
  5896		public final void typeAlias() throws RecognitionException, TokenStreamException {
  5897			
  5898			fireEnterRule(13,0);
  5899			try { // debugging
  5900				
  5901				switch ( LA(1)) {
  5902				case LITERAL_type:
  5903				{
  5904					match(LITERAL_type);
  5905					match(LITERAL_alias);
  5906					ident2();
  5907					match(BECOMES);
  5908	
       
  5909	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 17
       
       
  5910					qualident();
  5911					break;
  5912				}
  5913				case LITERAL_struct:
  5914				{
  5915					match(LITERAL_struct);
  5916					match(IDENT);
  5917					opfal(null);
  5918					match(LCURLY);
  5919					match(RCURLY);
  5920					break;
  5921				}
  5922				default:
  5923				{
  5924					throw new NoViableAltException(LT(1), getFilename());
  5925				}
  5926				}
  5927			} finally { // debugging
  5928				fireExitRule(13,0);
  5929			}
  5930		}
  5931		
  5932		public final void opfal(
  5933			FormalArgList fal
  5934		) throws RecognitionException, TokenStreamException {
  5935			
  5936			fireEnterRule(14,0);
  5937			try { // debugging
  5938				
  5939				match(LPAREN);
  5940				{
  5941				switch ( LA(1)) {
  5942				case IDENT:
  5943				case LITERAL_const:
  5944				case LITERAL_ref:
  5945				case LITERAL_in:
  5946				case LITERAL_out:
  5947				case LITERAL_generic:
  5948				{
  5949					formalArgList(fal);
  5950					break;
  5951				}
  5952				case RPAREN:
  5953				{
  5954					break;
  5955				}
  5956				default:
  5957				{
  5958					throw new NoViableAltException(LT(1), getFilename());
  5959				}
  5960				}
  5961				}
  5962				match(RPAREN);
  5963			} finally { // debugging
  5964				fireExitRule(14,0);
  5965			}
  5966	
       
  5967	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 18
       
       
  5968		}
  5969		
  5970		public final void baseStatement(
  5971			StatementClosure pc
  5972		) throws RecognitionException, TokenStreamException {
  5973			
  5974			fireEnterRule(15,0);
  5975			try { // debugging
  5976				
  5977				statement(pc);
  5978			} finally { // debugging
  5979				fireExitRule(15,0);
  5980			}
  5981		}
  5982		
  5983		public final void statement(
  5984			StatementClosure pc
  5985		) throws RecognitionException, TokenStreamException {
  5986			
  5987			fireEnterRule(16,0);
  5988			try { // debugging
  5989				
  5990				{
  5991				switch ( LA(1)) {
  5992				case IDENT:
  5993				{
  5994					procedureCallExpression(pc.procCallExpr());
  5995					break;
  5996				}
  5997				case LITERAL_if:
  5998				{
  5999					ifConditional(pc.ifExpression());
  6000					break;
  6001				}
  6002				case LITERAL_var:
  6003				case LITERAL_const:
  6004				{
  6005					varStmt(pc);
  6006					break;
  6007				}
  6008				case LITERAL_while:
  6009				case LITERAL_do:
  6010				{
  6011					whileLoop(pc);
  6012					break;
  6013				}
  6014				case LITERAL_iterate:
  6015				{
  6016					frobeIteration(pc);
  6017					break;
  6018				}
  6019				case LITERAL_construct:
  6020				{
  6021					match(LITERAL_construct);
  6022					expr=expression();
  6023					if ( inputState.guessing==0 ) {
  6024	
       
  6025	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 19
       
       
  6026						pc.constructExpression(expr);
  6027					}
  6028					break;
  6029				}
  6030				case LITERAL_yield:
  6031				{
  6032					match(LITERAL_yield);
  6033					expr=expression();
  6034					if ( inputState.guessing==0 ) {
  6035						pc.yield(expr);
  6036					}
  6037					break;
  6038				}
  6039				default:
  6040				{
  6041					throw new NoViableAltException(LT(1), getFilename());
  6042				}
  6043				}
  6044				}
  6045				{
  6046				_loop48:
  6047				do {
  6048					if ((LA(1)==SEMI)) {
  6049						match(SEMI);
  6050					}
  6051					else {
  6052						break _loop48;
  6053					}
  6054					
  6055				} while (true);
  6056				}
  6057			} finally { // debugging
  6058				fireExitRule(16,0);
  6059			}
  6060		}
  6061		
  6062		public final void identList(
  6063			IdentList ail
  6064		) throws RecognitionException, TokenStreamException {
  6065			
  6066			fireEnterRule(17,0);
  6067			try { // debugging
  6068				String s=null;
  6069				
  6070				s=ident2();
  6071				if ( inputState.guessing==0 ) {
  6072					ail.push(s);
  6073				}
  6074				{
  6075				_loop91:
  6076				do {
  6077					if ((LA(1)==COMMA)) {
  6078						match(COMMA);
  6079						s=ident2();
  6080						if ( inputState.guessing==0 ) {
  6081							ail.push(s);
  6082	
       
  6083	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 20
       
       
  6084						}
  6085					}
  6086					else {
  6087						break _loop91;
  6088					}
  6089					
  6090				} while (true);
  6091				}
  6092			} finally { // debugging
  6093				fireExitRule(17,0);
  6094			}
  6095		}
  6096		
  6097		public final IExpression  expression() throws RecognitionException, TokenStreamException {
  6098			IExpression ex;
  6099			
  6100			fireEnterRule(18,0);
  6101			try { // debugging
  6102				
  6103				ex=assignmentExpression();
  6104				return ex;
  6105			} finally { // debugging
  6106				fireExitRule(18,0);
  6107			}
  6108		}
  6109		
  6110		public final void functionScope(
  6111			Scope pc
  6112		) throws RecognitionException, TokenStreamException {
  6113			
  6114			fireEnterRule(19,0);
  6115			try { // debugging
  6116				
  6117				match(LCURLY);
  6118				{
  6119				switch ( LA(1)) {
  6120				case STRING_LITERAL:
  6121				{
  6122					docstrings(pc);
  6123					break;
  6124				}
  6125				case IDENT:
  6126				case RCURLY:
  6127				case LITERAL_construct:
  6128				case LITERAL_yield:
  6129				case LITERAL_while:
  6130				case LITERAL_do:
  6131				case LITERAL_iterate:
  6132				case LITERAL_var:
  6133				case LITERAL_const:
  6134				case LITERAL_if:
  6135				case LITERAL_block:
  6136				{
  6137					break;
  6138				}
  6139				default:
  6140	
       
  6141	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 21
       
       
  6142				{
  6143					throw new NoViableAltException(LT(1), getFilename());
  6144				}
  6145				}
  6146				}
  6147				{
  6148				_loop41:
  6149				do {
  6150					if ((_tokenSet_11.member(LA(1)))) {
  6151						functionStatement(pc.statementClosure());
  6152					}
  6153					else {
  6154						break _loop41;
  6155					}
  6156					
  6157				} while (true);
  6158				}
  6159				match(RCURLY);
  6160			} finally { // debugging
  6161				fireExitRule(19,0);
  6162			}
  6163		}
  6164		
  6165		public final void functionStatement(
  6166			StatementClosure pc
  6167		) throws RecognitionException, TokenStreamException {
  6168			
  6169			fireEnterRule(20,0);
  6170			try { // debugging
  6171				
  6172				switch ( LA(1)) {
  6173				case IDENT:
  6174				case LITERAL_construct:
  6175				case LITERAL_yield:
  6176				case LITERAL_while:
  6177				case LITERAL_do:
  6178				case LITERAL_iterate:
  6179				case LITERAL_var:
  6180				case LITERAL_const:
  6181				case LITERAL_if:
  6182				{
  6183					baseStatement(pc);
  6184					break;
  6185				}
  6186				case LITERAL_block:
  6187				{
  6188					block(pc.blockClosure());
  6189					break;
  6190				}
  6191				default:
  6192				{
  6193					throw new NoViableAltException(LT(1), getFilename());
  6194				}
  6195				}
  6196			} finally { // debugging
  6197				fireExitRule(20,0);
  6198	
       
  6199	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 22
       
       
  6200			}
  6201		}
  6202		
  6203		public final void block(
  6204			BlockStatement pc
  6205		) throws RecognitionException, TokenStreamException {
  6206			
  6207			fireEnterRule(21,0);
  6208			try { // debugging
  6209				
  6210				match(LITERAL_block);
  6211				{
  6212				switch ( LA(1)) {
  6213				case LITERAL_closure:
  6214				{
  6215					match(LITERAL_closure);
  6216					break;
  6217				}
  6218				case LPAREN:
  6219				{
  6220					break;
  6221				}
  6222				default:
  6223				{
  6224					throw new NoViableAltException(LT(1), getFilename());
  6225				}
  6226				}
  6227				}
  6228				opfal(pc.opfal());
  6229				{
  6230				switch ( LA(1)) {
  6231				case TOK_ARROW:
  6232				{
  6233					match(TOK_ARROW);
  6234					typeName(pc.returnType());
  6235					break;
  6236				}
  6237				case LCURLY:
  6238				{
  6239					break;
  6240				}
  6241				default:
  6242				{
  6243					throw new NoViableAltException(LT(1), getFilename());
  6244				}
  6245				}
  6246				}
  6247				match(LCURLY);
  6248				{
  6249				_loop179:
  6250				do {
  6251					if ((_tokenSet_7.member(LA(1)))) {
  6252						baseStatement(pc.scope());
  6253					}
  6254					else {
  6255						break _loop179;
  6256	
       
  6257	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 23
       
       
  6258					}
  6259					
  6260				} while (true);
  6261				}
  6262				match(RCURLY);
  6263			} finally { // debugging
  6264				fireExitRule(21,0);
  6265			}
  6266		}
  6267		
  6268		public final void formalArgList(
  6269			FormalArgList fal
  6270		) throws RecognitionException, TokenStreamException {
  6271			
  6272			fireEnterRule(22,0);
  6273			try { // debugging
  6274				
  6275				formalArgListItem_priv(fal.next());
  6276				{
  6277				_loop108:
  6278				do {
  6279					if ((LA(1)==COMMA)) {
  6280						match(COMMA);
  6281						formalArgListItem_priv(fal.next());
  6282					}
  6283					else {
  6284						break _loop108;
  6285					}
  6286					
  6287				} while (true);
  6288				}
  6289			} finally { // debugging
  6290				fireExitRule(22,0);
  6291			}
  6292		}
  6293		
  6294		public final void procedureCallExpression(
  6295			StatementClosure pc
  6296		) throws RecognitionException, TokenStreamException {
  6297			
  6298			fireEnterRule(23,0);
  6299			try { // debugging
  6300				ProcedureCallExpression pce=pc.procedureCallExpression();
  6301				
  6302				xy=qualident();
  6303				if ( inputState.guessing==0 ) {
  6304					pce.identifier(xy);
  6305				}
  6306				procCallEx(pce);
  6307			} finally { // debugging
  6308				fireExitRule(23,0);
  6309			}
  6310		}
  6311		
  6312		public final void ifConditional(
  6313			IfExpression ifex
  6314	
       
  6315	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 24
       
       
  6316		) throws RecognitionException, TokenStreamException {
  6317			
  6318			fireEnterRule(24,0);
  6319			try { // debugging
  6320				
  6321				match(LITERAL_if);
  6322				expr=expression();
  6323				if ( inputState.guessing==0 ) {
  6324					ifex.expr();
  6325				}
  6326				scope(ifex.scope());
  6327				{
  6328				_loop63:
  6329				do {
  6330					switch ( LA(1)) {
  6331					case LITERAL_else:
  6332					{
  6333						match(LITERAL_else);
  6334						scope(ifex.else_().scope());
  6335						break;
  6336					}
  6337					case LITERAL_elseif:
  6338					{
  6339						elseif_part(ifex.elseif());
  6340						break;
  6341					}
  6342					default:
  6343					{
  6344						break _loop63;
  6345					}
  6346					}
  6347				} while (true);
  6348				}
  6349			} finally { // debugging
  6350				fireExitRule(24,0);
  6351			}
  6352		}
  6353		
  6354		public final void whileLoop(
  6355			StatementClosure pc
  6356		) throws RecognitionException, TokenStreamException {
  6357			
  6358			fireEnterRule(25,0);
  6359			try { // debugging
  6360				Loop loop=pc.loop();
  6361				
  6362				switch ( LA(1)) {
  6363				case LITERAL_while:
  6364				{
  6365					match(LITERAL_while);
  6366					if ( inputState.guessing==0 ) {
  6367						loop.type(loop.WHILE);
  6368					}
  6369					expr=expression();
  6370					if ( inputState.guessing==0 ) {
  6371						loop.expr(expr);
  6372	
       
  6373	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 25
       
       
  6374					}
  6375					scope(loop.scope());
  6376					break;
  6377				}
  6378				case LITERAL_do:
  6379				{
  6380					match(LITERAL_do);
  6381					if ( inputState.guessing==0 ) {
  6382						loop.type(loop.DO_WHILE);
  6383					}
  6384					scope(loop.scope());
  6385					match(LITERAL_while);
  6386					expr=expression();
  6387					if ( inputState.guessing==0 ) {
  6388						loop.expr(expr);
  6389					}
  6390					break;
  6391				}
  6392				default:
  6393				{
  6394					throw new NoViableAltException(LT(1), getFilename());
  6395				}
  6396				}
  6397			} finally { // debugging
  6398				fireExitRule(25,0);
  6399			}
  6400		}
  6401		
  6402		public final void frobeIteration(
  6403			StatementClosure pc
  6404		) throws RecognitionException, TokenStreamException {
  6405			
  6406			fireEnterRule(26,0);
  6407			try { // debugging
  6408				Token  i1 = null;
  6409				Loop loop=pc.loop();
  6410				
  6411				match(LITERAL_iterate);
  6412				{
  6413				switch ( LA(1)) {
  6414				case LITERAL_from:
  6415				{
  6416					match(LITERAL_from);
  6417					if ( inputState.guessing==0 ) {
  6418						loop.type(loop.FROM_TO_TYPE);
  6419					}
  6420					expr=expression();
  6421					if ( inputState.guessing==0 ) {
  6422						loop.frompart(expr);
  6423					}
  6424					match(LITERAL_to);
  6425					expr=expression();
  6426					if ( inputState.guessing==0 ) {
  6427						loop.topart(expr);
  6428					}
  6429					break;
  6430	
       
  6431	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 26
       
       
  6432				}
  6433				case LITERAL_to:
  6434				{
  6435					match(LITERAL_to);
  6436					if ( inputState.guessing==0 ) {
  6437						loop.type(loop.TO_TYPE);
  6438					}
  6439					expr=expression();
  6440					if ( inputState.guessing==0 ) {
  6441						loop.topart(expr);
  6442					}
  6443					break;
  6444				}
  6445				case IDENT:
  6446				case LPAREN:
  6447				case STRING_LITERAL:
  6448				case LBRACK:
  6449				case PLUS:
  6450				case MINUS:
  6451				case INC:
  6452				case DEC:
  6453				case BNOT:
  6454				case LNOT:
  6455				case CHAR_LITERAL:
  6456				case NUM_INT:
  6457				{
  6458					if ( inputState.guessing==0 ) {
  6459						loop.type(loop.EXPR_TYPE);
  6460					}
  6461					expr=expression();
  6462					if ( inputState.guessing==0 ) {
  6463						loop.topart(expr);
  6464					}
  6465					break;
  6466				}
  6467				default:
  6468				{
  6469					throw new NoViableAltException(LT(1), getFilename());
  6470				}
  6471				}
  6472				}
  6473				{
  6474				switch ( LA(1)) {
  6475				case LITERAL_with:
  6476				{
  6477					match(LITERAL_with);
  6478					i1 = LT(1);
  6479					match(IDENT);
  6480					if ( inputState.guessing==0 ) {
  6481						loop.iterName(i1.getText());
  6482					}
  6483					break;
  6484				}
  6485				case LCURLY:
  6486				{
  6487					break;
  6488	
       
  6489	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 27
       
       
  6490				}
  6491				default:
  6492				{
  6493					throw new NoViableAltException(LT(1), getFilename());
  6494				}
  6495				}
  6496				}
  6497				scope(loop.scope());
  6498			} finally { // debugging
  6499				fireExitRule(26,0);
  6500			}
  6501		}
  6502		
  6503		public final void procCallEx(
  6504			ProcedureCallExpression pce
  6505		) throws RecognitionException, TokenStreamException {
  6506			
  6507			fireEnterRule(27,0);
  6508			try { // debugging
  6509				
  6510				match(LPAREN);
  6511				{
  6512				switch ( LA(1)) {
  6513				case IDENT:
  6514				case LPAREN:
  6515				case STRING_LITERAL:
  6516				case LBRACK:
  6517				case PLUS:
  6518				case MINUS:
  6519				case INC:
  6520				case DEC:
  6521				case BNOT:
  6522				case LNOT:
  6523				case CHAR_LITERAL:
  6524				case NUM_INT:
  6525				{
  6526					expressionList(pce.exprList());
  6527					break;
  6528				}
  6529				case RPAREN:
  6530				{
  6531					break;
  6532				}
  6533				default:
  6534				{
  6535					throw new NoViableAltException(LT(1), getFilename());
  6536				}
  6537				}
  6538				}
  6539				match(RPAREN);
  6540			} finally { // debugging
  6541				fireExitRule(27,0);
  6542			}
  6543		}
  6544		
  6545		private final void varStmt_i(
  6546	
       
  6547	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 28
       
       
  6548			VariableStatement vs 
  6549		) throws RecognitionException, TokenStreamException {
  6550			
  6551			fireEnterRule(28,0);
  6552			try { // debugging
  6553				Token  i = null;
  6554				
  6555				i = LT(1);
  6556				match(IDENT);
  6557				if ( inputState.guessing==0 ) {
  6558					vs.setName(i.getText());
  6559				}
  6560				{
  6561				switch ( LA(1)) {
  6562				case TOK_COLON:
  6563				{
  6564					match(TOK_COLON);
  6565					typeName(vs.typeName());
  6566					break;
  6567				}
  6568				case IDENT:
  6569				case SEMI:
  6570				case LPAREN:
  6571				case RCURLY:
  6572				case COMMA:
  6573				case STRING_LITERAL:
  6574				case LITERAL_construct:
  6575				case LITERAL_yield:
  6576				case LITERAL_while:
  6577				case LITERAL_do:
  6578				case LITERAL_iterate:
  6579				case LITERAL_var:
  6580				case LITERAL_const:
  6581				case BECOMES:
  6582				case LITERAL_if:
  6583				case LBRACK:
  6584				case PLUS:
  6585				case MINUS:
  6586				case INC:
  6587				case DEC:
  6588				case BNOT:
  6589				case LNOT:
  6590				case CHAR_LITERAL:
  6591				case NUM_INT:
  6592				case LITERAL_block:
  6593				{
  6594					break;
  6595				}
  6596				default:
  6597				{
  6598					throw new NoViableAltException(LT(1), getFilename());
  6599				}
  6600				}
  6601				}
  6602				{
  6603				switch ( LA(1)) {
  6604	
       
  6605	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 29
       
       
  6606				case BECOMES:
  6607				{
  6608					match(BECOMES);
  6609					expr=expression();
  6610					if ( inputState.guessing==0 ) {
  6611						vs.initial(expr);
  6612					}
  6613					break;
  6614				}
  6615				case IDENT:
  6616				case SEMI:
  6617				case LPAREN:
  6618				case RCURLY:
  6619				case COMMA:
  6620				case STRING_LITERAL:
  6621				case LITERAL_construct:
  6622				case LITERAL_yield:
  6623				case LITERAL_while:
  6624				case LITERAL_do:
  6625				case LITERAL_iterate:
  6626				case LITERAL_var:
  6627				case LITERAL_const:
  6628				case LITERAL_if:
  6629				case LBRACK:
  6630				case PLUS:
  6631				case MINUS:
  6632				case INC:
  6633				case DEC:
  6634				case BNOT:
  6635				case LNOT:
  6636				case CHAR_LITERAL:
  6637				case NUM_INT:
  6638				case LITERAL_block:
  6639				{
  6640					break;
  6641				}
  6642				default:
  6643				{
  6644					throw new NoViableAltException(LT(1), getFilename());
  6645				}
  6646				}
  6647				}
  6648			} finally { // debugging
  6649				fireExitRule(28,0);
  6650			}
  6651		}
  6652		
  6653		private final void elseif_part(
  6654			IfExpression ifex
  6655		) throws RecognitionException, TokenStreamException {
  6656			
  6657			fireEnterRule(29,0);
  6658			try { // debugging
  6659				
  6660				match(LITERAL_elseif);
  6661				expr=expression();
  6662	
       
  6663	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 30
       
       
  6664				if ( inputState.guessing==0 ) {
  6665					ifex.expr();
  6666				}
  6667				scope(ifex.scope());
  6668			} finally { // debugging
  6669				fireExitRule(29,0);
  6670			}
  6671		}
  6672		
  6673		public final void structTypeName(
  6674			TypeName pc
  6675		) throws RecognitionException, TokenStreamException {
  6676			
  6677			fireEnterRule(30,0);
  6678			try { // debugging
  6679				
  6680				switch ( LA(1)) {
  6681				case IDENT:
  6682				case LITERAL_const:
  6683				case LITERAL_ref:
  6684				case LITERAL_generic:
  6685				{
  6686					genericQualifiers(pc);
  6687					{
  6688					switch ( LA(1)) {
  6689					case LITERAL_generic:
  6690					{
  6691						abstractGenericTypeName_xx(pc);
  6692						break;
  6693					}
  6694					case IDENT:
  6695					{
  6696						specifiedGenericTypeName_xx(pc);
  6697						break;
  6698					}
  6699					default:
  6700					{
  6701						throw new NoViableAltException(LT(1), getFilename());
  6702					}
  6703					}
  6704					}
  6705					break;
  6706				}
  6707				case LITERAL_typeof:
  6708				{
  6709					match(LITERAL_typeof);
  6710					xy=qualident();
  6711					if ( inputState.guessing==0 ) {
  6712						pc.typeof(xy);
  6713					}
  6714					break;
  6715				}
  6716				default:
  6717				{
  6718					throw new NoViableAltException(LT(1), getFilename());
  6719				}
  6720	
       
  6721	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 31
       
       
  6722				}
  6723			} finally { // debugging
  6724				fireExitRule(30,0);
  6725			}
  6726		}
  6727		
  6728		public final void genericQualifiers(
  6729			TypeName pc
  6730		) throws RecognitionException, TokenStreamException {
  6731			
  6732			fireEnterRule(31,0);
  6733			try { // debugging
  6734				
  6735				{
  6736				switch ( LA(1)) {
  6737				case LITERAL_const:
  6738				{
  6739					match(LITERAL_const);
  6740					if ( inputState.guessing==0 ) {
  6741						pc.set(TypeModifiers.CONST);
  6742					}
  6743					break;
  6744				}
  6745				case IDENT:
  6746				case LITERAL_ref:
  6747				case LITERAL_generic:
  6748				{
  6749					break;
  6750				}
  6751				default:
  6752				{
  6753					throw new NoViableAltException(LT(1), getFilename());
  6754				}
  6755				}
  6756				}
  6757				{
  6758				switch ( LA(1)) {
  6759				case LITERAL_ref:
  6760				{
  6761					match(LITERAL_ref);
  6762					if ( inputState.guessing==0 ) {
  6763						pc.set(TypeModifiers.REFPAR);
  6764					}
  6765					break;
  6766				}
  6767				case IDENT:
  6768				case LITERAL_generic:
  6769				{
  6770					break;
  6771				}
  6772				default:
  6773				{
  6774					throw new NoViableAltException(LT(1), getFilename());
  6775				}
  6776				}
  6777				}
  6778	
       
  6779	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 32
       
       
  6780			} finally { // debugging
  6781				fireExitRule(31,0);
  6782			}
  6783		}
  6784		
  6785		public final void abstractGenericTypeName_xx(
  6786			TypeName tn
  6787		) throws RecognitionException, TokenStreamException {
  6788			
  6789			fireEnterRule(32,0);
  6790			try { // debugging
  6791				
  6792				match(LITERAL_generic);
  6793				xy=qualident();
  6794				if ( inputState.guessing==0 ) {
  6795					tn.typeName(xy);
  6796				}
  6797				if ( inputState.guessing==0 ) {
  6798					tn.set(TypeModifiers.GENERIC);
  6799				}
  6800			} finally { // debugging
  6801				fireExitRule(32,0);
  6802			}
  6803		}
  6804		
  6805		public final void specifiedGenericTypeName_xx(
  6806			TypeName tn
  6807		) throws RecognitionException, TokenStreamException {
  6808			
  6809			fireEnterRule(33,0);
  6810			try { // debugging
  6811				
  6812				simpleTypeName_xx(tn);
  6813				{
  6814				if ((LA(1)==LBRACK) && (_tokenSet_12.member(LA(2)))) {
  6815					match(LBRACK);
  6816					typeName(tn);
  6817					match(RBRACK);
  6818				}
  6819				else if ((_tokenSet_13.member(LA(1))) && (_tokenSet_14.member(LA(2)))) {
  6820				}
  6821				else {
  6822					throw new NoViableAltException(LT(1), getFilename());
  6823				}
  6824				
  6825				}
  6826			} finally { // debugging
  6827				fireExitRule(33,0);
  6828			}
  6829		}
  6830		
  6831		public final void formalArgTypeName(
  6832			TypeName tn
  6833		) throws RecognitionException, TokenStreamException {
  6834			
  6835			fireEnterRule(34,0);
  6836	
       
  6837	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 33
       
       
  6838			try { // debugging
  6839				
  6840				switch ( LA(1)) {
  6841				case IDENT:
  6842				case LITERAL_const:
  6843				case LITERAL_typeof:
  6844				case LITERAL_ref:
  6845				case LITERAL_generic:
  6846				{
  6847					structTypeName(tn);
  6848					break;
  6849				}
  6850				case LITERAL_function:
  6851				case LITERAL_procedure:
  6852				{
  6853					funcTypeExpr(tn);
  6854					break;
  6855				}
  6856				default:
  6857				{
  6858					throw new NoViableAltException(LT(1), getFilename());
  6859				}
  6860				}
  6861			} finally { // debugging
  6862				fireExitRule(34,0);
  6863			}
  6864		}
  6865		
  6866		public final void funcTypeExpr(
  6867			TypeName pc
  6868		) throws RecognitionException, TokenStreamException {
  6869			
  6870			fireEnterRule(35,0);
  6871			try { // debugging
  6872				
  6873				switch ( LA(1)) {
  6874				case LITERAL_function:
  6875				{
  6876					match(LITERAL_function);
  6877					if ( inputState.guessing==0 ) {
  6878						pc.type(TypeModifiers.FUNCTION);
  6879					}
  6880					{
  6881					if ((LA(1)==LPAREN) && (_tokenSet_15.member(LA(2)))) {
  6882						match(LPAREN);
  6883						{
  6884						switch ( LA(1)) {
  6885						case IDENT:
  6886						case LITERAL_const:
  6887						case LITERAL_typeof:
  6888						case LITERAL_ref:
  6889						case LITERAL_generic:
  6890						case LITERAL_function:
  6891						case LITERAL_procedure:
  6892						{
  6893							typeNameList(pc.argList());
  6894	
       
  6895	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 34
       
       
  6896							break;
  6897						}
  6898						case RPAREN:
  6899						{
  6900							break;
  6901						}
  6902						default:
  6903						{
  6904							throw new NoViableAltException(LT(1), getFilename());
  6905						}
  6906						}
  6907						}
  6908						match(RPAREN);
  6909					}
  6910					else if ((_tokenSet_16.member(LA(1))) && (_tokenSet_14.member(LA(2)))) {
  6911					}
  6912					else {
  6913						throw new NoViableAltException(LT(1), getFilename());
  6914					}
  6915					
  6916					}
  6917					{
  6918					switch ( LA(1)) {
  6919					case TOK_ARROW:
  6920					{
  6921						match(TOK_ARROW);
  6922						typeName(pc.returnValue());
  6923						break;
  6924					}
  6925					case IDENT:
  6926					case TOK_COLON:
  6927					case SEMI:
  6928					case LPAREN:
  6929					case RPAREN:
  6930					case LCURLY:
  6931					case RCURLY:
  6932					case COMMA:
  6933					case STRING_LITERAL:
  6934					case LITERAL_construct:
  6935					case LITERAL_yield:
  6936					case LITERAL_while:
  6937					case LITERAL_do:
  6938					case LITERAL_iterate:
  6939					case LITERAL_to:
  6940					case LITERAL_with:
  6941					case LITERAL_var:
  6942					case LITERAL_const:
  6943					case BECOMES:
  6944					case LITERAL_if:
  6945					case LITERAL_typeof:
  6946					case LITERAL_ref:
  6947					case LITERAL_generic:
  6948					case LBRACK:
  6949					case RBRACK:
  6950					case LITERAL_function:
  6951					case LITERAL_procedure:
  6952	
       
  6953	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 35
       
       
  6954					case PLUS_ASSIGN:
  6955					case MINUS_ASSIGN:
  6956					case STAR_ASSIGN:
  6957					case DIV_ASSIGN:
  6958					case MOD_ASSIGN:
  6959					case SR_ASSIGN:
  6960					case BSR_ASSIGN:
  6961					case SL_ASSIGN:
  6962					case BAND_ASSIGN:
  6963					case BXOR_ASSIGN:
  6964					case BOR_ASSIGN:
  6965					case QUESTION:
  6966					case LOR:
  6967					case LAND:
  6968					case BOR:
  6969					case BXOR:
  6970					case BAND:
  6971					case EQUALITY:
  6972					case NOT_EQUALS:
  6973					case PLUS:
  6974					case MINUS:
  6975					case INC:
  6976					case DEC:
  6977					case BNOT:
  6978					case LNOT:
  6979					case CHAR_LITERAL:
  6980					case NUM_INT:
  6981					case LITERAL_block:
  6982					{
  6983						break;
  6984					}
  6985					default:
  6986					{
  6987						throw new NoViableAltException(LT(1), getFilename());
  6988					}
  6989					}
  6990					}
  6991					break;
  6992				}
  6993				case LITERAL_procedure:
  6994				{
  6995					match(LITERAL_procedure);
  6996					if ( inputState.guessing==0 ) {
  6997						pc.type(TypeModifiers.PROCEDURE);
  6998					}
  6999					{
  7000					if ((LA(1)==LPAREN) && (_tokenSet_15.member(LA(2)))) {
  7001						match(LPAREN);
  7002						{
  7003						switch ( LA(1)) {
  7004						case IDENT:
  7005						case LITERAL_const:
  7006						case LITERAL_typeof:
  7007						case LITERAL_ref:
  7008						case LITERAL_generic:
  7009						case LITERAL_function:
  7010	
       
  7011	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 36
       
       
  7012						case LITERAL_procedure:
  7013						{
  7014							typeNameList(pc.argList());
  7015							break;
  7016						}
  7017						case RPAREN:
  7018						{
  7019							break;
  7020						}
  7021						default:
  7022						{
  7023							throw new NoViableAltException(LT(1), getFilename());
  7024						}
  7025						}
  7026						}
  7027						match(RPAREN);
  7028					}
  7029					else if ((_tokenSet_13.member(LA(1))) && (_tokenSet_14.member(LA(2)))) {
  7030					}
  7031					else {
  7032						throw new NoViableAltException(LT(1), getFilename());
  7033					}
  7034					
  7035					}
  7036					break;
  7037				}
  7038				default:
  7039				{
  7040					throw new NoViableAltException(LT(1), getFilename());
  7041				}
  7042				}
  7043			} finally { // debugging
  7044				fireExitRule(35,0);
  7045			}
  7046		}
  7047		
  7048		public final void simpleTypeName_xx(
  7049			TypeName tn
  7050		) throws RecognitionException, TokenStreamException {
  7051			
  7052			fireEnterRule(36,0);
  7053			try { // debugging
  7054				
  7055				xy=qualident();
  7056				if ( inputState.guessing==0 ) {
  7057					tn.typeName(xy);
  7058				}
  7059			} finally { // debugging
  7060				fireExitRule(36,0);
  7061			}
  7062		}
  7063		
  7064		public final void variableQualifiers(
  7065			TypeName pc
  7066		) throws RecognitionException, TokenStreamException {
  7067			
  7068	
       
  7069	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 37
       
       
  7070			fireEnterRule(37,0);
  7071			try { // debugging
  7072				
  7073				{
  7074				switch ( LA(1)) {
  7075				case LITERAL_once:
  7076				{
  7077					match(LITERAL_once);
  7078					if ( inputState.guessing==0 ) {
  7079						pc.set(TypeModifiers.ONCE);
  7080					}
  7081					break;
  7082				}
  7083				case EOF:
  7084				case LITERAL_const:
  7085				case LITERAL_local:
  7086				case LITERAL_tagged:
  7087				case LITERAL_pooled:
  7088				case LITERAL_manual:
  7089				case LITERAL_gc:
  7090				{
  7091					break;
  7092				}
  7093				default:
  7094				{
  7095					throw new NoViableAltException(LT(1), getFilename());
  7096				}
  7097				}
  7098				}
  7099				{
  7100				switch ( LA(1)) {
  7101				case LITERAL_local:
  7102				{
  7103					match(LITERAL_local);
  7104					if ( inputState.guessing==0 ) {
  7105						pc.set(TypeModifiers.LOCAL);
  7106					}
  7107					break;
  7108				}
  7109				case LITERAL_tagged:
  7110				{
  7111					match(LITERAL_tagged);
  7112					if ( inputState.guessing==0 ) {
  7113						pc.set(TypeModifiers.TAGGED);
  7114					}
  7115					break;
  7116				}
  7117				case LITERAL_const:
  7118				{
  7119					match(LITERAL_const);
  7120					if ( inputState.guessing==0 ) {
  7121						pc.set(TypeModifiers.CONST);
  7122					}
  7123					break;
  7124				}
  7125				case LITERAL_pooled:
  7126	
       
  7127	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 38
       
       
  7128				{
  7129					match(LITERAL_pooled);
  7130					if ( inputState.guessing==0 ) {
  7131						pc.set(TypeModifiers.POOLED);
  7132					}
  7133					break;
  7134				}
  7135				case LITERAL_manual:
  7136				{
  7137					match(LITERAL_manual);
  7138					if ( inputState.guessing==0 ) {
  7139						pc.set(TypeModifiers.MANUAL);
  7140					}
  7141					break;
  7142				}
  7143				case LITERAL_gc:
  7144				{
  7145					match(LITERAL_gc);
  7146					if ( inputState.guessing==0 ) {
  7147						pc.set(TypeModifiers.GC);
  7148					}
  7149					break;
  7150				}
  7151				case EOF:
  7152				{
  7153					break;
  7154				}
  7155				default:
  7156				{
  7157					throw new NoViableAltException(LT(1), getFilename());
  7158				}
  7159				}
  7160				}
  7161			} finally { // debugging
  7162				fireExitRule(37,0);
  7163			}
  7164		}
  7165		
  7166		public final void regularQualifiers(
  7167			TypeName fp
  7168		) throws RecognitionException, TokenStreamException {
  7169			
  7170			fireEnterRule(38,0);
  7171			try { // debugging
  7172				
  7173				{
  7174				switch ( LA(1)) {
  7175				case LITERAL_in:
  7176				{
  7177					match(LITERAL_in);
  7178					if ( inputState.guessing==0 ) {
  7179						fp.setIn(true);
  7180					}
  7181					break;
  7182				}
  7183				case LITERAL_out:
  7184	
       
  7185	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 39
       
       
  7186				{
  7187					match(LITERAL_out);
  7188					if ( inputState.guessing==0 ) {
  7189						fp.setOut(true);
  7190					}
  7191					break;
  7192				}
  7193				default:
  7194					if ((LA(1)==LITERAL_const) && (LA(2)==IDENT||LA(2)==LITERAL_generic)) {
  7195						match(LITERAL_const);
  7196						if ( inputState.guessing==0 ) {
  7197							fp.setConstant(true);
  7198						}
  7199					}
  7200					else if ((LA(1)==LITERAL_const||LA(1)==LITERAL_ref) && (LA(2)==IDENT||LA(2)==LITERAL_ref||LA(2)==LITERAL_generic)) {
  7201						{
  7202						{
  7203						switch ( LA(1)) {
  7204						case LITERAL_const:
  7205						{
  7206							match(LITERAL_const);
  7207							if ( inputState.guessing==0 ) {
  7208								fp.setConstant(true);
  7209							}
  7210							break;
  7211						}
  7212						case LITERAL_ref:
  7213						{
  7214							break;
  7215						}
  7216						default:
  7217						{
  7218							throw new NoViableAltException(LT(1), getFilename());
  7219						}
  7220						}
  7221						}
  7222						match(LITERAL_ref);
  7223						if ( inputState.guessing==0 ) {
  7224							fp.setReference(true);
  7225						}
  7226						}
  7227					}
  7228				else {
  7229					throw new NoViableAltException(LT(1), getFilename());
  7230				}
  7231				}
  7232				}
  7233			} finally { // debugging
  7234				fireExitRule(38,0);
  7235			}
  7236		}
  7237		
  7238		public final void typeNameList(
  7239			TypeNameList pc
  7240		) throws RecognitionException, TokenStreamException {
  7241			
  7242	
       
  7243	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 40
       
       
  7244			fireEnterRule(39,0);
  7245			try { // debugging
  7246				
  7247				typeName(pc.next());
  7248				{
  7249				_loop105:
  7250				do {
  7251					if ((LA(1)==COMMA)) {
  7252						match(COMMA);
  7253						typeName(pc.next());
  7254					}
  7255					else {
  7256						break _loop105;
  7257					}
  7258					
  7259				} while (true);
  7260				}
  7261			} finally { // debugging
  7262				fireExitRule(39,0);
  7263			}
  7264		}
  7265		
  7266		public final String  ident2() throws RecognitionException, TokenStreamException {
  7267			String ident;
  7268			
  7269			fireEnterRule(40,0);
  7270			try { // debugging
  7271				Token  r1 = null;
  7272				ident=null;
  7273				
  7274				r1 = LT(1);
  7275				match(IDENT);
  7276				if ( inputState.guessing==0 ) {
  7277					ident=r1.getText();
  7278				}
  7279				return ident;
  7280			} finally { // debugging
  7281				fireExitRule(40,0);
  7282			}
  7283		}
  7284		
  7285		public final void qualidentList(
  7286			QualidentList qal
  7287		) throws RecognitionException, TokenStreamException {
  7288			
  7289			fireEnterRule(41,0);
  7290			try { // debugging
  7291				String qid;
  7292				
  7293				qid=qualident();
  7294				if ( inputState.guessing==0 ) {
  7295					qal.add(qid);
  7296				}
  7297				{
  7298				_loop102:
  7299				do {
  7300	
       
  7301	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 41
       
       
  7302					if ((LA(1)==COMMA)) {
  7303						match(COMMA);
  7304						qid=qualident();
  7305						if ( inputState.guessing==0 ) {
  7306							qal.add(qid);
  7307						}
  7308					}
  7309					else {
  7310						break _loop102;
  7311					}
  7312					
  7313				} while (true);
  7314				}
  7315			} finally { // debugging
  7316				fireExitRule(41,0);
  7317			}
  7318		}
  7319		
  7320		private final void formalArgListItem_priv(
  7321			FormalArgListItem fali
  7322		) throws RecognitionException, TokenStreamException {
  7323			
  7324			fireEnterRule(42,0);
  7325			try { // debugging
  7326				Token  i = null;
  7327				
  7328				{
  7329				switch ( LA(1)) {
  7330				case LITERAL_const:
  7331				case LITERAL_ref:
  7332				case LITERAL_in:
  7333				case LITERAL_out:
  7334				{
  7335					regularQualifiers(fali.typeName());
  7336					break;
  7337				}
  7338				case IDENT:
  7339				case LITERAL_generic:
  7340				{
  7341					break;
  7342				}
  7343				default:
  7344				{
  7345					throw new NoViableAltException(LT(1), getFilename());
  7346				}
  7347				}
  7348				}
  7349				{
  7350				switch ( LA(1)) {
  7351				case IDENT:
  7352				{
  7353					i = LT(1);
  7354					match(IDENT);
  7355					if ( inputState.guessing==0 ) {
  7356						fali.setName(i.getText());
  7357					}
  7358	
       
  7359	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 42
       
       
  7360					{
  7361					switch ( LA(1)) {
  7362					case TOK_COLON:
  7363					{
  7364						match(TOK_COLON);
  7365						formalArgTypeName(fali.typeName());
  7366						break;
  7367					}
  7368					case RPAREN:
  7369					case COMMA:
  7370					{
  7371						break;
  7372					}
  7373					default:
  7374					{
  7375						throw new NoViableAltException(LT(1), getFilename());
  7376					}
  7377					}
  7378					}
  7379					break;
  7380				}
  7381				case LITERAL_generic:
  7382				{
  7383					abstractGenericTypeName_xx(fali.typeName());
  7384					break;
  7385				}
  7386				default:
  7387				{
  7388					throw new NoViableAltException(LT(1), getFilename());
  7389				}
  7390				}
  7391				}
  7392			} finally { // debugging
  7393				fireExitRule(42,0);
  7394			}
  7395		}
  7396		
  7397		public final void ident() throws RecognitionException, TokenStreamException {
  7398			
  7399			fireEnterRule(43,0);
  7400			try { // debugging
  7401				Token  r1 = null;
  7402				
  7403				r1 = LT(1);
  7404				match(IDENT);
  7405				if ( inputState.guessing==0 ) {
  7406					out.pushString(r1.getText());
  7407				}
  7408			} finally { // debugging
  7409				fireExitRule(43,0);
  7410			}
  7411		}
  7412		
  7413		public final IExpression  assignmentExpression() throws RecognitionException, TokenStreamException {
  7414			IExpression e;
  7415			
  7416	
       
  7417	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 43
       
       
  7418			fireEnterRule(44,0);
  7419			try { // debugging
  7420				IExpression e2;
  7421				
  7422				e=conditionalExpression();
  7423				{
  7424				switch ( LA(1)) {
  7425				case BECOMES:
  7426				case PLUS_ASSIGN:
  7427				case MINUS_ASSIGN:
  7428				case STAR_ASSIGN:
  7429				case DIV_ASSIGN:
  7430				case MOD_ASSIGN:
  7431				case SR_ASSIGN:
  7432				case BSR_ASSIGN:
  7433				case SL_ASSIGN:
  7434				case BAND_ASSIGN:
  7435				case BXOR_ASSIGN:
  7436				case BOR_ASSIGN:
  7437				{
  7438					{
  7439					switch ( LA(1)) {
  7440					case BECOMES:
  7441					{
  7442						match(BECOMES);
  7443						if ( inputState.guessing==0 ) {
  7444							e=ExpressionBuilder.buildPartial(e, ExpressionType.ASSIGNMENT);
  7445						}
  7446						break;
  7447					}
  7448					case PLUS_ASSIGN:
  7449					{
  7450						match(PLUS_ASSIGN);
  7451						if ( inputState.guessing==0 ) {
  7452							e=ExpressionBuilder.buildPartial(e, ExpressionType.AUG_PLUS);
  7453						}
  7454						break;
  7455					}
  7456					case MINUS_ASSIGN:
  7457					{
  7458						match(MINUS_ASSIGN);
  7459						if ( inputState.guessing==0 ) {
  7460							e=ExpressionBuilder.buildPartial(e, ExpressionType.AUG_MINUS);
  7461						}
  7462						break;
  7463					}
  7464					case STAR_ASSIGN:
  7465					{
  7466						match(STAR_ASSIGN);
  7467						if ( inputState.guessing==0 ) {
  7468							e=ExpressionBuilder.buildPartial(e, ExpressionType.AUG_MULT);
  7469						}
  7470						break;
  7471					}
  7472					case DIV_ASSIGN:
  7473					{
  7474	
       
  7475	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 44
       
       
  7476						match(DIV_ASSIGN);
  7477						if ( inputState.guessing==0 ) {
  7478							e=ExpressionBuilder.buildPartial(e, ExpressionType.AUG_DIV);
  7479						}
  7480						break;
  7481					}
  7482					case MOD_ASSIGN:
  7483					{
  7484						match(MOD_ASSIGN);
  7485						if ( inputState.guessing==0 ) {
  7486							e=ExpressionBuilder.buildPartial(e, ExpressionType.AUG_MOD);
  7487						}
  7488						break;
  7489					}
  7490					case SR_ASSIGN:
  7491					{
  7492						match(SR_ASSIGN);
  7493						if ( inputState.guessing==0 ) {
  7494							e=ExpressionBuilder.buildPartial(e, ExpressionType.AUG_SR);
  7495						}
  7496						break;
  7497					}
  7498					case BSR_ASSIGN:
  7499					{
  7500						match(BSR_ASSIGN);
  7501						if ( inputState.guessing==0 ) {
  7502							e=ExpressionBuilder.buildPartial(e, ExpressionType.AUG_BSR);
  7503						}
  7504						break;
  7505					}
  7506					case SL_ASSIGN:
  7507					{
  7508						match(SL_ASSIGN);
  7509						if ( inputState.guessing==0 ) {
  7510							e=ExpressionBuilder.buildPartial(e, ExpressionType.AUG_SL);
  7511						}
  7512						break;
  7513					}
  7514					case BAND_ASSIGN:
  7515					{
  7516						match(BAND_ASSIGN);
  7517						if ( inputState.guessing==0 ) {
  7518							e=ExpressionBuilder.buildPartial(e, ExpressionType.AUG_BAND);
  7519						}
  7520						break;
  7521					}
  7522					case BXOR_ASSIGN:
  7523					{
  7524						match(BXOR_ASSIGN);
  7525						if ( inputState.guessing==0 ) {
  7526							e=ExpressionBuilder.buildPartial(e, ExpressionType.AUG_BXOR);
  7527						}
  7528						break;
  7529					}
  7530					case BOR_ASSIGN:
  7531					{
  7532	
       
  7533	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 45
       
       
  7534						match(BOR_ASSIGN);
  7535						if ( inputState.guessing==0 ) {
  7536							e=ExpressionBuilder.buildPartial(e, ExpressionType.AUG_BOR);
  7537						}
  7538						break;
  7539					}
  7540					default:
  7541					{
  7542						throw new NoViableAltException(LT(1), getFilename());
  7543					}
  7544					}
  7545					}
  7546					e2=assignmentExpression();
  7547					if ( inputState.guessing==0 ) {
  7548						((IBinaryExpression)e).setRight(e2);
  7549					}
  7550					break;
  7551				}
  7552				case IDENT:
  7553				case TOK_COLON:
  7554				case SEMI:
  7555				case LPAREN:
  7556				case RPAREN:
  7557				case LCURLY:
  7558				case RCURLY:
  7559				case COMMA:
  7560				case STRING_LITERAL:
  7561				case LITERAL_construct:
  7562				case LITERAL_yield:
  7563				case LITERAL_while:
  7564				case LITERAL_do:
  7565				case LITERAL_iterate:
  7566				case LITERAL_to:
  7567				case LITERAL_with:
  7568				case LITERAL_var:
  7569				case LITERAL_const:
  7570				case LITERAL_if:
  7571				case LBRACK:
  7572				case RBRACK:
  7573				case PLUS:
  7574				case MINUS:
  7575				case INC:
  7576				case DEC:
  7577				case BNOT:
  7578				case LNOT:
  7579				case CHAR_LITERAL:
  7580				case NUM_INT:
  7581				case LITERAL_block:
  7582				{
  7583					break;
  7584				}
  7585				default:
  7586				{
  7587					throw new NoViableAltException(LT(1), getFilename());
  7588				}
  7589				}
  7590	
       
  7591	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 46
       
       
  7592				}
  7593				return e;
  7594			} finally { // debugging
  7595				fireExitRule(44,0);
  7596			}
  7597		}
  7598		
  7599		public final void expressionList(
  7600			ExpressionList el
  7601		) throws RecognitionException, TokenStreamException {
  7602			
  7603			fireEnterRule(45,0);
  7604			try { // debugging
  7605				
  7606				expr=expression();
  7607				if ( inputState.guessing==0 ) {
  7608					el.next(expr);
  7609				}
  7610				{
  7611				_loop118:
  7612				do {
  7613					if ((LA(1)==COMMA)) {
  7614						match(COMMA);
  7615						expr=expression();
  7616						if ( inputState.guessing==0 ) {
  7617							el.next(expr);
  7618						}
  7619					}
  7620					else {
  7621						break _loop118;
  7622					}
  7623					
  7624				} while (true);
  7625				}
  7626			} finally { // debugging
  7627				fireExitRule(45,0);
  7628			}
  7629		}
  7630		
  7631		public final IExpression  conditionalExpression() throws RecognitionException, TokenStreamException {
  7632			IExpression e;
  7633			
  7634			fireEnterRule(46,0);
  7635			try { // debugging
  7636				
  7637				e=logicalOrExpression();
  7638				{
  7639				switch ( LA(1)) {
  7640				case QUESTION:
  7641				{
  7642					match(QUESTION);
  7643					assignmentExpression();
  7644					match(TOK_COLON);
  7645					conditionalExpression();
  7646					break;
  7647				}
  7648	
       
  7649	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 47
       
       
  7650				case IDENT:
  7651				case TOK_COLON:
  7652				case SEMI:
  7653				case LPAREN:
  7654				case RPAREN:
  7655				case LCURLY:
  7656				case RCURLY:
  7657				case COMMA:
  7658				case STRING_LITERAL:
  7659				case LITERAL_construct:
  7660				case LITERAL_yield:
  7661				case LITERAL_while:
  7662				case LITERAL_do:
  7663				case LITERAL_iterate:
  7664				case LITERAL_to:
  7665				case LITERAL_with:
  7666				case LITERAL_var:
  7667				case LITERAL_const:
  7668				case BECOMES:
  7669				case LITERAL_if:
  7670				case LBRACK:
  7671				case RBRACK:
  7672				case PLUS_ASSIGN:
  7673				case MINUS_ASSIGN:
  7674				case STAR_ASSIGN:
  7675				case DIV_ASSIGN:
  7676				case MOD_ASSIGN:
  7677				case SR_ASSIGN:
  7678				case BSR_ASSIGN:
  7679				case SL_ASSIGN:
  7680				case BAND_ASSIGN:
  7681				case BXOR_ASSIGN:
  7682				case BOR_ASSIGN:
  7683				case PLUS:
  7684				case MINUS:
  7685				case INC:
  7686				case DEC:
  7687				case BNOT:
  7688				case LNOT:
  7689				case CHAR_LITERAL:
  7690				case NUM_INT:
  7691				case LITERAL_block:
  7692				{
  7693					break;
  7694				}
  7695				default:
  7696				{
  7697					throw new NoViableAltException(LT(1), getFilename());
  7698				}
  7699				}
  7700				}
  7701				return e;
  7702			} finally { // debugging
  7703				fireExitRule(46,0);
  7704			}
  7705		}
  7706	
       
  7707	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 48
       
       
  7708		
  7709		public final IExpression  logicalOrExpression() throws RecognitionException, TokenStreamException {
  7710			IExpression e;
  7711			
  7712			fireEnterRule(47,0);
  7713			try { // debugging
  7714				
  7715				e=logicalAndExpression();
  7716				{
  7717				_loop126:
  7718				do {
  7719					if ((LA(1)==LOR)) {
  7720						match(LOR);
  7721						logicalAndExpression();
  7722					}
  7723					else {
  7724						break _loop126;
  7725					}
  7726					
  7727				} while (true);
  7728				}
  7729				return e;
  7730			} finally { // debugging
  7731				fireExitRule(47,0);
  7732			}
  7733		}
  7734		
  7735		public final IExpression  logicalAndExpression() throws RecognitionException, TokenStreamException {
  7736			IExpression e;
  7737			
  7738			fireEnterRule(48,0);
  7739			try { // debugging
  7740				
  7741				e=inclusiveOrExpression();
  7742				{
  7743				_loop129:
  7744				do {
  7745					if ((LA(1)==LAND)) {
  7746						match(LAND);
  7747						inclusiveOrExpression();
  7748					}
  7749					else {
  7750						break _loop129;
  7751					}
  7752					
  7753				} while (true);
  7754				}
  7755				return e;
  7756			} finally { // debugging
  7757				fireExitRule(48,0);
  7758			}
  7759		}
  7760		
  7761		public final IExpression  inclusiveOrExpression() throws RecognitionException, TokenStreamException {
  7762			IExpression e;
  7763			
  7764	
       
  7765	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 49
       
       
  7766			fireEnterRule(49,0);
  7767			try { // debugging
  7768				
  7769				e=exclusiveOrExpression();
  7770				{
  7771				_loop132:
  7772				do {
  7773					if ((LA(1)==BOR)) {
  7774						match(BOR);
  7775						exclusiveOrExpression();
  7776					}
  7777					else {
  7778						break _loop132;
  7779					}
  7780					
  7781				} while (true);
  7782				}
  7783				return e;
  7784			} finally { // debugging
  7785				fireExitRule(49,0);
  7786			}
  7787		}
  7788		
  7789		public final IExpression  exclusiveOrExpression() throws RecognitionException, TokenStreamException {
  7790			IExpression e;
  7791			
  7792			fireEnterRule(50,0);
  7793			try { // debugging
  7794				
  7795				e=andExpression();
  7796				{
  7797				_loop135:
  7798				do {
  7799					if ((LA(1)==BXOR)) {
  7800						match(BXOR);
  7801						andExpression();
  7802					}
  7803					else {
  7804						break _loop135;
  7805					}
  7806					
  7807				} while (true);
  7808				}
  7809				return e;
  7810			} finally { // debugging
  7811				fireExitRule(50,0);
  7812			}
  7813		}
  7814		
  7815		public final IExpression  andExpression() throws RecognitionException, TokenStreamException {
  7816			IExpression e;
  7817			
  7818			fireEnterRule(51,0);
  7819			try { // debugging
  7820				
  7821				e=equalityExpression();
  7822	
       
  7823	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 50
       
       
  7824				{
  7825				_loop138:
  7826				do {
  7827					if ((LA(1)==BAND)) {
  7828						match(BAND);
  7829						equalityExpression();
  7830					}
  7831					else {
  7832						break _loop138;
  7833					}
  7834					
  7835				} while (true);
  7836				}
  7837				return e;
  7838			} finally { // debugging
  7839				fireExitRule(51,0);
  7840			}
  7841		}
  7842		
  7843		public final IExpression  equalityExpression() throws RecognitionException, TokenStreamException {
  7844			IExpression e;
  7845			
  7846			fireEnterRule(52,0);
  7847			try { // debugging
  7848				
  7849				e=relationalExpression();
  7850				{
  7851				_loop142:
  7852				do {
  7853					if ((LA(1)==EQUALITY||LA(1)==NOT_EQUALS)) {
  7854						{
  7855						switch ( LA(1)) {
  7856						case EQUALITY:
  7857						{
  7858							match(EQUALITY);
  7859							break;
  7860						}
  7861						case NOT_EQUALS:
  7862						{
  7863							match(NOT_EQUALS);
  7864							break;
  7865						}
  7866						default:
  7867						{
  7868							throw new NoViableAltException(LT(1), getFilename());
  7869						}
  7870						}
  7871						}
  7872						relationalExpression();
  7873					}
  7874					else {
  7875						break _loop142;
  7876					}
  7877					
  7878				} while (true);
  7879				}
  7880	
       
  7881	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 51
       
       
  7882				return e;
  7883			} finally { // debugging
  7884				fireExitRule(52,0);
  7885			}
  7886		}
  7887		
  7888		public final IExpression  relationalExpression() throws RecognitionException, TokenStreamException {
  7889			IExpression e;
  7890			
  7891			fireEnterRule(53,0);
  7892			try { // debugging
  7893				TypeName tn=null;
  7894				
  7895				e=shiftExpression();
  7896				{
  7897				switch ( LA(1)) {
  7898				case IDENT:
  7899				case TOK_COLON:
  7900				case SEMI:
  7901				case LPAREN:
  7902				case RPAREN:
  7903				case LCURLY:
  7904				case RCURLY:
  7905				case COMMA:
  7906				case STRING_LITERAL:
  7907				case LITERAL_construct:
  7908				case LITERAL_yield:
  7909				case LITERAL_while:
  7910				case LITERAL_do:
  7911				case LITERAL_iterate:
  7912				case LITERAL_to:
  7913				case LITERAL_with:
  7914				case LITERAL_var:
  7915				case LITERAL_const:
  7916				case BECOMES:
  7917				case LITERAL_if:
  7918				case LBRACK:
  7919				case RBRACK:
  7920				case PLUS_ASSIGN:
  7921				case MINUS_ASSIGN:
  7922				case STAR_ASSIGN:
  7923				case DIV_ASSIGN:
  7924				case MOD_ASSIGN:
  7925				case SR_ASSIGN:
  7926				case BSR_ASSIGN:
  7927				case SL_ASSIGN:
  7928				case BAND_ASSIGN:
  7929				case BXOR_ASSIGN:
  7930				case BOR_ASSIGN:
  7931				case QUESTION:
  7932				case LOR:
  7933				case LAND:
  7934				case BOR:
  7935				case BXOR:
  7936				case BAND:
  7937				case EQUALITY:
  7938	
       
  7939	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 52
       
       
  7940				case NOT_EQUALS:
  7941				case LT_:
  7942				case GT:
  7943				case LTE:
  7944				case GTE:
  7945				case PLUS:
  7946				case MINUS:
  7947				case INC:
  7948				case DEC:
  7949				case BNOT:
  7950				case LNOT:
  7951				case CHAR_LITERAL:
  7952				case NUM_INT:
  7953				case LITERAL_block:
  7954				{
  7955					{
  7956					_loop147:
  7957					do {
  7958						if (((LA(1) >= LT_ && LA(1) <= GTE))) {
  7959							{
  7960							switch ( LA(1)) {
  7961							case LT_:
  7962							{
  7963								match(LT_);
  7964								break;
  7965							}
  7966							case GT:
  7967							{
  7968								match(GT);
  7969								break;
  7970							}
  7971							case LTE:
  7972							{
  7973								match(LTE);
  7974								break;
  7975							}
  7976							case GTE:
  7977							{
  7978								match(GTE);
  7979								break;
  7980							}
  7981							default:
  7982							{
  7983								throw new NoViableAltException(LT(1), getFilename());
  7984							}
  7985							}
  7986							}
  7987							shiftExpression();
  7988						}
  7989						else {
  7990							break _loop147;
  7991						}
  7992						
  7993					} while (true);
  7994					}
  7995					break;
  7996	
       
  7997	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 53
       
       
  7998				}
  7999				case LITERAL_is_a:
  8000				{
  8001					match(LITERAL_is_a);
  8002					if ( inputState.guessing==0 ) {
  8003						tn=new RegularTypeName();
  8004					}
  8005					typeName(tn);
  8006					if ( inputState.guessing==0 ) {
  8007						e=ExpressionBuilder.build(e, ExpressionType.IS_A, new TypeNameExpression(tn));
  8008					}
  8009					break;
  8010				}
  8011				default:
  8012				{
  8013					throw new NoViableAltException(LT(1), getFilename());
  8014				}
  8015				}
  8016				}
  8017				return e;
  8018			} finally { // debugging
  8019				fireExitRule(53,0);
  8020			}
  8021		}
  8022		
  8023		public final IExpression  shiftExpression() throws RecognitionException, TokenStreamException {
  8024			IExpression e;
  8025			
  8026			fireEnterRule(54,0);
  8027			try { // debugging
  8028				
  8029				e=additiveExpression();
  8030				{
  8031				_loop151:
  8032				do {
  8033					if (((LA(1) >= SL && LA(1) <= BSR))) {
  8034						{
  8035						switch ( LA(1)) {
  8036						case SL:
  8037						{
  8038							match(SL);
  8039							break;
  8040						}
  8041						case SR:
  8042						{
  8043							match(SR);
  8044							break;
  8045						}
  8046						case BSR:
  8047						{
  8048							match(BSR);
  8049							break;
  8050						}
  8051						default:
  8052						{
  8053							throw new NoViableAltException(LT(1), getFilename());
  8054	
       
  8055	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 54
       
       
  8056						}
  8057						}
  8058						}
  8059						additiveExpression();
  8060					}
  8061					else {
  8062						break _loop151;
  8063					}
  8064					
  8065				} while (true);
  8066				}
  8067				return e;
  8068			} finally { // debugging
  8069				fireExitRule(54,0);
  8070			}
  8071		}
  8072		
  8073		public final IExpression  additiveExpression() throws RecognitionException, TokenStreamException {
  8074			IExpression e;
  8075			
  8076			fireEnterRule(55,0);
  8077			try { // debugging
  8078				IExpression ex;
  8079				
  8080				e=multiplicativeExpression();
  8081				{
  8082				_loop155:
  8083				do {
  8084					if ((LA(1)==PLUS||LA(1)==MINUS) && (_tokenSet_9.member(LA(2)))) {
  8085						{
  8086						switch ( LA(1)) {
  8087						case PLUS:
  8088						{
  8089							match(PLUS);
  8090							if ( inputState.guessing==0 ) {
  8091								e=ExpressionBuilder.buildPartial(e, ExpressionType.ADDITION);
  8092							}
  8093							break;
  8094						}
  8095						case MINUS:
  8096						{
  8097							match(MINUS);
  8098							if ( inputState.guessing==0 ) {
  8099								e=ExpressionBuilder.buildPartial(e, ExpressionType.SUBTRACTION);
  8100							}
  8101							break;
  8102						}
  8103						default:
  8104						{
  8105							throw new NoViableAltException(LT(1), getFilename());
  8106						}
  8107						}
  8108						}
  8109						ex=multiplicativeExpression();
  8110						if ( inputState.guessing==0 ) {
  8111							((IBinaryExpression)e).setRight(ex);
  8112	
       
  8113	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 55
       
       
  8114						}
  8115					}
  8116					else {
  8117						break _loop155;
  8118					}
  8119					
  8120				} while (true);
  8121				}
  8122				return e;
  8123			} finally { // debugging
  8124				fireExitRule(55,0);
  8125			}
  8126		}
  8127		
  8128		public final IExpression  multiplicativeExpression() throws RecognitionException, TokenStreamException {
  8129			IExpression e;
  8130			
  8131			fireEnterRule(56,0);
  8132			try { // debugging
  8133				
  8134				e=qidentExpression();
  8135				{
  8136				_loop159:
  8137				do {
  8138					if (((LA(1) >= STAR && LA(1) <= MOD))) {
  8139						{
  8140						switch ( LA(1)) {
  8141						case STAR:
  8142						{
  8143							match(STAR);
  8144							if ( inputState.guessing==0 ) {
  8145								out.pushMultiply();
  8146							}
  8147							break;
  8148						}
  8149						case DIV:
  8150						{
  8151							match(DIV);
  8152							break;
  8153						}
  8154						case MOD:
  8155						{
  8156							match(MOD);
  8157							break;
  8158						}
  8159						default:
  8160						{
  8161							throw new NoViableAltException(LT(1), getFilename());
  8162						}
  8163						}
  8164						}
  8165						qidentExpression();
  8166					}
  8167					else {
  8168						break _loop159;
  8169					}
  8170	
       
  8171	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 56
       
       
  8172					
  8173				} while (true);
  8174				}
  8175				return e;
  8176			} finally { // debugging
  8177				fireExitRule(56,0);
  8178			}
  8179		}
  8180		
  8181		public final IExpression  qidentExpression() throws RecognitionException, TokenStreamException {
  8182			IExpression e;
  8183			
  8184			fireEnterRule(57,0);
  8185			try { // debugging
  8186				IExpression e2;
  8187				
  8188				e=unaryExpression();
  8189				{
  8190				_loop162:
  8191				do {
  8192					if ((LA(1)==QIDENT)) {
  8193						match(QIDENT);
  8194						e2=unaryExpression();
  8195						if ( inputState.guessing==0 ) {
  8196							e=ExpressionBuilder.build(e, ExpressionType.QIDENT,(e2));
  8197						}
  8198					}
  8199					else {
  8200						break _loop162;
  8201					}
  8202					
  8203				} while (true);
  8204				}
  8205				return e;
  8206			} finally { // debugging
  8207				fireExitRule(57,0);
  8208			}
  8209		}
  8210		
  8211		public final IExpression  unaryExpression() throws RecognitionException, TokenStreamException {
  8212			IExpression e;
  8213			
  8214			fireEnterRule(58,0);
  8215			try { // debugging
  8216				
  8217				switch ( LA(1)) {
  8218				case INC:
  8219				{
  8220					match(INC);
  8221					e=unaryExpression();
  8222					if ( inputState.guessing==0 ) {
  8223						e.set(ExpressionType.INCREMENT);
  8224					}
  8225					break;
  8226				}
  8227				case DEC:
  8228	
       
  8229	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 57
       
       
  8230				{
  8231					match(DEC);
  8232					e=unaryExpression();
  8233					if ( inputState.guessing==0 ) {
  8234						e.set(ExpressionType.DECREMENT);
  8235					}
  8236					break;
  8237				}
  8238				case MINUS:
  8239				{
  8240					match(MINUS);
  8241					e=unaryExpression();
  8242					if ( inputState.guessing==0 ) {
  8243						e.set(ExpressionType.NEGATION);
  8244					}
  8245					break;
  8246				}
  8247				case PLUS:
  8248				{
  8249					match(PLUS);
  8250					e=unaryExpression();
  8251					if ( inputState.guessing==0 ) {
  8252						e.set(ExpressionType.POSITIVITY);
  8253					}
  8254					break;
  8255				}
  8256				case IDENT:
  8257				case LPAREN:
  8258				case STRING_LITERAL:
  8259				case LBRACK:
  8260				case BNOT:
  8261				case LNOT:
  8262				case CHAR_LITERAL:
  8263				case NUM_INT:
  8264				{
  8265					e=unaryExpressionNotPlusMinus();
  8266					break;
  8267				}
  8268				default:
  8269				{
  8270					throw new NoViableAltException(LT(1), getFilename());
  8271				}
  8272				}
  8273				return e;
  8274			} finally { // debugging
  8275				fireExitRule(58,0);
  8276			}
  8277		}
  8278		
  8279		public final IExpression  unaryExpressionNotPlusMinus() throws RecognitionException, TokenStreamException {
  8280			IExpression e;
  8281			
  8282			fireEnterRule(59,0);
  8283			try { // debugging
  8284				
  8285				switch ( LA(1)) {
  8286	
       
  8287	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 58
       
       
  8288				case BNOT:
  8289				{
  8290					match(BNOT);
  8291					e=unaryExpression();
  8292					if ( inputState.guessing==0 ) {
  8293						e.set(ExpressionType.BNOT);
  8294					}
  8295					break;
  8296				}
  8297				case LNOT:
  8298				{
  8299					match(LNOT);
  8300					e=unaryExpression();
  8301					if ( inputState.guessing==0 ) {
  8302						e.set(ExpressionType.LNOT);
  8303					}
  8304					break;
  8305				}
  8306				case IDENT:
  8307				case LPAREN:
  8308				case STRING_LITERAL:
  8309				case LBRACK:
  8310				case CHAR_LITERAL:
  8311				case NUM_INT:
  8312				{
  8313					{
  8314					e=postfixExpression_priv();
  8315					}
  8316					break;
  8317				}
  8318				default:
  8319				{
  8320					throw new NoViableAltException(LT(1), getFilename());
  8321				}
  8322				}
  8323				return e;
  8324			} finally { // debugging
  8325				fireExitRule(59,0);
  8326			}
  8327		}
  8328		
  8329		public final IExpression  postfixExpression_priv() throws RecognitionException, TokenStreamException {
  8330			IExpression e;
  8331			
  8332			fireEnterRule(60,0);
  8333			try { // debugging
  8334				Token  in = null;
  8335				Token  de = null;
  8336				
  8337				{
  8338				e=primitiveElement();
  8339				{
  8340				if ((LA(1)==INC) && (_tokenSet_17.member(LA(2)))) {
  8341					in = LT(1);
  8342					match(INC);
  8343					if ( inputState.guessing==0 ) {
  8344	
       
  8345	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 59
       
       
  8346						e=ExpressionBuilder.build(e, ExpressionType.POST_INCREMENT);
  8347					}
  8348				}
  8349				else if ((LA(1)==DEC) && (_tokenSet_17.member(LA(2)))) {
  8350					de = LT(1);
  8351					match(DEC);
  8352					if ( inputState.guessing==0 ) {
  8353						e=ExpressionBuilder.build(e, ExpressionType.POST_DECREMENT);
  8354					}
  8355				}
  8356				else if ((_tokenSet_17.member(LA(1))) && (_tokenSet_18.member(LA(2)))) {
  8357				}
  8358				else {
  8359					throw new NoViableAltException(LT(1), getFilename());
  8360				}
  8361				
  8362				}
  8363				}
  8364				return e;
  8365			} finally { // debugging
  8366				fireExitRule(60,0);
  8367			}
  8368		}
  8369		
  8370		public final IExpression  primitiveElement() throws RecognitionException, TokenStreamException {
  8371			IExpression e;
  8372			
  8373			fireEnterRule(61,0);
  8374			try { // debugging
  8375				e=null;
  8376				
  8377				switch ( LA(1)) {
  8378				case IDENT:
  8379				case STRING_LITERAL:
  8380				case LBRACK:
  8381				case CHAR_LITERAL:
  8382				case NUM_INT:
  8383				{
  8384					e=constantValue();
  8385					break;
  8386				}
  8387				case LPAREN:
  8388				{
  8389					match(LPAREN);
  8390					if ( inputState.guessing==0 ) {
  8391						e=new SubExpression();
  8392					}
  8393					expr=expression();
  8394					match(RPAREN);
  8395					break;
  8396				}
  8397				default:
  8398				{
  8399					throw new NoViableAltException(LT(1), getFilename());
  8400				}
  8401				}
  8402	
       
  8403	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 60
       
       
  8404				return e;
  8405			} finally { // debugging
  8406				fireExitRule(61,0);
  8407			}
  8408		}
  8409		
  8410		public final VariableReference variableReference() throws RecognitionException, TokenStreamException {
  8411			
  8412			fireEnterRule(62,0);
  8413			try { // debugging
  8414				Token  r1 = null;
  8415				Token  r2 = null;
  8416				Token  r3 = null;
  8417				VariableReference vr=new VariableReference();
  8418				
  8419				r1 = LT(1);
  8420				match(IDENT);
  8421				if ( inputState.guessing==0 ) {
  8422					vr.setMain(r1.getText());
  8423				}
  8424				{
  8425				_loop183:
  8426				do {
  8427					if ((LA(1)==DOT)) {
  8428						match(DOT);
  8429						r2 = LT(1);
  8430						match(IDENT);
  8431						if ( inputState.guessing==0 ) {
  8432							vr.addIdentPart(r2.getText());
  8433						}
  8434					}
  8435					else if ((LA(1)==TOK_COLON) && (LA(2)==TOK_COLON)) {
  8436						match(TOK_COLON);
  8437						match(TOK_COLON);
  8438						r3 = LT(1);
  8439						match(IDENT);
  8440						if ( inputState.guessing==0 ) {
  8441							vr.addColonIdentPart(r3.getText());
  8442						}
  8443					}
  8444					else if ((LA(1)==LBRACK) && (_tokenSet_9.member(LA(2)))) {
  8445						match(LBRACK);
  8446						expr=expression();
  8447						match(RBRACK);
  8448						if ( inputState.guessing==0 ) {
  8449							vr.addArrayPart(expr);
  8450						}
  8451					}
  8452					else if ((LA(1)==LPAREN) && (_tokenSet_19.member(LA(2)))) {
  8453						procCallEx2();
  8454						if ( inputState.guessing==0 ) {
  8455							vr.addProcCallPart(out.popProcCall());
  8456						}
  8457					}
  8458					else {
  8459						break _loop183;
  8460	
       
  8461	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 61
       
       
  8462					}
  8463					
  8464				} while (true);
  8465				return vr; // TODO
  8466				}
  8467			} finally { // debugging
  8468				fireExitRule(62,0);
  8469			}
  8470		}
  8471		
  8472		public final void procCallEx2() throws RecognitionException, TokenStreamException {
  8473			
  8474			fireEnterRule(63,0);
  8475			try { // debugging
  8476				
  8477				match(LPAREN);
  8478				{
  8479				switch ( LA(1)) {
  8480				case IDENT:
  8481				case LPAREN:
  8482				case STRING_LITERAL:
  8483				case LBRACK:
  8484				case PLUS:
  8485				case MINUS:
  8486				case INC:
  8487				case DEC:
  8488				case BNOT:
  8489				case LNOT:
  8490				case CHAR_LITERAL:
  8491				case NUM_INT:
  8492				{
  8493					expressionList(null/*fixme*/);
  8494					break;
  8495				}
  8496				case RPAREN:
  8497				{
  8498					break;
  8499				}
  8500				default:
  8501				{
  8502					throw new NoViableAltException(LT(1), getFilename());
  8503				}
  8504				}
  8505				}
  8506				match(RPAREN);
  8507			} finally { // debugging
  8508				fireExitRule(63,0);
  8509			}
  8510		}
  8511		
  8512		
  8513		public static final String[] _tokenNames = {
  8514			"<0>",
  8515			"EOF",
  8516			"<2>",
  8517			"NULL_TREE_LOOKAHEAD",
  8518	
       
  8519	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 62
       
       
  8520			"PROCEDURE_CALL",
  8521			"EXPR_LIST",
  8522			"NUM_FLOAT",
  8523			"\"indexing\"",
  8524			"IDENT",
  8525			"TOK_COLON",
  8526			"\"package\"",
  8527			"SEMI",
  8528			"\"namespace\"",
  8529			"LPAREN",
  8530			"RPAREN",
  8531			"\"imports\"",
  8532			"\"class\"",
  8533			"LCURLY",
  8534			"RCURLY",
  8535			"COMMA",
  8536			"STRING_LITERAL",
  8537			"\"constructor\"",
  8538			"\"ctor\"",
  8539			"\"destructor\"",
  8540			"\"dtor\"",
  8541			"\"from\"",
  8542			"\"import\"",
  8543			"\"construct\"",
  8544			"\"yield\"",
  8545			"\"while\"",
  8546			"\"do\"",
  8547			"\"iterate\"",
  8548			"\"to\"",
  8549			"\"with\"",
  8550			"\"var\"",
  8551			"\"const\"",
  8552			"BECOMES",
  8553			"\"if\"",
  8554			"\"else\"",
  8555			"\"elseif\"",
  8556			"\"typeof\"",
  8557			"\"once\"",
  8558			"\"local\"",
  8559			"\"tagged\"",
  8560			"\"pooled\"",
  8561			"\"manual\"",
  8562			"\"gc\"",
  8563			"\"ref\"",
  8564			"\"in\"",
  8565			"\"out\"",
  8566			"\"generic\"",
  8567			"LBRACK",
  8568			"RBRACK",
  8569			"\"function\"",
  8570			"TOK_ARROW",
  8571			"\"procedure\"",
  8572			"DOT",
  8573			"PLUS_ASSIGN",
  8574			"MINUS_ASSIGN",
  8575			"STAR_ASSIGN",
  8576	
       
  8577	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 63
       
       
  8578			"DIV_ASSIGN",
  8579			"MOD_ASSIGN",
  8580			"SR_ASSIGN",
  8581			"BSR_ASSIGN",
  8582			"SL_ASSIGN",
  8583			"BAND_ASSIGN",
  8584			"BXOR_ASSIGN",
  8585			"BOR_ASSIGN",
  8586			"QUESTION",
  8587			"LOR",
  8588			"LAND",
  8589			"BOR",
  8590			"BXOR",
  8591			"BAND",
  8592			"EQUALITY",
  8593			"NOT_EQUALS",
  8594			"LT_",
  8595			"GT",
  8596			"LTE",
  8597			"GTE",
  8598			"\"is_a\"",
  8599			"SL",
  8600			"SR",
  8601			"BSR",
  8602			"PLUS",
  8603			"MINUS",
  8604			"STAR",
  8605			"DIV",
  8606			"MOD",
  8607			"QIDENT",
  8608			"INC",
  8609			"DEC",
  8610			"BNOT",
  8611			"LNOT",
  8612			"CHAR_LITERAL",
  8613			"NUM_INT",
  8614			"\"block\"",
  8615			"\"closure\"",
  8616			"\"type\"",
  8617			"\"alias\"",
  8618			"\"struct\"",
  8619			"VOCAB",
  8620			"WS_",
  8621			"TIMES",
  8622			"SL_COMMENT",
  8623			"ML_COMMENT",
  8624			"TQUOT",
  8625			"ESC",
  8626			"HEX_DIGIT",
  8627			"EXPONENT",
  8628			"FLOAT_SUFFIX"
  8629		};
  8630		
  8631		private static final long _tokenSet_0_data_[] = { 100765696L, 0L };
  8632		public static final BitSet _tokenSet_0 = new BitSet(_tokenSet_0_data_);
  8633		private static final long _tokenSet_1_data_[] = { 46303767540793600L, 0L };
  8634	
       
  8635	2019-01-11 06:34        tripleo/elijah/ElijahParser.java         Page 64
       
       
  8636		public static final BitSet _tokenSet_1 = new BitSet(_tokenSet_1_data_);
  8637		private static final long _tokenSet_2_data_[] = { 2251992985772288L, 94425317376L, 0L, 0L };
  8638		public static final BitSet _tokenSet_2 = new BitSet(_tokenSet_2_data_);
  8639		private static final long _tokenSet_3_data_[] = { 1267771266564352L, 0L };
  8640		public static final BitSet _tokenSet_3 = new BitSet(_tokenSet_3_data_);
  8641		private static final long _tokenSet_4_data_[] = { -18998186670658816L, 8525975551L, 0L, 0L };
  8642		public static final BitSet _tokenSet_4 = new BitSet(_tokenSet_4_data_);
  8643		private static final long _tokenSet_5_data_[] = { 2251992954315008L, 4231004160L, 0L, 0L };
  8644		public static final BitSet _tokenSet_5 = new BitSet(_tokenSet_5_data_);
  8645		private static final long _tokenSet_6_data_[] = { -69804703401760000L, 8589934591L, 0L, 0L };
  8646		public static final BitSet _tokenSet_6 = new BitSet(_tokenSet_6_data_);
  8647		private static final long _tokenSet_7_data_[] = { 193139310848L, 0L };
  8648		public static final BitSet _tokenSet_7 = new BitSet(_tokenSet_7_data_);
  8649		private static final long _tokenSet_8_data_[] = { 74309398181323008L, 4231004160L, 0L, 0L };
  8650		public static final BitSet _tokenSet_8 = new BitSet(_tokenSet_8_data_);
  8651		private static final long _tokenSet_9_data_[] = { 2251799814742272L, 4231004160L, 0L, 0L };
  8652		public static final BitSet _tokenSet_9 = new BitSet(_tokenSet_9_data_);
  8653		private static final long _tokenSet_10_data_[] = { -69805532364135680L, 4294967295L, 0L, 0L };
  8654		public static final BitSet _tokenSet_10 = new BitSet(_tokenSet_10_data_);
  8655		private static final long _tokenSet_11_data_[] = { 193139310848L, 4294967296L, 0L, 0L };
  8656		public static final BitSet _tokenSet_11 = new BitSet(_tokenSet_11_data_);
  8657		private static final long _tokenSet_12_data_[] = { 46303767540269312L, 0L };
  8658		public static final BitSet _tokenSet_12 = new BitSet(_tokenSet_12_data_);
  8659		private static final long _tokenSet_13_data_[] = { -91055780708586752L, 8525975551L, 0L, 0L };
  8660		public static final BitSet _tokenSet_13 = new BitSet(_tokenSet_13_data_);
  8661		private static final long _tokenSet_14_data_[] = { -138538496557310L, 17179869183L, 0L, 0L };
  8662		public static final BitSet _tokenSet_14 = new BitSet(_tokenSet_14_data_);
  8663		private static final long _tokenSet_15_data_[] = { 46303767540285696L, 0L };
  8664		public static final BitSet _tokenSet_15 = new BitSet(_tokenSet_15_data_);
  8665		private static final long _tokenSet_16_data_[] = { -73041382199104768L, 8525975551L, 0L, 0L };
  8666		public static final BitSet _tokenSet_16 = new BitSet(_tokenSet_16_data_);
  8667		private static final long _tokenSet_17_data_[] = { -137359513889117440L, 8589934591L, 0L, 0L };
  8668		public static final BitSet _tokenSet_17 = new BitSet(_tokenSet_17_data_);
  8669		private static final long _tokenSet_18_data_[] = { -18997361936171262L, 17179869183L, 0L, 0L };
  8670		public static final BitSet _tokenSet_18 = new BitSet(_tokenSet_18_data_);
  8671		private static final long _tokenSet_19_data_[] = { 2251799814758656L, 4231004160L, 0L, 0L };
  8672		public static final BitSet _tokenSet_19 = new BitSet(_tokenSet_19_data_);
  8673		private String _semPredNames[] = {
  8674		};
  8675		
  8676		}
  8677	
       
  8678	2019-01-11 06:34             tripleo/elijah/Main.java             Page 1
       
       
  8679	package tripleo.elijah;
  8680	 
  8681	// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
  8682	// Jad home page: http://www.geocities.com/kpdus/jad.html
  8683	// Decompiler options: packimports(3) 
  8684	// Source File Name:   Main.java
       
  8685	import java.io.*;
       
  8686	import antlr.ANTLRException;
       
  8687	public class Main {
       
  8688		public static void main(String args[]) {
  8689			try {
  8690				if (args.length > 0) {
  8691					for (int i = 0; i < args.length; i++)
  8692						if (args[i].equals("-showtree"))
  8693							showTree = true;
  8694						else
  8695							doFile(new File(args[i]));
       
  8696				} else {
  8697					System.err
  8698							.println("Usage: java Main [-showtree] <directory or file name>");
  8699				}
  8700			} catch (Exception e) {
  8701				System.err.println((new StringBuilder("exception: ")).append(e)
  8702						.toString());
  8703				e.printStackTrace(System.err);
  8704			}
  8705		}
       
  8706		public static void doFile(File f) throws Exception {
  8707			if (f.isDirectory()) {
  8708				String files[] = f.list();
  8709				for (int i = 0; i < files.length; i++)
  8710					doFile(new File(f, files[i]));
       
  8711			} else if (f.getName().length() > 3
  8712					&& f.getName().substring(f.getName().length() - 3)
  8713							.equals(".os")) {
  8714				System.out.println((new StringBuilder("   ")).append(
  8715						f.getAbsolutePath()).toString());
  8716				parseFile(f.getName(), new FileInputStream(f));
  8717			}
  8718		}
       
  8719		public static void parseFile(String f, InputStream s) throws Exception {
  8720			try {
  8721				ElijahLexer lexer = new ElijahLexer(s);
  8722				lexer.setFilename(f);
  8723				ElijahParser parser = new ElijahParser(lexer);
  8724				parser.out = new Out();
  8725				parser.setFilename(f);
  8726				parser.program();
  8727	
       
  8728	2019-01-11 06:34             tripleo/elijah/Main.java             Page 2
       
       
  8729			} catch (ANTLRException e) {
  8730				System.err.println(("parser exception: "+e));
  8731				e.printStackTrace();
  8732			}
  8733		}
       
  8734		static boolean showTree = false;
       
  8735	}
  8736	
       
  8737	2019-01-11 06:34             tripleo/elijah/Out.java              Page 1
       
       
  8738	package tripleo.elijah;
  8739	 
  8740	// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
  8741	// Jad home page: http://www.geocities.com/kpdus/jad.html
  8742	// Decompiler options: packimports(3) 
  8743	// Source File Name:   Out.java
       
  8744	import java.io.*;
       
       
  8745	import tripleo.elijah.gen.java.JavaCodeGen;
  8746	import tripleo.elijah.lang.*;
  8747	import tripleo.elijah.util.TabbedOutputStream;
       
  8748	public class Out {
       
  8749		public void FinishModule() {
  8750			TabbedOutputStream tos;
  8751			println("** FinishModule");
  8752			tos = null;
  8753			try {
  8754				tos = new TabbedOutputStream(new FileOutputStream("oscc.out"));
  8755	//			pc.module.print_osi(tos);
  8756				pc.module.finish(tos);
  8757				//
  8758				final JavaCodeGen visit = new JavaCodeGen();
  8759				pc.module.visitGen(visit);
  8760			} catch (FileNotFoundException fnfe) {
  8761				println("&& FileNotFoundException");
  8762			} catch (IOException ioe) {
  8763				println("&& IOException");
  8764	//		} catch (Exception exception) {
  8765	//			try {
  8766	//				tos.close();
  8767	//			} catch (IOException ioe) {
  8768	//				println("&& IOException");
  8769	//			}
  8770	////			try {
  8771	////				println((new StringBuilder("[incorrect] stringstack.top = "))
  8772	////						.append((String) stringStack.top()).toString());
  8773	////			} catch (NoSuchElementException nsee) {
  8774	////				println("stringstack empty [correct]");
  8775	////			}
  8776	////			try {
  8777	////				println((new StringBuilder("[incorrect] exprstack.top = "))
  8778	////						.append(((IExpression) exprStack.top()).repr_())
  8779	////						.toString());
  8780	////			} catch (NoSuchElementException nsee) {
  8781	////				println("exprstack empty [correct]");
  8782	////			}
  8783	//			throw exception;
  8784			}
  8785	//		try {
  8786	//			tos.close();
  8787	//		} catch (IOException ioe) {
  8788	//			println("&& IOException");
  8789	
       
  8790	2019-01-11 06:34             tripleo/elijah/Out.java              Page 2
       
       
  8791	//		}
  8792	//		try {
  8793	//			println((new StringBuilder("[incorrect] stringstack.top = "))
  8794	//					.append((String) stringStack.top()).toString());
  8795	//		} catch (NoSuchElementException nsee) {
  8796	//			println("stringstack empty [correct]");
  8797	//		}
  8798	//		try {
  8799	//			println((new StringBuilder("[incorrect] exprstack.top = ")).append(
  8800	//					((IExpression) exprStack.top()).repr_()).toString());
  8801	//		} catch (NoSuchElementException nsee) {
  8802	//			println("exprstack empty [correct]");
  8803	//		}
  8804			return;
  8805		}
       
  8806		public ProcedureCall popProcCall() {
  8807			return null;
  8808		}
       
  8809		public void beginProcCallEx2() {
  8810		}
       
  8811		public void beginProcCall() {
  8812		}
       
  8813		public void endProcCall() {
  8814		}
       
       
  8815		public void pushString(String s) {
  8816			println((new StringBuilder("** Pushing Ident ")).append(s).toString());
  8817		}
       
  8818		public void pushCharLit(String s) {
  8819		}
       
  8820		public void pushMultiply() {
  8821		}
       
       
  8822		public void pushTypeRef(TypeRef tr) {
  8823			println((new StringBuilder("** pushing typeref ")).append(tr.repr_())
  8824					.toString());
  8825		}
       
  8826		private void print(String s) {
  8827			System.out.print(s);
  8828		}
       
  8829		private void println(int s) {
  8830			System.out.println(s);
  8831		}
       
  8832		public void println(String s) {
  8833			System.out.println(s);
  8834	
       
  8835	2019-01-11 06:34             tripleo/elijah/Out.java              Page 3
       
       
  8836		}
       
  8837		private void print3(String s1, String s2, String s3) {
  8838			System.out.print(s1);
  8839			System.out.print(s2);
  8840			System.out.print(s3);
  8841		}
       
  8842		private void println(String s1, String s2) {
  8843			System.out.print(s1);
  8844			System.out.println(s2);
  8845		}
       
  8846		private void printpln(String s1, String s2) {
  8847			System.out.print(s1);
  8848			System.out.print('(');
  8849			System.out.print(s2);
  8850			System.out.println(')');
  8851		}
       
  8852		private ParserClosure pc;
       
  8853		public ParserClosure closure() {
  8854			return pc=new ParserClosure();
  8855		}
       
  8856	}
  8857	
