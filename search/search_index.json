{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Elijjah","text":"<p>https://github.com/elijah-team/elijah-lang-lgpl/tree/stable</p>"},{"location":"#certainly","title":"Certainly","text":"<p>Elijjah is:</p> <ul> <li>... a high-level language suitable for replacement of legacy languages.</li> <li>... meant to integrate into these projects.</li> </ul>"},{"location":"#definitely","title":"Definitely","text":"<ul> <li>It will feature a REPL and a graphical environment as well,   along the lines Smalltalk/Tunes Slate.</li> </ul>"},{"location":"#xx","title":"xx","text":"<p>It is free software intended for use on all systems, including GNU/Linux.</p>"},{"location":"#usage","title":"Usage","text":"<p>Other Software Required: * antlr (included) * javassist (not used yet, but included) * python (not yet) * java-compiler (java8)</p>"},{"location":"#status","title":"Status","text":"<ul> <li> <p>The repo is currently buildable from maven.  You can also import into Eclipse and IDEA   and get up and running.  The tests need to run run from the root directory, which is   done automatically in maven but not IDEA.</p> </li> <li> <p>Much work is needed.</p> </li> <li> <p>See Language Overview for more details on the language.</p> </li> <li> <p>All of this is a work in progress and your support would be appreciated.</p> </li> </ul>"},{"location":"access_notation/","title":"Access Notation","text":"<p>The <code>access</code> notation is used for to purposes:</p> <ul> <li>Controlling which classes have access to member functions and member variables</li> <li>Putting members into sections/categories (a la Smalltalk)</li> </ul>"},{"location":"access_notation/#syntax","title":"Syntax","text":"<pre><code>access QUOTED_STRING:section IDENT:shortname = LCURLY typeNameList RCURLY\n</code></pre> <p>For example</p> <pre><code>access Q = {A, B, C}\n</code></pre> <pre><code>access Q\n</code></pre> <p>will now allow the same access as above. See <code>Q</code> is a shortname</p>"},{"location":"aliases/","title":"Aliases","text":""},{"location":"keywords/","title":"Keywords","text":"<code>abstract</code> Used to introdude an abstract class after the keyword <code>class</code> Used to introduce an abstract function (use instead of the function body) <code>access</code> Used to introduce an access clause <code>alias</code> Used to introduce an alias <p><code>as</code></p> <p><code>break</code></p> <p><code>case</code></p> <p><code>cast_to</code></p> <p><code>class</code></p> <p><code>const</code></p> <ul> <li>Used to introduce a <code>const</code> variable, whose value cannot change and whose type is also <code>const</code>-whatever</li> <li>Used to introduce a <code>const</code> function, in furtherance of const-correctness, which means that a function      cannot change the state of an object</li> </ul> <p><code>construct</code></p> <p><code>constructor</code></p> <p><code>continue</code></p> <code>ctor</code> An alias for <code>constructor</code> <code>def</code> Used to introduce a <code>def</code> function, which contains only one expression.  It still must be called with parentheses, though. <p><code>destructor</code></p> <code>do</code> Contrary to Rust, Elijjah includes a do-while loop.  I don't know for  how long, I may want to do (!) something else with this keyword. <p><code>dtor</code></p> <p><code>else</code></p> <p><code>elseif</code></p> <p><code>false</code></p> <p><code>from</code></p> <p><code>func</code></p> <p><code>function</code></p> <p><code>generic</code></p> <p><code>if</code></p> <p><code>immutable</code></p> <p><code>import</code></p> <p><code>in</code></p> <p><code>indexing</code></p> <p><code>interface</code></p> <p><code>invariant</code></p> <p><code>is_a</code></p> <p><code>iterate</code></p> <p><code>match</code></p> <p><code>namespace</code></p> <p><code>null</code></p> <p><code>out</code></p> <p><code>package</code></p> <code>proc</code> Short for <code>procedure</code> <p><code>procedure</code></p> <p><code>ref</code></p> <code>return</code> Used for early return from functions.  It can return a value.  See Result <p><code>signature</code></p> <p><code>struct</code></p> <p><code>this</code></p> <p><code>to</code></p> <p><code>true</code></p> <p><code>type</code></p> <p><code>typeof</code></p> <p><code>val</code></p> <p><code>var</code></p> <p><code>while</code></p> <p><code>with</code></p> <p><code>yield</code></p>"},{"location":"language-overview/","title":"Language Overview","text":""},{"location":"language-overview/#elijjah-programming-language","title":"Elijjah (programming language)","text":"<p>Elijjah is a multi-paradigm systems and applications programming language with an emphasis on making the programmer's life easier. It is statically typed while using type deduction where possible and it supports both functional and object oriented paradigms.</p> <p>It is intended to provide the power of C++, the expressibility of Python, and the utility of Java.  The code the reference compiler generates if C/C++ or Java is intended to complement each and every one of those in any combination.  It can reliably interact with Java libraries or C/C++ libraries like Swing/JavaFX, SWT, boost, or gtk and Qt.</p>"},{"location":"language-overview/#contents","title":"Contents","text":"<ul> <li>1 History</li> <li>2 Philosophy</li> <li>3 Syntax</li> <li>4 Memory safety</li> <li>3 Syntax<ul> <li>3.1 Design and Features</li> <li>3.2 Ownership</li> <li>3.3 Types and polymorphism</li> <li>3.4 Main Entry Point</li> <li>3.5 Extension Methods</li> <li>3.6 Operator Overloading</li> <li>3.7 Higher Order Functions</li> </ul> </li> <li>4 Tools</li> <li>5 Unimplemented Things</li> </ul>"},{"location":"language-overview/#history","title":"History","text":"<p>In the early 2000s the author became disillusioned with the then current state of the language landscape.  Namely the frustrating complexity of C++ and the frustrating simplicity of Java, arguably the two most popular languages at the time.</p> <p>Due to unforeseen circumstances, the compiler is just now being produced and released, hopefully to widespread acclaim or niche acceptance.  The author hopes that Elijjah can achieve what Java, D and Vala could not.</p> <p>The language has evolved over time from a simple JavaScript clone to a full-fledged programming language fit to challenge today's top contenders.  </p>"},{"location":"language-overview/#philosophy","title":"Philosophy","text":"<p>The author states that Elijjah is designed to be an industrial strength object-oriented language, and a better language that C++ and Java, but to still be interoperable with either, allowing programmers to make a gradual transition to Elijjah.</p> <p>Semicolons are optional as a statement terminator , though whitespace is ignored in the current compiler,  eventually a newline should be enough to deduce that the statement has ended.</p>"},{"location":"language-overview/#syntax","title":"Syntax","text":"<p>The concrete syntax of Elijjah is similar to C/C++ and Java with hints from JavaScript, Python, and Eiffel.  Blocks of code are delimited by curly braces and control flow keywords such as <code>if</code>, <code>else</code>, and <code>while</code> are allowed.  As of now <code>for</code> is not supported and <code>foreach</code> is available as <code>iterate</code>.</p> <p>A function is composed of expressions and statements.  Everything other than a function call or a variable assignment is a statement.  A function need not end with a return statement (if enabled), but the return value must be assigned to a special variable <code>Result</code>.</p>"},{"location":"language-overview/#memory-safety","title":"Memory safety","text":"<p>Elijjah has an option for using a garbage collector of the prrogrammer's choice whwen using C/C++ backend, otherwise it uses the default model of its backend.</p> <p>Resource acquisition is initialization (RAII), and optional reference counting are both supported. </p> <p>Overall, the memory safety of your program depends on the backend used and the non-abuse of features like <code>C.Pointer</code> and <code>Pointer</code> (and unsafe if implemented.)</p>"},{"location":"language-overview/#syntax_1","title":"Syntax","text":"<p>Class members are public by default and classes themselves are open by default, though member access control can be fine grained, and classes can be prevented from derivarion by using the @Sealed annotation.</p> <p>In addition to classes and methods (called member functions in Elijjah) of OOP, Elijjah also supports the use of functions without class instantiation using namespaces.  This can be useful when interacting with C.</p> <p>Semicolons are optional as a statement terminator; in most cases a newline is sufficient for the compiler to deduce that the statement has ended.</p> <p>Elijjah variable declarations and parameter lists have the data type (optionally, and then inferred) come after the variable name (and with a colon), similar to Pascal.</p> <p>Variables in Elijjah can be immutable, declared with the <code>val</code> keyword, or mutable, declared with the <code>var</code> keyword.</p>"},{"location":"language-overview/#design-and-features","title":"Design and Features","text":"<p>It is hoped that Elijjah will be useful in concurrent systems though at this time no features specially exist to facilitate this,  The main safety feature of Elijjah is a more evolved type system using <code>datatype</code> and <code>match</code> and providing the now popular Option type. (called Maybe).</p> <p>Maybe the language will evolve concurrency and safety features present in other languages like Rust and Erlang.  The programmer has fine-grained control of memory layout (using <code>struct</code>s) where applicable (meaning largely using the C/C++ backends, though transparent access to C/C++ objects is supported).  Performance of idiomatic Elijjah is comparable to that of idiomatic C++.</p> <p>Elijjah also supports const correctness and immutable functions, where an object is not allowed to be modified in any way.</p>"},{"location":"language-overview/#ownership","title":"Ownership","text":"<p>Maybe the <code>borrow</code> keyword will be implemented one day.</p>"},{"location":"language-overview/#types-and-polymorphism","title":"Types and polymorphism","text":"<p>Where not explicit, the types of variables (and values honestly) are deduced by the compiler.  If this proves insufficient over time , a proper type inferencer will  be adopted.</p> <p>Both function and classes can be given generic parameters, and class <code>signature</code>s can be used to require a class to implement a certain interface without raxing the type system.  TGhe implementation of generics is similar to the typical implementation of C++ templates: a separate copy of the code is generated for each instantiation. This is called monomorphization and contrasts with the type erasure scheme typically used in Java and Haskell. The benefit of monomorphization is optimized code for each specific use case; the drawback is increased compile time and size of the resulting binaries.</p> <p><code>struct</code>s are used to control memory layout. Structs cannot fully participate in OOP aand member function on structs must be resolvable statically.</p> <p>There are no static members in Elijjah.  This functionality is implemented by <code>namespace</code>s, each of which is a singleton and can be counted on to exist only once in an entire program. (Note that multi-threading behavior is undefined here.)</p>"},{"location":"language-overview/#main-entry-point","title":"Main entry point","text":"<p>The entry point for every program is a class called Main and a function called main, and must not be part of a namespace or class.  Other considerations exist for dlls and maybe applets or something.  You must get system level arguments by inheriting Arguments class.  In addition, the file should be in a directory by itself.  There are no other file restrictions.</p>"},{"location":"language-overview/#extension-methods","title":"Extension methods","text":"<p>Similar to C# and Kotlin (and conceived independently), Elijjah allows a user to add methods to any class without the formalities of creating a derived class with new methods. Instead, Elijjah adds the concept of an extension method which allows a function to be \"glued\" onto the public method list of any class without being formally placed inside of the class. In other words, an extension method is a helper method that has access to all the public interface of a class which it can use to create a new method interface to a target class and this method will appear exactly like a method of the class, appearing as part of code completion inspection of class methods. For example:</p> <pre><code> package MyStringExtensions\n\nextend String { \n  def lastChar(): Char = get(Length - 1)\n}\n\n &gt;&gt;&gt; println(\"Elijjah\".lastChar())\n</code></pre> <p>This means a user can package a customization layer of a library into a namespace which is subsequently imported for use in other modules.</p>"},{"location":"language-overview/#operator-overloading","title":"Operator overloading","text":"<p>Operator overloading is accomplished in the same fashion as Python, by implementing a specially named function, such as <code>__add__</code>, <code>__lshift__</code>, <code>__divide__</code>, etc.</p> <p>Note that constructors are declared with the <code>constructor</code> keyword (shortcut <code>ctor</code>), and destructors are declared with the <code>destructor</code> keyword (shortcut <code>dtor</code>).</p>"},{"location":"language-overview/#higher-order-functions","title":"Higher-order functions","text":"<p>Elijjah provides support for higher order functions and anonymous functions or lambdas.</p> <pre><code>// the following function takes a lambda, f, and executes f passing it the string, \"lambda\"\n// note that (s: String) -&gt; Unit indicates a lambda with a String parameter and Unit return type\nclass Foo {\n  executeLambda(f: function(s: String) -&gt; Unit) {\n    f(\"lambda\")\n  }\n}\n</code></pre> <p>Lambdas are declared using braces, <code>{|| }</code> . If a lambda takes parameters, they are declared within the <code>||</code> a la Smalltalk.</p> <p>~~~~// the following statement defines a lambda that takes a single parameter and passes it to the println function val l s= { |c : Maybe[Any]|  println(c.unwrap()) } }</p> <p>probably should be:</p> <p>val l s= { |c : Maybe[Any]|  match c {Some[d:Any] {println(d)} _ {} } } // lambdas with no parameters may simply be defined using { } val l2 = { || print(\"no parameters\") } ~~~~</p>"},{"location":"language-overview/#tools","title":"Tools","text":"<ul> <li>Integration with common Java build tools is planned including Apache Maven, Apache Ant, and Gradle. Also support for Cmake and Bazel.  Integration with GObject and Python are planned features.</li> </ul>"},{"location":"language-overview/#unimplemented-things","title":"Unimplemented things","text":"<ul> <li>Kotlin/Python's spread (*) operator</li> <li>Kotlin Deconstructor methods</li> <li>Python multiple assignment ( const (x, y, z) coming soon)\\</li> <li>String interpolation (uses Python method (%); ${scope} coming)</li> <li>Kotlin/Groovy safe navigation, elvis operator</li> <li>Kotlin overly complex hello world example</li> <li>REPL</li> </ul>"},{"location":"type_names/","title":"Type Names","text":"<p>There a four type of type names in Elijjah.</p> <ol> <li>Generic</li> </ol> <pre><code>(?|\"generic\") IDENT\n</code></pre> <ol> <li>Typeof</li> </ol> <pre><code>\"typeof\" QUALIDENT\n</code></pre> <ol> <li>Normal</li> </ol> <pre><code>IDENT[IDENT (, IDENT)*]\n</code></pre> <ol> <li>Function</li> </ol> <pre><code>(\"func\"|\"proc\") IDENT LPAREN args RPAREN -&gt; returnType\n</code></pre> <p>Obviously for a <code>proc</code>, one doesn't include the return type.</p>"}]}